{
    "text_curriculum\\University of York.pdf": [
        "Course Outlines\nYear 1\nFOUNDATIONS OF PROGRAMMING FOR COMPUTER SCIENCE\nModule summary\nFoundations of Programming for Computer Science\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nStudents will be introduced to different programming constructs, basic data structures,\ncommand line tools, integrated development environments and unit testing of programs.\nStudents will learn how to describe well-defined tasks using pseudocode and translate them into\nprograms using a procedural programming paradigm. The module will be taught using a\nprocedural language for practising these skills.\nModule learning outcomes\nS101 Describe and apply the fundamental concepts of procedural programming. Write small\nprocedural programs from scratch to perform well-defined tasks, following well-defined\nrequirements, in a procedural programming language like Python. Relate the syntax of the\nlanguage to its semantics, and analyse the result of executing fragments of syntax. Integrate\nlibrary code with their own programs using appropriate software tools.\nS102 Implement bespoke data structures to store states of a process. Implement simple\nalgorithms written in pseudocode. Develop programs incrementally, using simple tests\n(automated where appropriate) to check each increment.\nS103 Store data in memory in standard built-in collection types, and to store and retrieve data\nfrom simple text files such as CSV and JSON files.\nS104\nUse an appropriate software development environment, such as Eclipse, IntelliJ or VS Code.\nGiven a program and a debugging tool, students will be able to identify and correct bugs which\nprevent the program from functioning as intended.\nS105\nOrganise and document program code following the principles of software engineering. Write\ndocumentation to explain the design and implementation of their own code, or example code\nwhich is supplied to them.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone",
        "Indicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, formative assessments, and after the\nfinal assessment as per normal University guidelines.\nIndicative reading\nAllen B. Downey - Think Python: How to Think Like a Computer Scientist - 2nd ed. (2015),\nO'Reilly Media\nMike Dawson - Python programming for the absolute beginner - 3rd ed. (2010) - Course\nTechnology\nKent D. Lee and Steve Hubbard - Data structures and algorithms with Python (2015), Springer",
        "MATHEMATICAL FOUNDATIONS OF COMPUTER SCIENCE\nModule summary\nMathematical Foundations of Computer Science\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nStudents will be introduced to the key discrete mathematics concepts that are the foundation of\ncomputer science. Seven topics are covered as follows: i) counting (combinatorics), ii) discrete\nprobability, iii) graphs, iv) propositional and predicate logic, v) proofs and sets, vi) relations on\nsets, and vii) relations on a single set. After studying the module, students will be able to apply\nthe learnt concepts, theories and formulae in real-world examples of computational problems.\nModule learning outcomes\nT101 Define, read and apply mathematical notations for the purpose of describing\nmathematical concepts from across discrete mathematics.\nT102 Select appropriate techniques to prove properties related to discrete mathematics\nconcepts.\nT103 Understand how to construct sets of elements with certain properties and determine their\ncardinality using counting formulae from combinatorics.\nT104 Understand and apply basic set theory, including formally defining set relations and\noperations.\nT105 Describe and use the basic concepts of discrete probability to describe events, with an\nunderstanding of joint, conditional and marginal probabilities, Bayes\u2019 theorem, expectation,\ncovariance and correlation.\nT106 Formally define and illustrate by example graphs of different graph classes, such as\nsimple, undirected, directed, weighted, directed acyclic, connected, disconnected and trees -\nwith an understanding of how they may be used in real-world computational problems.\nT107 Apply a variety of techniques to identify whether logical expressions are true or false,\nvalid or invalid or equivalent to one another, and be able to apply logical statements to describe\nreal-world logical problems.\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback",
        "Feedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n** Dean N., The Essence of Discrete Mathematics, Prentice Hall, 1997\n** Haggarty R., Discrete Mathematics for Computing, Addison Wesley, 2002\n** Truss J., Discrete Mathematics for Computer Scientists, Addison Wesley, 1999\n** Gordon H., Discrete Probability, Springer, 1997\n* Solow D., How to Read and Do Proofs, Wiley, 2005",
        "HUMAN-COMPUTER INTERACTION\nModule summary\nHCIN introduces user-centred design. Where other modules focus on technical understanding\nof computers and how they work, this module is instead about understanding the relationship\nbetween computer systems and people. It discusses how this can be used to improve system\ndevelopment, and how it can go wrong. We will explore the nature of and barriers to people's\ninteractions with computers and how systems can be designed to optimise and facilitate these\ninteractions. We will also consider how to evaluate the people's experience - what makes a\ngood, enjoyable human-computer interaction.\nRelated modules\nThe assessment is undertaken as a group open assessment in which groups will work together\nto complete and present a user-centred design task. The assessment also includes as part of\nthe submission an individual reflection exercise which is worth 10% of the overall marks. This\ntask asks students to comment on their development of transferable skills (using the York\nStrengths Framework as a basis) and how they have developed these during HCIN. The\nassessment also has a peer-assessment exercise, which ensures that individual contributions to\nthe group are accounted for in the final marks.\nReassessment is by an individual open assessment which requires students to understand and\nimplement the processes and techniques discussed during the module.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nStudents taking this module will be familiarised with how to design user-centred systems that\nmeet the needs and preferences of diverse users. Students will be introduced to the notion of\nengineering lifecycles, and in particular building requirements from user needs, iterative\nprototyping and evaluation of interactive systems. Students will undertake group work in\npracticals, giving them opportunities to develop communication and conflict resolution skills. The\nassessment will evaluate knowledge of the user-centred design process and interaction design\nprinciples.\nModule learning outcomes\nDescribe why user-centred design in software development is important to usable and inclusive\ndesign.\nUndertake a user-centred design process as a cyclical approach through the key stages of user\nneeds elicitation, conceptual design, prototyping, and evaluation.\nApply appropriate interaction design concepts in describing user-system interaction including:\naffordances, feedforward, feedback, conceptual model.",
        "Advocate for the ethical treatment of participants throughout the user-centred design lifecycle,\nand explain how user diversity can impact on the inclusiveness of a system.\nDescribe how interactive systems are embedded in societal structures, and how they are used\nto invoke change at the personal, community, national or international level.\nPlan and manage deliverables to set deadlines throughout a project lifecycle, and use a\nself-reflective skills assessment to improve student team working and team performance.\nIndicative assessment\nTask % of module mark\nEssay/coursework 10\nGroupwork 90\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, formative assessments, and after the\nfinal assessment as per normal University guidelines.\nIndicative reading\n*** Preece, J., Rogers, Y., Sharp, H., Interaction Design, 4th edn Wiley, 2015\n*** Cooper, A., Reimann., R., Cronin., D., Noessel., C. About Face: The Essentials of Interaction\nDesign. 4th edn Wiley, 2014.\n* Mackenzie, I.S. Human-Computer Interaction. Elsevier Inc., 2013.\n* Norman, D. The Design of Everyday Things. Any edition.",
        "OBJECT-ORIENTED DATA STRUCTURES AND ALGORITHMS\nModule summary\nObject Oriented Data Structures and Algorithms\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents begin to program key data structures such as stacks, queues, trees and graphs. They\nare introduced to the idea of complexity of an algorithm, and how to characterise time and\nspace through formal notations and proof techniques. Students are taught using an object\noriented language like Java, and learn the basics of test driven development for testing their\ncode and demonstrating its successful running. Students are also introduced to several\nalgorithm design paradigms such as greedy algorithms.\nModule learning outcomes\nS201\nImplement an object oriented design. This includes organising program code into modules using\nmethods following the software engineering principles of modularity and abstraction, and\nassembling data and methods into classes at an introductory level following the software\nengineering principles of encapsulation and data hiding. Integrate standard library code with\ntheir own programs using appropriate software tools.\nS202\nWrite and test code that conforms to specific interfaces. Identify and correct bugs which prevent\nthe program from functioning as intended.\nS203\nOrganise and document program code following the principles of software engineering.\nGenerate documentation, manually and programmatically, to explain the design and\nimplementation of their own code, or example code which is supplied to them.\nS204\nAnalyse problems in order to confidently design algorithms to solve simple problems,and be\nable to explain how algorithms and Processing programs work. Develop small programs that\nimplement basic algorithmic designs. Argue the correctness of algorithms using inductive proofs\nand invariants.\nS205",
        "Analyse worst-case running times of algorithms using asymptotic analysis and apply the\nknowledge to sorting and searching algorithms, categorising efficiency in time and memory use.\nS206\nCompare between different abstract data structures from linked lists to graphs in order to be\nable to choose an appropriate data structure for a design situation. This includes the major\nsearch, sort, and graph algorithms and their analyses.\nS207\n.Apply algorithmic design paradigms such as greedy and dynamic programming paradigms.\nPresent an argumentation for the choice of a paradigm for a given problem. Describe what an\napproximation algorithm is, the benefit of using approximation algorithms, and analyse the\napproximation factor for such an algorithm.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nModule feedback\nFeedback is provided through work in practical sessions, formative assessments, and after the\nfinal assessment as per normal University guidelines.\nIndicative reading\nSteven S. Skiena - The algorithm design manual - 2nd ed., (2010), Springer\nMichael T. Goodrich, Roberto Tamassia, Michael H. Goldwasser - Data Structures and\nAlgorithms in Java (2014), Wiley Etextbooks\nMitsunori Ogihara - Fundamentals of Java programming (2018), Springer",
        "INTRODUCTION TO COMPUTER ARCHITECTURES\nIntroduction to Computer Architectures\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents taking this module will gain foundations in the key architectural components of a\ncomputer system, how a high level program is executed upon that system, and how a computer\nsystem is constructed in hardware. Students will be introduced to how a computer system is\nconstructed, and how a program implemented in a high level programming language (for\nexample C) executes on that system. Students will be introduced to the basics of computer\narchitecture and program language construction, providing a basis for further study in later\nyears. Students will be introduced to a bottom-up approach, motivated by real examples, taught\nas both lectures and laboratory practicals. Students will be able to describe and apply their\nprogramming skills on real devices and computer systems that are used in many real\napplications today.\nModule learning outcomes\nIdentify the purpose of key computer hardware components such as processors, memories and\nbusses.\nDescribe different data types commonly found in binary systems (e.g. signed vs. unsigned\nintegers), and show how to convert, perform arithmetic, and perform logical operations.\nExpress logical expressions as basic gates, transistors and combinatoric logic circuits\nDescribe the function and limitations of a variety of logical building blocks in the context of\nprocessor architectures\nDescribe the von Neumann Model paradigm of computer architecture, including the fetch\nexecute cycle of instruction processing.\nExplain how operations executed in a processor can be used to implement to higher level\nsequential, conditional and iterative programming language constructs\nBuild a simple system comprised of a CPU, memory and input/output.\nExplain the use of assemblers, compilers and linkers to create executable code for a processor,\nand use such a toolchain develop software for the simple system built in the module\nIdentify potential security problems associated with architecture design.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nAdditional assessment information\nOpen assessment is a long-running task that takes place over a number of weeks.",
        "Indicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n*** J.Hennessy, D.Patterson Computer Architecture: A Quantitative Approach (2nd Edition)\nMorgan Kaufmannn 1990\n*** W.Stallings Computer Organization and Architecture: Design For Performance (8th Edition)\nPearson 2010",
        "FORMAL LANGUAGES AND AUTOMATA\nFormal Languages and Automata\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents taking this module will be introduced to the concepts of formal languages and the\nabstract machines that accept them as a way of describing computation. Students will have a\ndeep understanding of finite automata and pushdown automata, with their associated languages\nand related proof techniques, and will be introduced to more complex machines accepting\ncontext sensitive and recursively enumerable languages for purposes of being able to identify\nand describe them.\nModule learning outcomes\nDescribe and illustrate the concepts of formal languages, automata and grammars, and the\nrelations between them;\nConstruct a variety of abstract machines including: deterministic and non-deterministic finite\nautomata, deterministic and non-deterministic pushdown automata and Turing machines;\nDistinguish different classes of automata, and the languages they accept;\nApply a variety of operations to transform and convert between automata;\nConvert between grammars and automata for regular and context-free languages;\nDemonstrate that a grammar is ambiguous;\nApply the pumping lemma for regular and context-free languages to show a language is not\nregular or context-free respectively;\nDescribe the Chomsky hierarchy;\nIdentify key applications in computing where regular and context-free languages are used in\npractice; and\nUse automata theory as the basis for building lexers and parsers.\nIndicative assessment\nTask % of module mark\nOpen Examination 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOpen Examination 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading",
        "*** Peter Linz, An introduction to formal languages and automata. Sixth Edition. Jones and\nBartlett Computer Science. 2017\n** D.I. Cohen, Introduction to Computer Theory. 2nd Edition. Wiley. 1997\n** Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D., Introduction to Automata\nTheory, Languages and Computation (3rd ed.), Pearson Education, 2013\n** S.H. Rodger and T.W. Finley, JFLAP: An interactive formal language and automata package.\nJones and Bartlett Computer Science. 2006. Available online\n* Martin, John C., Introduction to Languages and the Theory of Computation (4th ed.), McGraw\nHill, 2010\n* Rich, Elaine, Automata, Computability and Complexity, Pearson Education, 2008\n* Sipser, Michael, Introduction to the Theory of Computation (3rd ed.), South-Western College\nPublishing, 2012",
        "Year 2\nDATA: INTRODUCTION TO DATA SCIENCE\nModule summary\nIntroduction to Data Science\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents will be introduced to key concepts required to undertake rigorous and valid data\nanalysis. Students will be introduced to processes for collecting, manipulating and cleaning\ndata, while gaining experience in judging the quality of data sources. Students will be introduced\nto statistical analysis in data science, including correlation, inferential statistics and regression,\nand how to use these tests in a programming environment. Relational databases, SQL, and and\nother database paradigms such as NoSQL, are covered as a way of storing and accessing data.\nA key aim of the module is to solve complex problems and deliver insights about\nmulti-dimensional data.\nModule learning outcomes\nDistinguish between different types of data that are generated in science, engineering and\ndesign, and employ strategies for ensuring data quality.\nRetrieve data from a variety of different data sources in a variety of different formats.\nApply inferential statistics and statistical procedures to test hypotheses about features and\nrelationships within data sets.\nUse appropriate visualisations to present and explore data sets.\nUse databases, both relational and of other paradigms, to store and query data.\nIdentify the ethical concerns regarding the provenance of data, the privacy of individuals, and\nthe impact data analytics can have on society, and apply topics from the code of ethics of a\nprofessional data protection body.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading",
        "*** Spiegelhalter, D., The Art of Statistics: Learning from Data, Pelican, 2019.\n*** VanderPlas, J. Python Data Science Handbook: Essential Tools for Working with Data,\nO\u2019Reilly, 2016.\n** Igual, L. Segui, S. Introduction to Data Science: A Python Approach to Concepts, Techniques\nand Applications, Springer, 2017",
        "SYSTEMS & DEVICES 2: OPERATING SYSTEMS, SECURITY, AND NETWORKING\nModule summary\nSystems & Devices 2: Operating Systems, Security, and Networking\nRelated modules\nPre-requisite modules\nSystems & Devices 1: Introduction to Computer Architectures (COM00011C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module builds on Systems and Devices 1 by examining the system software that executes\nupon a computer system. Students will learn how the resources of the system can be shared by\nmultiple programmes and users, and how networking can be used to communicate between\nprogrammes. One important aspect is how basic security and protection mechanisms are\nprovided by the processor and memory system. Throughout, the module students will consider\npractical examples based on computer systems used today. This module also introduces\nstudents to the core concepts of computer networking by covering the layered network model,\nand discussing the utility and motivation for such an approach. Services that are layered on this\nmodel (such as UNIX sockets, DNS, TCP, IP) are detailed and students will develop software to\nexperiment with these features. After taking this module, students will have an understanding of\nthe role of an operating system, how computers can support multiple time-sliced programmes,\nand how all kinds of computer networks, including the Internet, are created.\nModule learning outcomes\nDemonstrate application programming of OS-supported concurrency, communication and I/O.\nShow how the structure of the OS is supported by computer hardware, with specific reference to\nthe hardware features that extend the basic systems introduced in S&D1.\nUse basic resource management mechanisms provided by common OSes, including time and\nmemory.\nDemonstrate use of the memory protection mechanisms provided by hardware and OSes,\nincluding memory mapped I/O.\nDemonstrate use of the information security provided by the OS in terms of file systems.",
        "Demonstrate concurrent programming at the process level and show how it is supported by, and\nimplemented on, the system hardware.\nLearn to recognise and avoid issues of deadlock, livelock, and starvation.\nBe able to articulate the motivation behind the layered network model\nDevelop software using OS-level networking concepts (i.e. sockets) to communicate with other\nsystems.\nDemonstrate understanding of networked architectures, how they are integrated into an\noperating system, and develop simple applications using this knowledge.\nIndicative assessment\nTask % of module mark\nEssay/coursework 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nSpecial assessment rules\nNone\nAdditional assessment information\nStudents are only required to resit any failed assessment component.\nIndicative reassessment\nTask % of module mark\nEssay/coursework 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n*** Operating System Concepts, Tenth Edition by Silberschatz, Galvin and Gagne, Wiley (2018)\n* A. S. Tanenbaum, Modern Operating Systems, Prentice Hall (2014).\n* W. Stallings, Operating Systems, Internals and Design Principles (9th Edition) Ninth Edition,\nPrentice Hall (2017).",
        "THEORY 3: COMPUTABILITY, COMPLEXITY & LOGIC\nModule summary\nTheory 3: Computability, Complexity and Logic\nRelated modules\nPre-requisite modules\nTheory 2: Formal Languages & Automata (COM00014C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module covers computability theory and complexity theory. In particular, students will learn\nthe concepts of semi-decidable and decidable languages, and Turing-computable functions.\nThey will be able to explain the difference between solvable and unsolvable problems and prove\nunsolvability by reduction. They will understand the time and space complexity of Turing\nmachines, complexity classes such as P, NP, PSpace, NPSpace and NPC, and prove\nNP-completeness by reduction. The module will also introduce basic concepts and results in\npropositional logic, predicate logic, and program verification. In particular, students will learn to\ndistinguish between syntax and semantics, and be able to use formal proof systems such as\nnatural deduction. They will understand the limitations of logic in terms of decidability and\nexpressiveness, and how to use a formal calculus such as Hoare logic to specify programs and\nprove them correct.\nModule learning outcomes\nUse unrestricted grammars and Turing machines to specify semi-decidable languages.\nProvide examples of unsolvable problems and prove that a problem is unsolvable by reducing a\nknown unsolvable problem to it.\nExplain the Church-Turing thesis and its significance.\nDefine the classes P and NP, and explain their relation to the class ExpTime.\nExplain the significance of NP-completeness and provide examples of NP-complete problems.",
        "Explain the meaning of formulas in propositional and predicate logic, and translate such\nformulas into English and vice-versa.\nExplain the fundamental difference between syntax and semantics.\nApply the rules of natural deduction to construct proofs, and determine the truth or falsity of\nformulas in a given model.\nExplain the limitations of logic and the relationship between logic and computability.\nReason deductively about programs using formalisms such as Hoare logic and weakest\npreconditions\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, revision classes, and after the final\nassessment as per normal University guidelines.\nIndicative reading\n**** Martin, John C., Introduction to Languages and the Theory of Computation (4th ed.),\nMcGraw Hill, 2010\n** Rich, Elaine, Automata, Computability and Complexity, Pearson Education, 2008\n** Sipser, Michael, Introduction to the Theory of Computation (3rd ed.), South-Western College\nPublishing, 2012\n* Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D., Introduction to Automata\nTheory, Languages and Computation (3rd ed.), Pearson Education, 2013\n* Arora, Sanjeev and Barak, Boaz, Computational Complexity: A Modern Approach, Cambridge\nUniversity Press, 2009\n++ Garey, Michael R. and Johnson, David S., Computers and Intractability: A Guide to the\nTheory of NP-Completeness, W.H. Freeman, 1979",
        "INTELLIGENT SYSTEMS: MACHINE LEARNING & OPTIMISATION\nModule summary\nMachine Learning & Optimisation.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module introduces the field of Artificial Intelligence, key approaches within the field and\nphilosophical questions such as what it means for a machine to understand. Students will learn\nthe theory and practice of machine learning techniques covering linear regression, simple neural\nnetworks, linear algebra and continuous optimisation. Students will see motivating real world\nproblems, the ML techniques required to solve them, the underlying mathematics needed for the\ntechnique and their practical implementation. Practicals will be taught using Python, and the\ngroup project will introduce the students to a Python-based modern machine learning library\nsuch as TensorFlow or PyTorch.\nModule learning outcomes\nExplain the difference between strong, weak and general AI, understand the relationship\nbetween computation and AI, define the machine learning paradigm, and distinguish it from the\nwider field of AI\nCompute partial derivatives and understand the concept of the gradient as a generalisation of\nthe derivative\nExpress, manipulate and solve systems of linear equations using linear algebra, and apply\nlinear regression and logistic regression\nOptimise multivariate functions using gradient descent\nExplain the concept of overfitting and how regularisation can be used to prevent it\nConstruct a basic neural network using a modern machine learning library and learn its weights\nvia optimisation using the backpropagation algorithm\nDeconstruct ethical arguments relating to AI and its applications, and appreciate the ethical and\nprivacy implications of machine learning\nIndicative assessment\nTask % of module mark\nEssay/coursework 30\nOnline Exam -less than 24hrs (Centrally scheduled) 70\nSpecial assessment rules",
        "None\nIndicative reassessment\nTask % of module mark\nEssay/coursework 30\nOnline Exam -less than 24hrs (Centrally scheduled) 70\nModule feedback\nFeedback is provided through work in practical sessions, and after the assessments as per\nnormal University guidelines.\nIndicative reading\nArtificial Intelligence: A Modern Approach by Russell and Norvig",
        "ENGINEERING 1: SOFTWARE & SYSTEMS ENGINEERING\nModule summary\nIntroduction to Software and Systems Engineering\nRelated modules\nPre-requisite modules\nSoftware 2: Object Oriented Data Structures & Algorithms (COM00016C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis is the students' first opportunity to integrate their skills into a development project. Starting\nfrom a broad problem description and working in groups, students will design, develop and test\na complex system. The students will be introduced to the software engineering terminology,\nlifecycle and processes and will become familiar with principles, techniques and tools for, and\ndevelop hands-on experience of eliciting requirements; defining software architectures;\ndesigning and implementing software in an object-oriented way using established patterns;\nreviewing, testing and refactoring software systems; and setting up continuous integration and\ndelivery processes. Students will also develop an appreciation of how to identify, mitigate and\nmonitor risks, how to manage software projects, and how to reuse and extend 3rd-party\ncode/libraries. Overarching themes of the module will include traceability, cyber-security and\nethical considerations across the engineering lifecycle.\nModule learning outcomes\nE101\nApply an understanding of software engineering terminology, lifecycles and process models, to\nhelp with undertaking a project.\nE102\nElicit and document user and system requirements.\nE103\nArchitect, design and implement software in an object-oriented way.",
        "E104\nDemonstrate how the estimation of risk can be used to improve decision-making, and to make\nrealistic estimates for a project.\nE105\nDefine unit- and system-level tests for software, and use continuous integration processes.\nE106\nApply mechanisms for working in teams to successfully undertake a group project.\nE107\nApply different models for software licensing and reuse of 3rd party software to the artefacts\ndeveloped in the module.\nE108\nDemonstrate consideration of cyber-security and ethical considerations in the engineering\nlifecycle, through practice and documentation.\nE109\nWrite documentation and design/deliver presentations for the different stages of the engineering\nlifecycle.\nIndicative assessment\nTask % of module mark\nGroupwork 35\nGroupwork 65\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 35\nEssay/coursework 65\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines",
        "Indicative reading\n**** Ian Sommerville, Software Engineering (latest edition), Addison-Wesley, 2010\n*** Roger Pressman, Software Engineering (latest edition), McGraw-Hill, 2010",
        "SYSTEMS & DEVICES 3: ADVANCED COMPUTER SYSTEMS\nRelated modules\nPre-requisite modules\nSystems & Devices 1: Introduction to Computer Architectures (COM00011C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module continues the Systems and Devices stream by considering advanced computer\nsystems in terms of their structure and how it affects their programming. To this point, the\nsystems introduced have been basic uniprocessors with simple memory. The module starts by\nintroducing the concept of multiple processor architectures, pipelined and superscalar\nprocessors, systems-on-chip and advanced memory structures, including caches.\nThe rest of the module considers how these hardware features affect the way that such modern\nsystems are efficiently programmed. Issues of programming for pipelines, caches, etc. are\nconsidered. Then how processes running in parallel on separate processors can share\nunderlying resources safely. Finally, the module considers building blocks for parallel\nprogramming, e.g. threads and communication. It will also consider how such constructs map to\nprocessor instructions. The module will consider real-world examples throughout.\nModule learning outcomes\nS301\nAppreciate how, and why, the hardware structure of multiprocessor architectures differs from the\narchitectures discussed in S&D1. Use this knowledge to develop software applications for such\narchitectures.\nS302\nUse knowledge of computer system design concepts to evaluate the likely performance of a\nproposed computer architecture.\nS303",
        "Demonstrate the ability to optimise software for advanced hardware features like caches,\nbranch predictors, and pipelines.\nS304 Demonstrate through software development, how data structures are laid out in memory,\nhow they can be accessed from a program, and how processor instructions are generated to\nmanipulate them.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone\nAdditional assessment information\nStudents will only need to retake failed assessment components.\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines\nIndicative reading\n**** H. Abelson, and G.J. Sussman, Structure and Interpretation of Computer Programs, MIT\nPress, 1996\n*** R.W. Sebesta, Concepts of Programming Languages, Addison Wesley, 2009\n*** A. Burns and G. Davis, Concurrent Programming, Addison-Wesley, 1993\n** D. Watt and W. Findlay, Programming Language Design Concepts, Wiley, 2004\n** T.W. Pratt and M.V. Zelkowitz, Programming Languages: Design and Implementation,\nPrentice Hall, 2001\n** D. Lea, Concurrent Programming in Java, Addison Wesley, 1996\n** A. Burns and A. Wellings, Concurrent and Real-Time Programming in Ada, CUP, 2007\n** F. Casarini and S. Thompson, Erlang Programming, O'Reilly, 2009\n** A. Burns and A. Wellings, Real-Time Systems and Languages 4/e, Addison Wesley",
        "Year 3\nCAPSTONE PROJECT (PRBX): COMPUTER SCIENCE (UG)\nProfessional requirements\nPlease see the additional assessment information above.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26 to Semester 2 2025-26\nModule aims\nThe aims of this module are to provide a culmination of three years' teaching in a substantial\nCapstone Project Module (CPM).The project provides an introduction to independent study in\nan engineering context, supports synthesis and application of material from the degree course,\nand gives the student the opportunity to demonstrate an appreciation of engineering methods\nand techniques, through coverage of requirements, ethical considerations, specification, design,\nimplementation and evaluation. On completion of the project, the student will have gained the\npractical skills that can only be gleaned from the experience of undertaking independent\n(supervised) study. The student will also have the experience of having written a substantial\nacademic report.\nModule learning outcomes\nDemonstrate acquired specialisation in a particular part of the subject area, including enhanced\nor new technical skills that build on taught theory.\nDemonstrate acquired skills to undertake a computer systems (software and/or hardware)\nengineering project, including design, implementation and evaluation.\nDemonstrate a practical understanding of how established techniques of research and enquiry\nare used to create and interpret knowledge.\nRecognise alternatives, selecting and justifying the approach taken at each point in the report,\nidentifying parts of the project area that are feasible within the time (etc) constraints of the\nproject.\nAppreciate the latent issues of the subject area (for example, in software engineering they might\nmeet and tackle such as emergent requirements, design flaws, equipment/application\nproblems).\nPrepare a written report on the work done, according to the defined criteria. In particular, the\nstudent should be able to prepare a report with a good structure and clear presentation, and in\nwhich the referencing is of publishable academic standard. The report must demonstrate critical\nabilities and evaluation of work done and methods applied.",
        "Articulates an understanding of legal, ethical, social, professional and commercial issues\ninvolved in the project, detailing potential issues and mitigation strategies.\nSummarise the context, method, results, and implications of the project in an engaging form for\na non-expert audience.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNon-compensatable\nAdditional assessment information\nPlease note, as per University of York assessment regulations (see the Rules for Progression\nand Award), it is only possible to resit UG Capstone Project Modules (CPMs) when this is\npermitted within the total module credit resit threshold for the year. Currently, this threshold is 60\nmodule credits.\nDue to PSRB (accreditation requirements) there are also special assessment rules that apply to\nPRBX. First PRBX cannot be compensated. Second, only in the case of marginal fail of PRBX\n(marks that fall within 30-39), reassessment is permitted. Students are given the opportunity to\nmake amendments to enable them to reach a pass threshold, within a specified time frame. The\nmark for the resubmitted PRBX will be capped at the pass mark (40). There will only be one\nsuch reassessment. These rules are applicable to all students who take PRBX, regardless of\nprogramme.\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback on written report draft (where draft provided to supervisor in a timely manner).\nWritten feedback after written project report.\nIndicative reading\n*** Dawson, C. W Projects in Computing and Information Systems. Addison-Wesley 2005\n*** Gowers, E. The complete plain words. Penguin 1987\n*** Kopka, H and Daly, P.W. A guide to LATEX : document preparation for beginners and\nadvanced users, 3rd edn. Addison-Wesley 1999\n*** Zobel, J. Writing for computer science, 2nd edn. Springer 2004",
        "AI PROBLEM SOLVING WITH SEARCH AND LOGIC\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent, plus good knowledge of AI fundamentals, predicate logic and\nprogramming.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module will introduce key approaches in Artificial Intelligence for tasks such as: finding a\nsequence of actions to achieve a goal; playing adversarial games; and solving discrete\noptimization problems such as configuration and scheduling. Students will learn the theory and\npractice of AI search, logic, and constraint-based approaches. The module aims to equip\nstudents with a wide range of problem-solving tools, how to design effective heuristics for them,\nand enable comparison of methods to determine which are best suited to a given problem.\nSome of the tools covered are state-space search algorithms (i.e. A* Search, IDA*, and Greedy\nBest-First Search), game-tree search algorithms (i.e. Minimax and Monte-Carlo Tree Search),\nlocal search methods for solving discrete optimization problems, constraint programming, and\nthe satisfiability (SAT) problem in knowledge representation and reasoning.\nModule learning outcomes\nRepresent a given search problem in terms of states, actions, and a goal, and identify a suitable\nheuristic.\nRepresent a given scenario using propositional logic to enable logical inference (for example,\nusing a SAT solver).\nModel (represent) and solve discrete optimization problems using a modern constraint\nprogramming system.\nSelect and apply an appropriate AI state-space search algorithm for a given problem, identifying\nreasons for the choice of algorithm in comparison to others.\nSelect and apply an appropriate adversarial (game-tree) search method to solve a given game,\nincluding design of a suitable heuristic if required.\nDescribe the algorithms commonly used in SAT (propositional satisfiability) solvers, local search\nsolvers, and constraint solvers, and apply them to small examples.\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100",
        "Special assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.",
        "AUTONOMOUS ROBOTIC SYSTEMS ENGINEERING\nModule aims\nThis module will introduce students to the theoretical concepts and practical skills required to\nengineer autonomous robotic systems. It will cover fundamental aspects of sensors/actuators\nand control systems, then build upon this foundation with high-level algorithms for autonomous\nlocalisation, mapping, navigation, and multi-robot coordination. This module will also explore\nsafety considerations and ethical implications of the design, implementation, and deployment of\nautonomous robotic systems.\nModule learning outcomes\nDescribe the degrees of autonomy that robotic systems can achieve\nDiscuss the safety considerations and ethical implications of the design, implementation, and\ndeployment of autonomous robotic systems\nExplain methodological principles for engineering autonomous robotic systems\nDemonstrate an understanding of modern robotics middleware and its application\nImplement an autonomous robotic solution for a predefined problem\nDiscuss the strengths and weaknesses of an implemented autonomous robotic solution\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nCorrell, Nikolaus, et al. Introduction to Autonomous Robots: Mechanisms, Sensors, Actuators,\nand Algorithms. MIT Press, 2022.\nHerath, Damith, and David St-Onge. Foundations of Robotics: A Multidisciplinary Approach with\nPython and ROS. Springer Nature Singapore, 2022.",
        "EVOLUTIONARY & ADAPTIVE COMPUTING\nModule summary\nThis module introduces a range of biologically-inspired approaches to computing.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module introduces a range of biologically-inspired approaches to computing. It provides a\nfoundation of both theoretical and practical knowledge on the subject of evolutionary\ncomputation, an optimisation technique inspired by biological evolution. Students will have\nhands-on experience implementing a number of types of evolutionary algorithms using Python\nand the library DEAP: Distributed Evolutionary Algorithms in Python, to solve a range of different\ntypes of problems. The module also studies the use of Agents and Multi-agent Systems as a\nmodelling paradigm, with a focus on evolutionary adaptation and learning.\nModule learning outcomes\nDesign and implement evolutionary systems to address a given problem.\nUnderstand the biological underpinnings of evolutionary algorithms, and use them to optimise\nmathematical functions and agent behaviours.\nDefine a range of agent behaviours and represent them in a form that is well suited to natural\nselection\nModel processes in populations of agents using hand-written mathematical models\nCritically evaluate the performance and implementation of evolutionary and multi agent systems.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n++ Banzhaf et al, Genetic Programming: An Introduction, Morgan Kaufmann , 1999\n++ M. Mitchell, An Introduction to Genetic Algorithms, MIT Press, 1998",
        "COMPUTER VISION & GRAPHICS\nModule summary\nThis module will introduce modern computer vision approaches, including discussion of the\nmain applications and challenges.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module will introduce modern computer vision approaches, including discussion of the\nmain applications and challenges. It will cover issues of image formation, camera geometry,\nfeature detection, motion estimation and tracking, image classification and scene\nunderstanding, using a range of model-based approaches.\nModule learning outcomes\nDemonstrate a detailed understanding of the image formation process, its modelling in\ncomputer vision and its simulation in computer graphics\nDescribe and implement techniques for rendering images including modelling light/material\ninteraction\nUnderstand a range of methods for inferring 3D shape from images\nApply fundamental machine learning methods for image understanding\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n** Forsyth and Ponce Computer Vision a Modern Approach Prentice Hall\n** Anil K. Jain Fundamentals of Digital Image Processing Prentice Hall",
        "CRYPTOGRAPHY THEORY & PRACTICE\nModule summary\nThe module aims to provide a broad overview of modern cryptography. The module will cover\nthe fundamental security goals achieved through cryptographic algorithms and protocols, how\nthey are formalised, designs that enable achieving those goals, and how formal security\narguments can be made for the design achieving the security goals.\nRelated modules\nPre-requisite modules\nNone\nCo-requisite modules\nNone\nProhibited combinations\nCryptography (MAT00080H)\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThe module aims to provide a broad overview of modern cryptography. The module will cover\nthe fundamental security goals achieved through cryptographic algorithms and protocols, how\nthey are formalised, designs that enable achieving those goals, and how formal security\narguments can be made for the design achieving the security goals.\nModule learning outcomes\nBy the end of the module the students will be able to:\ndescribe and apply the fundamental security properties provided by cryptographic algorithms\nand protocols;\ndescribe how these security properties are formalised;\ndescribe the implications of cryptographic security arguments;\nidentify security requirements for a given practical scenario and identify the appropriate\ncryptographic tools to achieve the security requirements;",
        "assess whether given cryptographic algorithms and protocols meet identified security\nrequirements; and\nanalyse the security and efficiency of cryptographic protocols from both theoretical and practical\npoints of view.\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n[1] J. Katz, Introduction to modern cryptography, Third edition :: Chapman & Hall/CRC, 2020\n[2] J.-P. Aumasson, Serious cryptography : a practical introduction to modern encryption :: No\nStarch Press, 2018\n[3] C. Paar, Understanding cryptography : a textbook for students and practitioners :: Springer,\n2009\n[4] A. McAndrew, Introduction to cryptography with open-source software :: CRC Press, 2011\n[5] W. Stallings, Cryptography and network security : principles and practice, Seventh edition ::\nPearson, 2017\n[6] A. J. Menezes, Handbook of applied cryptography :: CRC Press, 1997",
        "EMBEDDED SYSTEMS DESIGN & IMPLEMENTATION\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThe aim of this module is to understand the need for embedded computer systems, and the\nengineering process to design, implement and validate them.\nModule learning outcomes\nArticulate the need for embedded computer systems, and the requirements imposed on them by\ntheir application scenario.\nBe able to apply an engineering process to design, implement and validate embedded systems.\nDemonstrate the different levels of abstraction that are used throughout the design process, and\nbe able to decide the most appropriate abstractions at each step.\nExplore hardware/software implementation trade-offs, and a number of partitioning, mapping\nand evaluation techniques that can be used to analyse that trade-off for a particular application\nscenario.\nProgram computing platforms that have limited performance, energy, memory and storage\ncapacity.\nDesign and evaluate custom hardware architectures.\nUnderstand the process to improve and assure timing properties, including priority assignment,\nscheduling of real-time tasks and schedulability analysis.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is given to each student on each of the two assessments, highlighting the strengths\nand weaknesses of the proposed design. Additional feedback is also given during practical\nsessions, which are also based on design problems.\nIndicative reading\nP. Marwedel, Embedded System Design, Springer, 2011",
        "ENGINEERING 2: AUTOMATED SOFTWARE ENGINEERING\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module builds on ENG1 and introduces advanced techniques for engineering large,\ndata-intensive software systems that consist of components written in different programming\nlanguages and operating on a variety of platforms. In order to manage the complexity of\nengineering such data-intensive systems, ENG2 will introduce the theory, principles and\npractices of model-driven engineering (MDE), focusing on technical topics. These include\nmodelling, metamodelling, model management, model transformation, model-driven traceability,\nworkflows, model validation, and model evolution. Non-technical issues including standards,\ndomain-specific MDE versus general-purpose MDE and MDE processes will also be\nconsidered. The discussion of concepts and technologies for engineering modern data-intensive\nsoftware systems will start from a general discussion about architectural concerns, then move\non to discuss their design, implementation as a collaboration of microservices, and using\ncontainers for reproducible and scalable deployment. ENG2 will discuss assurance practices\naround data-intensive software systems, such as testing and hardening.\nModule learning outcomes\nDemonstrate the principles and practices of modelling and metamodelling.\nImplement and orchestrate domain-specific models, metamodels and model management\noperations.\nDemonstrate the design principles for data-intensive software systems, including their\narchitecture characteristics like availability, scalability, reliability and security, and the\ncharacteristics of the organisation.\nStructure data-intensive systems as combinations of independently maintained microservices,\nand propose benefits and challenges in terms of complexity management, organisational\nscalability, and resource usage.\nDeploy the components of data-intensive systems in a scalable and reproducible manner, by\npackaging them as containers and orchestrating these containers to work with each other.\nDescribe assurance practices in the development and deployment of large data-intensive\nsystems, including testing and hardening.\nArticulate how Model-Driven Engineering integrates with wider system engineering processes\nand policies, including those of a data-intensive software system.\nIndicative assessment\nTask % of module mark",
        "Essay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nNewman, Sam. Building Microservices, O'Reilly Media, 2021.\nKleppmann, Martin. Designing Data-Intensive Applications: The Big Ideas Behind Reliable,\nScalable, and Maintainable Systems, O'Reilly Media, 2017.\nWasowski A. Domain-Specific Languages: Effective Modeling, Automation, and Reuse. 1st ed.\n2023. (Berger T, ed.). Springer International Publishing; Imprint Springer; 2023.",
        "ETHICAL HACKING, ANALYSIS & INVESTIGATION\nModule aims\nThe module aims to provide an introductory range of theoretical and practical skills to undertake\nethical hacking, analysis, and investigation of modern computer systems and networks.\nThe module will explore ethical hacking topics such as vulnerability exploitation of cryptographic\nand network protocols, reverse engineering, and other penetration testing techniques, as well as\nmalware analysis and digital investigation of cyber incidents.\nThe module will familiarise students with a range of tools used by ethical hackers and security\npractitioners.\nModule learning outcomes\nBy the end of the module the students will be able to:\nExplain the fundamental concepts of cyber security in systems and networks\nUnderstand the security strengths & weaknesses in network mechanisms\nUnderstand the major threats and attacks in systems and networks under various scenarios,\narchitectures, and threat models\nAnalyse control solutions for network security\nAssess the relative merits of different solution approaches in various security-related contexts\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 50\nClosed/in-person Exam (Centrally scheduled) 50\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 50\nClosed/in-person Exam (Centrally scheduled) 50\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nJon Erickson. Hacking: The Art of Exploitation. No Starch (2008)",
        "Sikorski, Michael ; Honig, Andrew. Practical Malware Analysis: A Hands-On Guide to Dissecting\nMalicious Software. No Starch Press, Incorporated (2012)",
        "HIGH-INTEGRITY SYSTEMS ENGINEERING\nModule summary\nThis module teaches students to adapt their software development practice to take account of\nthe general criticality and the specific risks of the software they are developing.\nRelated modules\nStudents on the joint Mathematics and Computer Science programmes who are interested in\nthis module should discuss the necessary prerequisite knowledge with the module leader.\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nGood knowledge of software engineering practice.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module teaches students to adapt their software development practice to take account of\nthe general criticality and the specific risks of the software they are developing. Students will\ngain a broad understanding of the issues involved in designing and implementing critical\nsystems, be aware of the methods used to construct critical systems, and understand the\nlimitations of the various methods, analysis techniques and tools currently in use.\nModule learning outcomes\nUnderstand and articulate the issues involved in designing and implementing critical systems\nApply a range of techniques to the design, and validation of high integrity systems, such as\nfault-tree analysis and failure analysis.\nDiscuss issues of high integrity engineering, both technical and social.\nParticipate in significant discussion periods brainstorming scenarios and discussing previous\nwell-documented examples of system failures\nIntroduce existing software engineering concepts for the development of critical systems\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment",
        "Task % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, through discussion sessions, and after\nthe final assessment as per normal University guidelines.\nIndicative reading\nN.G. Leveson, Safeware: System Safety and Computers, Addison-Wesley, 1995",
        "HIGH-PERFORMANCE PARALLEL & DISTRIBUTED SYSTEMS\nModule summary\nThis module introduces and explores the use of high-performance computing, and related\ntechnologies.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module introduces and explores the use of HPC and related technologies, covering on and\noff node parallelism, accelerators, and memory management. Students will understand the\nincreasingly important role that HPC plays in science and engineering. Throughout the module,\nstudents will practice by developing programs using a range of parallel programming paradigms\nlike OpenMP and MPI.\nModule learning outcomes\nDemonstrate the development of parallel programs on shared memory systems using popular\nprogramming paradigms.\nBe able to understand appropriate metrics to assess the performance of applications and\nsystems.\nDemonstrate the development of parallel programs on distributed memory systems using\nappropriate parallel programming libraries.\nBe able to explore the design space afforded by parallel and distributed systems, including\nissues of GPU programming, high-speed networking, and I/O.\nBe able to reason about the performance, portability, and productivity of different approaches to\ndeveloping HPC applications.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\nIntroduction to High Performance Scientific Computing, Eijkhout, Victor; van de Geijn, Robert;\nChow, Edmond",
        "HUMAN FACTORS: TECHNOLOGY IN CONTEXT\nAdditional information\nPre-Requisite Module:\nHuman-Computer Interaction (HCIN) - COM00018C\nPre-Requisite Knowledge:\nResearch Methods\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nNone.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module will equip students with an understanding of how human characteristics and design\ninfluence interactions with technical systems in organisational and industry contexts. The\nmodule uses real-world case studies to introduce and critically evaluate the contribution of\nhumans in developing and maintaining safe, ethical and secure systems. The module aims to\ndevelop students' skills in:\nAnalysis techniques\nProposing and applying appropriate criteria to assess the rigour and suitability of industrial and\nacademic approaches to human reliability.\nModule learning outcomes\nRecognise the role of human characteristics/factors/mental models in relation to the safe,\nsecure and effective operation and maintenance of interactive systems across applied/industry\ncontexts\nCritically evaluate the quality of designs and propose solutions to security and safety issues\nDemonstrate the ability to locate and, where relevant, apply existing academic research to\ninform the consideration of issues arising within human-technology interactions\nIdentify, apply and critique appropriate techniques for human reliability and error analysis",
        "Identify, apply and critique appropriate techniques for security analysis, including issues of\nauthentication, privacy and foreseeable misuse\nUse appropriate frameworks and design techniques to investigate ethical issues in relation to\nhuman-machine interaction\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.",
        "INTELLIGENT SYSTEMS: PROBABILISTIC & DEEP LEARNING\nAdditional information\nPre-Requisite knowledge - Understanding of the theory and practice of Machine Learning. For\nundergraduates this is covered in intelligent systems modules (for example, INT2 - Intelligent\nSystems 2: Machine Learning & Optimisation COM00024I or IMLO - Intelligent Systems:\nMachine Learning & Optimisation COM00026I).\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent plus good understanding of the theory and practice of machine\nlearning.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module builds on the basic machine learning covered previously in the programme, and\ntakes students up to state of the art methods in modern deep learning. It introduces probabilistic\nmethods, where we can reason about uncertainty, and deep learning based methods, where\nneural networks with many layers prove to be the most powerful general model for learning. We\nwill see a range of methods and architectures for classification and regression problems,\nunsupervised generative models and the mathematics that underlies these techniques. We will\ncover both theory and practicalities: how are these ideas actually implemented in a modern\nmachine learning library like PyTorch?\nModule learning outcomes\nExplain the probabilistic basis of machine learning\nDemonstrate a working knowledge of manifold embedding and kernel methods\nApply a range of Bayesian methods for regression, classification and clustering\nBe familiar with the main deep learning architectures\nDemonstrate the optimisation process and different variants (i.e. gradient descent, stochastic\nalgorithms, ADAM)\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules",
        "None\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines\nIndicative reading\nSolomon, Justin. Numerical Algorithms. AK Peters/CRC Press, 2015",
        "LEGAL PRACTICE, TECHNOLOGY & COMPUTER SCIENCE\nModule summary\nLaw and computer science students will work collaboratively in teams to develop a\ntechnology-based solution to a real-life legal practice process problem. From initial analysis of\nthe problem, teams will work to develop a solution to the problem, assessing both legal and\nprocedural issues, system and user design requirements, functionality, costs, benefits and risks.\nStudents from each discipline will contribute know-how from their discipline to the project, whilst\ngaining new understanding and skills. The module will be supported by a leading international\nlaw firm with a technology hub in the region, providing students with access to external\nexpertise in the field, in addition to disciplinary tutor support.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThe aim of the module is to provide law and computer science students with an opportunity to\ndevelop an applied understanding of how technology and computer science are being applied in\ndeveloping new approaches to the provision of legal services and how these can offer greater\naccessibility to justice, as well as efficiency, quality and costs gains. Students will develop\nknowledge both within their own and the colloborative discipline, as well as a range of analytical,\nproblem-solving, planning, communication and interpersonal skills. The module also aims to\nprovide students with opportunities to interact with experts in legal practice technology and thus\ngain contemporary professional perspectives on the areas covered in the module.\nModule learning outcomes\nOn completion of this module, students should be able to:\nAnalyse a legal process which may be improved for users by application of computer science\nApply design thinking to identify procedural, technical, legal and user issues\nCommunicate orally and in writing relevant principles from their primary discipline to colleagues\nfrom another discipline\nCollaborate and synthesise disciplinary principles to develop potential solutions\nEvaluate potential solutions against user requirements\nFormulate a costed implementation plan for an agreed solution\nPresent a persuasive written and oral case for the solution\nExplain the potential applications of computer science and technology in the development of\nlegal services\nReflect on learning gains and challenges from the module, including cross-disciplinary\ncollaboration\nModule content\nLaw and computer science students will work collaboratively to develop a solution to a legal\nprocess problem, based on a real-life access to justice scenario. This will be developed in\ncollaboration with a law firm.",
        "The module will use problem-based learning (PBL) techniques, and be predominantly\ngroup-assessed. Students will receive a problem and, working in teams comprising equal\nnumbers from each discipline will apply PBL techniques to identify:\nsubstantive and procedural issues\nclient and internal commercial issues\nrisks\nprocess requirements\nUsing these as the basis to develop a solution, there will be an element of cross-discipline\nteaching: law students will have to be able to explain law, procedure and process requirements\nto computer science students and the latter will have to explain tech functionality and\ncapabilities, in each case in language understandable to those from the other discipline.\nFollowing initial detailed analysis of the problem, teams will work to develop a solution to the\nproblem, with activity moving from analysis to development. They will plan a programme of work\noutside class activity sessions, with the latter acting as formal workshops/surgeries, during\nwhich teams can obtain feedback from facilitators from both disciplines. There will also be an\nopportunity to obtain feedback from a legal technology expert from a law firm, as part of a\nplenary \"masterclass\".\nThe assessment will require submission of the solution - e.g., system requirements;\nfunctionality; process map; costs; benefits; risk; time-line to implementation - in the form of a\nbusiness proposal, together with an oral presentation by each group. Individual students will\nalso submit a personal reflection on learning gained against the module outcomes.\nIndicative assessment\nTask % of module mark\nEssay/coursework 20\nGroupwork 50\nOral presentation/seminar/exam 30\nSpecial assessment rules\nNone\nAdditional assessment information\nFormative feedback will be provided on a rolling basis by facilitators as teams progress through\nthe analysis and development stages of the module, especially during workshops.\nIndicative reassessment\nTask % of module mark\nEssay/coursework 20",
        "Groupwork 50\nOral presentation/seminar/exam 30\nModule feedback\nStudents will receive summative feedback as follows:\noral feedback on group presentation\nwritten feedback on group submission\nwritten feedback on individual reflective submission\nIndicative reading\nThe Future of the Professions: Susskind & Susskind \u2013 OUP 2017\nTomorrow\u2019s Lawyers \u2013 Susskind \u2013 OUP 2017\nThe End of Lawyers? Susskind \u2013 OUP 2008",
        "NETWORK SECURITY\nModule summary\nNetwork Security (NETS): This module covers the basic concepts of cyber security, how these\nare modelled, threat models, and the mechanisms to enforce security policies.\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module aims to provide a broad knowledge of network and system security, addressing\nthreats over a range of network layers and detailing corresponding defensive countermeasures\nand protocols. The module will cover the basic concepts of cyber security (confidentiality,\nintegrity and availability), how these are modelled, threat models (adversary capabilities and\ngoals), and basic control mechanisms to enforce security policies (e.g. access control). Students\nwill learn to understand network security, threats, and the mechanisms that have been\ndeveloped to counter them. It explores a range of different networked systems, the main\nnetwork attacks, and their defence mechanisms.\nModule learning outcomes\nBy the end of the module the students will be able to:\nDescribe the fundamental concepts of cyber security in systems and networks\nIdentify security strengths & weaknesses in network mechanisms\nIdentify major threats and attacks in systems and networks under various scenarios,\narchitectures, and threat models\nPropose control solutions for network security\nAssess the relative merits of different solution approaches in various security-related contexts\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, discussion in seminars, and after each\nassessment as per normal University guidelines.",
        "Indicative reading\nSherri Davidoff, Jonathan Ham, Network Forensics: Tracking Hackers Through Cyberspace,\nPrentice Hall, 2012\nKevin R Fall, W Richard Stevens, TCP/IP Illustrated, Volume 1: The protocols, Addison Wesley,\n2012\nAndrew Tannenbaum, Computer Networks, Prentice Hall, 2002",
        "PLAYER EXPERIENCES IN DIGITAL GAMES\nModule aims\nThis module will provide students with a comprehensive understanding of player experience and\nthe different ways in which games can impact players. In addition to learning about what player\nexperience is and how to evaluate it, the module will also cover the effects of games on players\n(e.g. in relation to wellbeing) and the use of games for applied purposes (e.g. behaviour\nchange).\nModule learning outcomes\nDemonstrate an understanding of the breadth of player experience\nSelect appropriate methods for evaluating different kinds of player experience\nConduct playtesting sessions and report on the findings\nCompare and contrast the different ways in which digital games can affect players\nPlan appropriate evaluations for applied games\nIndicative assessment\nTask % of module mark\nEssay/coursework 60\nGroupwork 40\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 60\nGroupwork 40\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nDrachen, A., Mirza-Babaei, P., & Nacke, L. E. (Eds.). (2018). Games user research. Oxford\nUniversity Press.\nStahlke, S., & Mirza-Babaei, P. (2022). The Game Designer's Playbook: An Introduction to\nGame Interaction Design. Oxford University Press.",
        "QUALITATIVE APPROACHES TO INVESTIGATING UX\nModule aims\nThis module will provide students the methodological approaches to interrogating concepts and\nusers\u2019 subjective experiences with interactive systems. The module provides theoretical and\npractical grounding in methods used for collection and analysis of qualitative data that are used\nin industry and academic research. Students will learn how different qualitative methods can be\nused for a range of purposes, from informing to design to understanding technology use in\ncontext.\nModule learning outcomes\nIdentify and justify use of appropriate qualitative methodology\nRecognise and acknowledge the underpinning epistemological positions of qualitative methods\nRecognise the role of the researcher in the research process\nCritique and contrast the methods of studies against the standards of rigour and validity of the\nchosen methodology\nReport and discuss the results of an analysis appropriate to the method used\nDescribe the important aspects of research governance including ethical conduct and data\ngovernance\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.",
        "QUANTUM COMPUTATION\nModule summary\nThe aim of this module is to introduce the theory of quantum computation. In it we will learn\nabout the pioneering quantum algorithms that promise a qualitative leap in computation power\nover conventional computers.\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent; good understanding of programming.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nIntroducing both the promise and limitations of quantum computation. Gate operations, evolving\nquantum states, calculating the result of measurements on quantum states, designing and\nanalyzing quantum computational circuits, key algorithms (e.g., Shor's, Grover's and the\nDeutsch-Jozsa algorithms).\nModule learning outcomes\nArticulate both the promise and limitations of quantum computation.\nApply some of the many concepts and techniques in quantum computation (e.g., applying gate\noperations and evolving quantum states, calculating the result of measurements on quantum\nstates, designing and analyzing quantum computational circuits);\nExplain some of the key algorithms (e.g., Shor's, Grover's and the Deutsch-Jozsa algorithms)\nand their implications, and are able to simulate these algorithms on quantum states.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.",
        "Indicative reading\n*** G. Benenti, et al., Principles of Quantum Computation and Information, vol I, World Scientific,\n2004\n*** G. Benenti, et al., Principles of Quantum Computation and Information, vol II, World\nScientific, 2007\n*** P. Kaye, et al., An Introduction to Quantum Computing, Oxford University Press, 2007",
        "RESEARCH METHODS IN COMPUTER SCIENCE\nModule summary\nA core module that equips postgraduate taught students with core theorectical and practical\nresearch skills.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nResearch is about both generating new knowledge and evaluating confidence in knowledge.\nThere are three skills associated with the conduct of good research:\nThe ability to accurately identify from existing literature and systems a meaningful or important\ngap in knowledge, and therefore what constitutes new knowledge in the domain of Computer\nScience\nThe ability to competently intervene in the world (e.g. through developing systems,\nimplementing data collection procedures, conducting experiments\u2026) in order to generate\nknowledge that causes positive change.\nThe ability to evaluate the quality of evidence stemming from an intervention using sound\nanalysis, and communicate that analysis to the scientific community.\nAs the ways of intervening in the world depend strongly on your disciplinary area, the aim of this\nmodule is to provide an introduction to the first and third pillars, namely the conduct of literature\nreviews to identify a research gap; and the methods for analysing research data, interpreting\nsaid analysis, and accurately presenting research outcomes.\nThe module will also cover general principles related to the second pillar that apply across\ndisciplinary areas in the development of novel methods and conduct of experiments.\nModule learning outcomes\nBy the end of this module, students will be able to\u2026\nIdentify a gap in the evidence base within the structure of a formal academic literature review.\nDiscuss the validity and reliability of methods used in extant or novel research.\nDescribe and apply principles of responsible research and innovation to a research project.\nAnalyse a variety of quantitative research data using an array of appropriate inferential\nstatistical tests.\nPresent the outcomes of a research project.",
        "Indicative assessment\nTask % of module mark\nEssay/coursework 50\nGroupwork 50\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 50\nEssay/coursework 50\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nHowell DC. Fundamental Statistics for the Behavioral Sciences . 9th edition, student edition.\nCengage Learning; 2017.\nGoldbort R. Writing for Science . Yale University Press; 2006.",
        ""
    ],
    "semesters_1804495258204685296": [
        "Year 1\nFOUNDATIONS OF PROGRAMMING FOR COMPUTER SCIENCE\nModule summary\nFoundations of Programming for Computer Science\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nStudents will be introduced to different programming constructs, basic data structures,\ncommand line tools, integrated development environments and unit testing of programs.\nStudents will learn how to describe well-defined tasks using pseudocode and translate them into\nprograms using a procedural programming paradigm. The module will be taught using a\nprocedural language for practising these skills.\nModule learning outcomes\nS101 Describe and apply the fundamental concepts of procedural programming. Write small\nprocedural programs from scratch to perform well-defined tasks, following well-defined\nrequirements, in a procedural programming language like Python. Relate the syntax of the\nlanguage to its semantics, and analyse the result of executing fragments of syntax. Integrate\nlibrary code with their own programs using appropriate software tools.\nS102 Implement bespoke data structures to store states of a process. Implement simple\nalgorithms written in pseudocode. Develop programs incrementally, using simple tests\n(automated where appropriate) to check each increment.\nS103 Store data in memory in standard built-in collection types, and to store and retrieve data\nfrom simple text files such as CSV and JSON files.\nS104\nUse an appropriate software development environment, such as Eclipse, IntelliJ or VS Code.\nGiven a program and a debugging tool, students will be able to identify and correct bugs which\nprevent the program from functioning as intended.\nS105\nOrganise and document program code following the principles of software engineering. Write\ndocumentation to explain the design and implementation of their own code, or example code\nwhich is supplied to them.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, formative assessments, and after the\nfinal assessment as per normal University guidelines.\nIndicative reading\nAllen B. Downey - Think Python: How to Think Like a Computer Scientist - 2nd ed. (2015),\nO'Reilly Media\nMike Dawson - Python programming for the absolute beginner - 3rd ed. (2010) - Course\nTechnology\nKent D. Lee and Steve Hubbard - Data structures and algorithms with Python (2015), Springer\nMATHEMATICAL FOUNDATIONS OF COMPUTER SCIENCE\nModule summary\nMathematical Foundations of Computer Science\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nStudents will be introduced to the key discrete mathematics concepts that are the foundation of\ncomputer science. Seven topics are covered as follows: i) counting (combinatorics), ii) discrete\nprobability, iii) graphs, iv) propositional and predicate logic, v) proofs and sets, vi) relations on\nsets, and vii) relations on a single set. After studying the module, students will be able to apply\nthe learnt concepts, theories and formulae in real-world examples of computational problems.\nModule learning outcomes\nT101 Define, read and apply mathematical notations for the purpose of describing\nmathematical concepts from across discrete mathematics.\nT102 Select appropriate techniques to prove properties related to discrete mathematics\nconcepts.\nT103 Understand how to construct sets of elements with certain properties and determine their\ncardinality using counting formulae from combinatorics.\nT104 Understand and apply basic set theory, including formally defining set relations and\noperations.\nT105 Describe and use the basic concepts of discrete probability to describe events, with an\nunderstanding of joint, conditional and marginal probabilities, Bayes\u2019 theorem, expectation,\ncovariance and correlation.\nT106 Formally define and illustrate by example graphs of different graph classes, such as\nsimple, undirected, directed, weighted, directed acyclic, connected, disconnected and trees -\nwith an understanding of how they may be used in real-world computational problems.\nT107 Apply a variety of techniques to identify whether logical expressions are true or false,\nvalid or invalid or equivalent to one another, and be able to apply logical statements to describe\nreal-world logical problems.\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n** Dean N., The Essence of Discrete Mathematics, Prentice Hall, 1997\n** Haggarty R., Discrete Mathematics for Computing, Addison Wesley, 2002\n** Truss J., Discrete Mathematics for Computer Scientists, Addison Wesley, 1999\n** Gordon H., Discrete Probability, Springer, 1997\n* Solow D., How to Read and Do Proofs, Wiley, 2005\nHUMAN-COMPUTER INTERACTION\nModule summary\nHCIN introduces user-centred design. Where other modules focus on technical understanding\nof computers and how they work, this module is instead about understanding the relationship\nbetween computer systems and people. It discusses how this can be used to improve system\ndevelopment, and how it can go wrong. We will explore the nature of and barriers to people's\ninteractions with computers and how systems can be designed to optimise and facilitate these\ninteractions. We will also consider how to evaluate the people's experience - what makes a\ngood, enjoyable human-computer interaction.\nRelated modules\nThe assessment is undertaken as a group open assessment in which groups will work together\nto complete and present a user-centred design task. The assessment also includes as part of\nthe submission an individual reflection exercise which is worth 10% of the overall marks. This\ntask asks students to comment on their development of transferable skills (using the York\nStrengths Framework as a basis) and how they have developed these during HCIN. The\nassessment also has a peer-assessment exercise, which ensures that individual contributions to\nthe group are accounted for in the final marks.\nReassessment is by an individual open assessment which requires students to understand and\nimplement the processes and techniques discussed during the module.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nStudents taking this module will be familiarised with how to design user-centred systems that\nmeet the needs and preferences of diverse users. Students will be introduced to the notion of\nengineering lifecycles, and in particular building requirements from user needs, iterative\nprototyping and evaluation of interactive systems. Students will undertake group work in\npracticals, giving them opportunities to develop communication and conflict resolution skills. The\nassessment will evaluate knowledge of the user-centred design process and interaction design\nprinciples.\nModule learning outcomes\nDescribe why user-centred design in software development is important to usable and inclusive\ndesign.\nUndertake a user-centred design process as a cyclical approach through the key stages of user\nneeds elicitation, conceptual design, prototyping, and evaluation.\nApply appropriate interaction design concepts in describing user-system interaction including:\naffordances, feedforward, feedback, conceptual model.\nAdvocate for the ethical treatment of participants throughout the user-centred design lifecycle,\nand explain how user diversity can impact on the inclusiveness of a system.\nDescribe how interactive systems are embedded in societal structures, and how they are used\nto invoke change at the personal, community, national or international level.\nPlan and manage deliverables to set deadlines throughout a project lifecycle, and use a\nself-reflective skills assessment to improve student team working and team performance.\nIndicative assessment\nTask % of module mark\nEssay/coursework 10\nGroupwork 90\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, formative assessments, and after the\nfinal assessment as per normal University guidelines.\nIndicative reading\n*** Preece, J., Rogers, Y., Sharp, H., Interaction Design, 4th edn Wiley, 2015\n*** Cooper, A., Reimann., R., Cronin., D., Noessel., C. About Face: The Essentials of Interaction\nDesign. 4th edn Wiley, 2014.\n* Mackenzie, I.S. Human-Computer Interaction. Elsevier Inc., 2013.\n* Norman, D. The Design of Everyday Things. Any edition.\nOBJECT-ORIENTED DATA STRUCTURES AND ALGORITHMS\nModule summary\nObject Oriented Data Structures and Algorithms\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents begin to program key data structures such as stacks, queues, trees and graphs. They\nare introduced to the idea of complexity of an algorithm, and how to characterise time and\nspace through formal notations and proof techniques. Students are taught using an object\noriented language like Java, and learn the basics of test driven development for testing their\ncode and demonstrating its successful running. Students are also introduced to several\nalgorithm design paradigms such as greedy algorithms.\nModule learning outcomes\nS201\nImplement an object oriented design. This includes organising program code into modules using\nmethods following the software engineering principles of modularity and abstraction, and\nassembling data and methods into classes at an introductory level following the software\nengineering principles of encapsulation and data hiding. Integrate standard library code with\ntheir own programs using appropriate software tools.\nS202\nWrite and test code that conforms to specific interfaces. Identify and correct bugs which prevent\nthe program from functioning as intended.\nS203\nOrganise and document program code following the principles of software engineering.\nGenerate documentation, manually and programmatically, to explain the design and\nimplementation of their own code, or example code which is supplied to them.\nS204\nAnalyse problems in order to confidently design algorithms to solve simple problems,and be\nable to explain how algorithms and Processing programs work. Develop small programs that\nimplement basic algorithmic designs. Argue the correctness of algorithms using inductive proofs\nand invariants.\nS205\nAnalyse worst-case running times of algorithms using asymptotic analysis and apply the\nknowledge to sorting and searching algorithms, categorising efficiency in time and memory use.\nS206\nCompare between different abstract data structures from linked lists to graphs in order to be\nable to choose an appropriate data structure for a design situation. This includes the major\nsearch, sort, and graph algorithms and their analyses.\nS207\n.Apply algorithmic design paradigms such as greedy and dynamic programming paradigms.\nPresent an argumentation for the choice of a paradigm for a given problem. Describe what an\napproximation algorithm is, the benefit of using approximation algorithms, and analyse the\napproximation factor for such an algorithm.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nModule feedback\nFeedback is provided through work in practical sessions, formative assessments, and after the\nfinal assessment as per normal University guidelines.\nIndicative reading\nSteven S. Skiena - The algorithm design manual - 2nd ed., (2010), Springer\nMichael T. Goodrich, Roberto Tamassia, Michael H. Goldwasser - Data Structures and\nAlgorithms in Java (2014), Wiley Etextbooks\nMitsunori Ogihara - Fundamentals of Java programming (2018), Springer\nINTRODUCTION TO COMPUTER ARCHITECTURES\nIntroduction to Computer Architectures\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents taking this module will gain foundations in the key architectural components of a\ncomputer system, how a high level program is executed upon that system, and how a computer\nsystem is constructed in hardware. Students will be introduced to how a computer system is\nconstructed, and how a program implemented in a high level programming language (for\nexample C) executes on that system. Students will be introduced to the basics of computer\narchitecture and program language construction, providing a basis for further study in later\nyears. Students will be introduced to a bottom-up approach, motivated by real examples, taught\nas both lectures and laboratory practicals. Students will be able to describe and apply their\nprogramming skills on real devices and computer systems that are used in many real\napplications today.\nModule learning outcomes\nIdentify the purpose of key computer hardware components such as processors, memories and\nbusses.\nDescribe different data types commonly found in binary systems (e.g. signed vs. unsigned\nintegers), and show how to convert, perform arithmetic, and perform logical operations.\nExpress logical expressions as basic gates, transistors and combinatoric logic circuits\nDescribe the function and limitations of a variety of logical building blocks in the context of\nprocessor architectures\nDescribe the von Neumann Model paradigm of computer architecture, including the fetch\nexecute cycle of instruction processing.\nExplain how operations executed in a processor can be used to implement to higher level\nsequential, conditional and iterative programming language constructs\nBuild a simple system comprised of a CPU, memory and input/output.\nExplain the use of assemblers, compilers and linkers to create executable code for a processor,\nand use such a toolchain develop software for the simple system built in the module\nIdentify potential security problems associated with architecture design.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nAdditional assessment information\nOpen assessment is a long-running task that takes place over a number of weeks.\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n*** J.Hennessy, D.Patterson Computer Architecture: A Quantitative Approach (2nd Edition)\nMorgan Kaufmannn 1990\n*** W.Stallings Computer Organization and Architecture: Design For Performance (8th Edition)\nPearson 2010\nFORMAL LANGUAGES AND AUTOMATA\nFormal Languages and Automata\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents taking this module will be introduced to the concepts of formal languages and the\nabstract machines that accept them as a way of describing computation. Students will have a\ndeep understanding of finite automata and pushdown automata, with their associated languages\nand related proof techniques, and will be introduced to more complex machines accepting\ncontext sensitive and recursively enumerable languages for purposes of being able to identify\nand describe them.\nModule learning outcomes\nDescribe and illustrate the concepts of formal languages, automata and grammars, and the\nrelations between them;\nConstruct a variety of abstract machines including: deterministic and non-deterministic finite\nautomata, deterministic and non-deterministic pushdown automata and Turing machines;\nDistinguish different classes of automata, and the languages they accept;\nApply a variety of operations to transform and convert between automata;\nConvert between grammars and automata for regular and context-free languages;\nDemonstrate that a grammar is ambiguous;\nApply the pumping lemma for regular and context-free languages to show a language is not\nregular or context-free respectively;\nDescribe the Chomsky hierarchy;\nIdentify key applications in computing where regular and context-free languages are used in\npractice; and\nUse automata theory as the basis for building lexers and parsers.\nIndicative assessment\nTask % of module mark\nOpen Examination 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOpen Examination 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n*** Peter Linz, An introduction to formal languages and automata. Sixth Edition. Jones and\nBartlett Computer Science. 2017\n** D.I. Cohen, Introduction to Computer Theory. 2nd Edition. Wiley. 1997\n** Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D., Introduction to Automata\nTheory, Languages and Computation (3rd ed.), Pearson Education, 2013\n** S.H. Rodger and T.W. Finley, JFLAP: An interactive formal language and automata package.\nJones and Bartlett Computer Science. 2006. Available online\n* Martin, John C., Introduction to Languages and the Theory of Computation (4th ed.), McGraw\nHill, 2010\n* Rich, Elaine, Automata, Computability and Complexity, Pearson Education, 2008\n* Sipser, Michael, Introduction to the Theory of Computation (3rd ed.), South-Western College\nPublishing, 2012\n",
        "Year 2\nDATA: INTRODUCTION TO DATA SCIENCE\nModule summary\nIntroduction to Data Science\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nStudents will be introduced to key concepts required to undertake rigorous and valid data\nanalysis. Students will be introduced to processes for collecting, manipulating and cleaning\ndata, while gaining experience in judging the quality of data sources. Students will be introduced\nto statistical analysis in data science, including correlation, inferential statistics and regression,\nand how to use these tests in a programming environment. Relational databases, SQL, and and\nother database paradigms such as NoSQL, are covered as a way of storing and accessing data.\nA key aim of the module is to solve complex problems and deliver insights about\nmulti-dimensional data.\nModule learning outcomes\nDistinguish between different types of data that are generated in science, engineering and\ndesign, and employ strategies for ensuring data quality.\nRetrieve data from a variety of different data sources in a variety of different formats.\nApply inferential statistics and statistical procedures to test hypotheses about features and\nrelationships within data sets.\nUse appropriate visualisations to present and explore data sets.\nUse databases, both relational and of other paradigms, to store and query data.\nIdentify the ethical concerns regarding the provenance of data, the privacy of individuals, and\nthe impact data analytics can have on society, and apply topics from the code of ethics of a\nprofessional data protection body.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n*** Spiegelhalter, D., The Art of Statistics: Learning from Data, Pelican, 2019.\n*** VanderPlas, J. Python Data Science Handbook: Essential Tools for Working with Data,\nO\u2019Reilly, 2016.\n** Igual, L. Segui, S. Introduction to Data Science: A Python Approach to Concepts, Techniques\nand Applications, Springer, 2017\nSYSTEMS & DEVICES 2: OPERATING SYSTEMS, SECURITY, AND NETWORKING\nModule summary\nSystems & Devices 2: Operating Systems, Security, and Networking\nRelated modules\nPre-requisite modules\nSystems & Devices 1: Introduction to Computer Architectures (COM00011C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module builds on Systems and Devices 1 by examining the system software that executes\nupon a computer system. Students will learn how the resources of the system can be shared by\nmultiple programmes and users, and how networking can be used to communicate between\nprogrammes. One important aspect is how basic security and protection mechanisms are\nprovided by the processor and memory system. Throughout, the module students will consider\npractical examples based on computer systems used today. This module also introduces\nstudents to the core concepts of computer networking by covering the layered network model,\nand discussing the utility and motivation for such an approach. Services that are layered on this\nmodel (such as UNIX sockets, DNS, TCP, IP) are detailed and students will develop software to\nexperiment with these features. After taking this module, students will have an understanding of\nthe role of an operating system, how computers can support multiple time-sliced programmes,\nand how all kinds of computer networks, including the Internet, are created.\nModule learning outcomes\nDemonstrate application programming of OS-supported concurrency, communication and I/O.\nShow how the structure of the OS is supported by computer hardware, with specific reference to\nthe hardware features that extend the basic systems introduced in S&D1.\nUse basic resource management mechanisms provided by common OSes, including time and\nmemory.\nDemonstrate use of the memory protection mechanisms provided by hardware and OSes,\nincluding memory mapped I/O.\nDemonstrate use of the information security provided by the OS in terms of file systems.\nDemonstrate concurrent programming at the process level and show how it is supported by, and\nimplemented on, the system hardware.\nLearn to recognise and avoid issues of deadlock, livelock, and starvation.\nBe able to articulate the motivation behind the layered network model\nDevelop software using OS-level networking concepts (i.e. sockets) to communicate with other\nsystems.\nDemonstrate understanding of networked architectures, how they are integrated into an\noperating system, and develop simple applications using this knowledge.\nIndicative assessment\nTask % of module mark\nEssay/coursework 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nSpecial assessment rules\nNone\nAdditional assessment information\nStudents are only required to resit any failed assessment component.\nIndicative reassessment\nTask % of module mark\nEssay/coursework 50\nOnline Exam -less than 24hrs (Centrally scheduled) 50\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n*** Operating System Concepts, Tenth Edition by Silberschatz, Galvin and Gagne, Wiley (2018)\n* A. S. Tanenbaum, Modern Operating Systems, Prentice Hall (2014).\n* W. Stallings, Operating Systems, Internals and Design Principles (9th Edition) Ninth Edition,\nPrentice Hall (2017).\nTHEORY 3: COMPUTABILITY, COMPLEXITY & LOGIC\nModule summary\nTheory 3: Computability, Complexity and Logic\nRelated modules\nPre-requisite modules\nTheory 2: Formal Languages & Automata (COM00014C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module covers computability theory and complexity theory. In particular, students will learn\nthe concepts of semi-decidable and decidable languages, and Turing-computable functions.\nThey will be able to explain the difference between solvable and unsolvable problems and prove\nunsolvability by reduction. They will understand the time and space complexity of Turing\nmachines, complexity classes such as P, NP, PSpace, NPSpace and NPC, and prove\nNP-completeness by reduction. The module will also introduce basic concepts and results in\npropositional logic, predicate logic, and program verification. In particular, students will learn to\ndistinguish between syntax and semantics, and be able to use formal proof systems such as\nnatural deduction. They will understand the limitations of logic in terms of decidability and\nexpressiveness, and how to use a formal calculus such as Hoare logic to specify programs and\nprove them correct.\nModule learning outcomes\nUse unrestricted grammars and Turing machines to specify semi-decidable languages.\nProvide examples of unsolvable problems and prove that a problem is unsolvable by reducing a\nknown unsolvable problem to it.\nExplain the Church-Turing thesis and its significance.\nDefine the classes P and NP, and explain their relation to the class ExpTime.\nExplain the significance of NP-completeness and provide examples of NP-complete problems.\nExplain the meaning of formulas in propositional and predicate logic, and translate such\nformulas into English and vice-versa.\nExplain the fundamental difference between syntax and semantics.\nApply the rules of natural deduction to construct proofs, and determine the truth or falsity of\nformulas in a given model.\nExplain the limitations of logic and the relationship between logic and computability.\nReason deductively about programs using formalisms such as Hoare logic and weakest\npreconditions\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, revision classes, and after the final\nassessment as per normal University guidelines.\nIndicative reading\n**** Martin, John C., Introduction to Languages and the Theory of Computation (4th ed.),\nMcGraw Hill, 2010\n** Rich, Elaine, Automata, Computability and Complexity, Pearson Education, 2008\n** Sipser, Michael, Introduction to the Theory of Computation (3rd ed.), South-Western College\nPublishing, 2012\n* Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D., Introduction to Automata\nTheory, Languages and Computation (3rd ed.), Pearson Education, 2013\n* Arora, Sanjeev and Barak, Boaz, Computational Complexity: A Modern Approach, Cambridge\nUniversity Press, 2009\n++ Garey, Michael R. and Johnson, David S., Computers and Intractability: A Guide to the\nTheory of NP-Completeness, W.H. Freeman, 1979\nINTELLIGENT SYSTEMS: MACHINE LEARNING & OPTIMISATION\nModule summary\nMachine Learning & Optimisation.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module introduces the field of Artificial Intelligence, key approaches within the field and\nphilosophical questions such as what it means for a machine to understand. Students will learn\nthe theory and practice of machine learning techniques covering linear regression, simple neural\nnetworks, linear algebra and continuous optimisation. Students will see motivating real world\nproblems, the ML techniques required to solve them, the underlying mathematics needed for the\ntechnique and their practical implementation. Practicals will be taught using Python, and the\ngroup project will introduce the students to a Python-based modern machine learning library\nsuch as TensorFlow or PyTorch.\nModule learning outcomes\nExplain the difference between strong, weak and general AI, understand the relationship\nbetween computation and AI, define the machine learning paradigm, and distinguish it from the\nwider field of AI\nCompute partial derivatives and understand the concept of the gradient as a generalisation of\nthe derivative\nExpress, manipulate and solve systems of linear equations using linear algebra, and apply\nlinear regression and logistic regression\nOptimise multivariate functions using gradient descent\nExplain the concept of overfitting and how regularisation can be used to prevent it\nConstruct a basic neural network using a modern machine learning library and learn its weights\nvia optimisation using the backpropagation algorithm\nDeconstruct ethical arguments relating to AI and its applications, and appreciate the ethical and\nprivacy implications of machine learning\nIndicative assessment\nTask % of module mark\nEssay/coursework 30\nOnline Exam -less than 24hrs (Centrally scheduled) 70\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 30\nOnline Exam -less than 24hrs (Centrally scheduled) 70\nModule feedback\nFeedback is provided through work in practical sessions, and after the assessments as per\nnormal University guidelines.\nIndicative reading\nArtificial Intelligence: A Modern Approach by Russell and Norvig\nENGINEERING 1: SOFTWARE & SYSTEMS ENGINEERING\nModule summary\nIntroduction to Software and Systems Engineering\nRelated modules\nPre-requisite modules\nSoftware 2: Object Oriented Data Structures & Algorithms (COM00016C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis is the students' first opportunity to integrate their skills into a development project. Starting\nfrom a broad problem description and working in groups, students will design, develop and test\na complex system. The students will be introduced to the software engineering terminology,\nlifecycle and processes and will become familiar with principles, techniques and tools for, and\ndevelop hands-on experience of eliciting requirements; defining software architectures;\ndesigning and implementing software in an object-oriented way using established patterns;\nreviewing, testing and refactoring software systems; and setting up continuous integration and\ndelivery processes. Students will also develop an appreciation of how to identify, mitigate and\nmonitor risks, how to manage software projects, and how to reuse and extend 3rd-party\ncode/libraries. Overarching themes of the module will include traceability, cyber-security and\nethical considerations across the engineering lifecycle.\nModule learning outcomes\nE101\nApply an understanding of software engineering terminology, lifecycles and process models, to\nhelp with undertaking a project.\nE102\nElicit and document user and system requirements.\nE103\nArchitect, design and implement software in an object-oriented way.\nE104\nDemonstrate how the estimation of risk can be used to improve decision-making, and to make\nrealistic estimates for a project.\nE105\nDefine unit- and system-level tests for software, and use continuous integration processes.\nE106\nApply mechanisms for working in teams to successfully undertake a group project.\nE107\nApply different models for software licensing and reuse of 3rd party software to the artefacts\ndeveloped in the module.\nE108\nDemonstrate consideration of cyber-security and ethical considerations in the engineering\nlifecycle, through practice and documentation.\nE109\nWrite documentation and design/deliver presentations for the different stages of the engineering\nlifecycle.\nIndicative assessment\nTask % of module mark\nGroupwork 35\nGroupwork 65\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 35\nEssay/coursework 65\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines\nIndicative reading\n**** Ian Sommerville, Software Engineering (latest edition), Addison-Wesley, 2010\n*** Roger Pressman, Software Engineering (latest edition), McGraw-Hill, 2010\nSYSTEMS & DEVICES 3: ADVANCED COMPUTER SYSTEMS\nRelated modules\nPre-requisite modules\nSystems & Devices 1: Introduction to Computer Architectures (COM00011C)\nCo-requisite modules\nNone\nProhibited combinations\nNone\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module continues the Systems and Devices stream by considering advanced computer\nsystems in terms of their structure and how it affects their programming. To this point, the\nsystems introduced have been basic uniprocessors with simple memory. The module starts by\nintroducing the concept of multiple processor architectures, pipelined and superscalar\nprocessors, systems-on-chip and advanced memory structures, including caches.\nThe rest of the module considers how these hardware features affect the way that such modern\nsystems are efficiently programmed. Issues of programming for pipelines, caches, etc. are\nconsidered. Then how processes running in parallel on separate processors can share\nunderlying resources safely. Finally, the module considers building blocks for parallel\nprogramming, e.g. threads and communication. It will also consider how such constructs map to\nprocessor instructions. The module will consider real-world examples throughout.\nModule learning outcomes\nS301\nAppreciate how, and why, the hardware structure of multiprocessor architectures differs from the\narchitectures discussed in S&D1. Use this knowledge to develop software applications for such\narchitectures.\nS302\nUse knowledge of computer system design concepts to evaluate the likely performance of a\nproposed computer architecture.\nS303\nDemonstrate the ability to optimise software for advanced hardware features like caches,\nbranch predictors, and pipelines.\nS304 Demonstrate through software development, how data structures are laid out in memory,\nhow they can be accessed from a program, and how processor instructions are generated to\nmanipulate them.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone\nAdditional assessment information\nStudents will only need to retake failed assessment components.\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines\nIndicative reading\n**** H. Abelson, and G.J. Sussman, Structure and Interpretation of Computer Programs, MIT\nPress, 1996\n*** R.W. Sebesta, Concepts of Programming Languages, Addison Wesley, 2009\n*** A. Burns and G. Davis, Concurrent Programming, Addison-Wesley, 1993\n** D. Watt and W. Findlay, Programming Language Design Concepts, Wiley, 2004\n** T.W. Pratt and M.V. Zelkowitz, Programming Languages: Design and Implementation,\nPrentice Hall, 2001\n** D. Lea, Concurrent Programming in Java, Addison Wesley, 1996\n** A. Burns and A. Wellings, Concurrent and Real-Time Programming in Ada, CUP, 2007\n** F. Casarini and S. Thompson, Erlang Programming, O'Reilly, 2009\n** A. Burns and A. Wellings, Real-Time Systems and Languages 4/e, Addison Wesley\n",
        "Year 3\nCAPSTONE PROJECT (PRBX): COMPUTER SCIENCE (UG)\nProfessional requirements\nPlease see the additional assessment information above.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26 to Semester 2 2025-26\nModule aims\nThe aims of this module are to provide a culmination of three years' teaching in a substantial\nCapstone Project Module (CPM).The project provides an introduction to independent study in\nan engineering context, supports synthesis and application of material from the degree course,\nand gives the student the opportunity to demonstrate an appreciation of engineering methods\nand techniques, through coverage of requirements, ethical considerations, specification, design,\nimplementation and evaluation. On completion of the project, the student will have gained the\npractical skills that can only be gleaned from the experience of undertaking independent\n(supervised) study. The student will also have the experience of having written a substantial\nacademic report.\nModule learning outcomes\nDemonstrate acquired specialisation in a particular part of the subject area, including enhanced\nor new technical skills that build on taught theory.\nDemonstrate acquired skills to undertake a computer systems (software and/or hardware)\nengineering project, including design, implementation and evaluation.\nDemonstrate a practical understanding of how established techniques of research and enquiry\nare used to create and interpret knowledge.\nRecognise alternatives, selecting and justifying the approach taken at each point in the report,\nidentifying parts of the project area that are feasible within the time (etc) constraints of the\nproject.\nAppreciate the latent issues of the subject area (for example, in software engineering they might\nmeet and tackle such as emergent requirements, design flaws, equipment/application\nproblems).\nPrepare a written report on the work done, according to the defined criteria. In particular, the\nstudent should be able to prepare a report with a good structure and clear presentation, and in\nwhich the referencing is of publishable academic standard. The report must demonstrate critical\nabilities and evaluation of work done and methods applied.\nArticulates an understanding of legal, ethical, social, professional and commercial issues\ninvolved in the project, detailing potential issues and mitigation strategies.\nSummarise the context, method, results, and implications of the project in an engaging form for\na non-expert audience.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNon-compensatable\nAdditional assessment information\nPlease note, as per University of York assessment regulations (see the Rules for Progression\nand Award), it is only possible to resit UG Capstone Project Modules (CPMs) when this is\npermitted within the total module credit resit threshold for the year. Currently, this threshold is 60\nmodule credits.\nDue to PSRB (accreditation requirements) there are also special assessment rules that apply to\nPRBX. First PRBX cannot be compensated. Second, only in the case of marginal fail of PRBX\n(marks that fall within 30-39), reassessment is permitted. Students are given the opportunity to\nmake amendments to enable them to reach a pass threshold, within a specified time frame. The\nmark for the resubmitted PRBX will be capped at the pass mark (40). There will only be one\nsuch reassessment. These rules are applicable to all students who take PRBX, regardless of\nprogramme.\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback on written report draft (where draft provided to supervisor in a timely manner).\nWritten feedback after written project report.\nIndicative reading\n*** Dawson, C. W Projects in Computing and Information Systems. Addison-Wesley 2005\n*** Gowers, E. The complete plain words. Penguin 1987\n*** Kopka, H and Daly, P.W. A guide to LATEX : document preparation for beginners and\nadvanced users, 3rd edn. Addison-Wesley 1999\n*** Zobel, J. Writing for computer science, 2nd edn. Springer 2004\nAI PROBLEM SOLVING WITH SEARCH AND LOGIC\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent, plus good knowledge of AI fundamentals, predicate logic and\nprogramming.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module will introduce key approaches in Artificial Intelligence for tasks such as: finding a\nsequence of actions to achieve a goal; playing adversarial games; and solving discrete\noptimization problems such as configuration and scheduling. Students will learn the theory and\npractice of AI search, logic, and constraint-based approaches. The module aims to equip\nstudents with a wide range of problem-solving tools, how to design effective heuristics for them,\nand enable comparison of methods to determine which are best suited to a given problem.\nSome of the tools covered are state-space search algorithms (i.e. A* Search, IDA*, and Greedy\nBest-First Search), game-tree search algorithms (i.e. Minimax and Monte-Carlo Tree Search),\nlocal search methods for solving discrete optimization problems, constraint programming, and\nthe satisfiability (SAT) problem in knowledge representation and reasoning.\nModule learning outcomes\nRepresent a given search problem in terms of states, actions, and a goal, and identify a suitable\nheuristic.\nRepresent a given scenario using propositional logic to enable logical inference (for example,\nusing a SAT solver).\nModel (represent) and solve discrete optimization problems using a modern constraint\nprogramming system.\nSelect and apply an appropriate AI state-space search algorithm for a given problem, identifying\nreasons for the choice of algorithm in comparison to others.\nSelect and apply an appropriate adversarial (game-tree) search method to solve a given game,\nincluding design of a suitable heuristic if required.\nDescribe the algorithms commonly used in SAT (propositional satisfiability) solvers, local search\nsolvers, and constraint solvers, and apply them to small examples.\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nAUTONOMOUS ROBOTIC SYSTEMS ENGINEERING\nModule aims\nThis module will introduce students to the theoretical concepts and practical skills required to\nengineer autonomous robotic systems. It will cover fundamental aspects of sensors/actuators\nand control systems, then build upon this foundation with high-level algorithms for autonomous\nlocalisation, mapping, navigation, and multi-robot coordination. This module will also explore\nsafety considerations and ethical implications of the design, implementation, and deployment of\nautonomous robotic systems.\nModule learning outcomes\nDescribe the degrees of autonomy that robotic systems can achieve\nDiscuss the safety considerations and ethical implications of the design, implementation, and\ndeployment of autonomous robotic systems\nExplain methodological principles for engineering autonomous robotic systems\nDemonstrate an understanding of modern robotics middleware and its application\nImplement an autonomous robotic solution for a predefined problem\nDiscuss the strengths and weaknesses of an implemented autonomous robotic solution\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nCorrell, Nikolaus, et al. Introduction to Autonomous Robots: Mechanisms, Sensors, Actuators,\nand Algorithms. MIT Press, 2022.\nHerath, Damith, and David St-Onge. Foundations of Robotics: A Multidisciplinary Approach with\nPython and ROS. Springer Nature Singapore, 2022.\nEVOLUTIONARY & ADAPTIVE COMPUTING\nModule summary\nThis module introduces a range of biologically-inspired approaches to computing.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module introduces a range of biologically-inspired approaches to computing. It provides a\nfoundation of both theoretical and practical knowledge on the subject of evolutionary\ncomputation, an optimisation technique inspired by biological evolution. Students will have\nhands-on experience implementing a number of types of evolutionary algorithms using Python\nand the library DEAP: Distributed Evolutionary Algorithms in Python, to solve a range of different\ntypes of problems. The module also studies the use of Agents and Multi-agent Systems as a\nmodelling paradigm, with a focus on evolutionary adaptation and learning.\nModule learning outcomes\nDesign and implement evolutionary systems to address a given problem.\nUnderstand the biological underpinnings of evolutionary algorithms, and use them to optimise\nmathematical functions and agent behaviours.\nDefine a range of agent behaviours and represent them in a form that is well suited to natural\nselection\nModel processes in populations of agents using hand-written mathematical models\nCritically evaluate the performance and implementation of evolutionary and multi agent systems.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n++ Banzhaf et al, Genetic Programming: An Introduction, Morgan Kaufmann , 1999\n++ M. Mitchell, An Introduction to Genetic Algorithms, MIT Press, 1998\nCOMPUTER VISION & GRAPHICS\nModule summary\nThis module will introduce modern computer vision approaches, including discussion of the\nmain applications and challenges.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module will introduce modern computer vision approaches, including discussion of the\nmain applications and challenges. It will cover issues of image formation, camera geometry,\nfeature detection, motion estimation and tracking, image classification and scene\nunderstanding, using a range of model-based approaches.\nModule learning outcomes\nDemonstrate a detailed understanding of the image formation process, its modelling in\ncomputer vision and its simulation in computer graphics\nDescribe and implement techniques for rendering images including modelling light/material\ninteraction\nUnderstand a range of methods for inferring 3D shape from images\nApply fundamental machine learning methods for image understanding\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n** Forsyth and Ponce Computer Vision a Modern Approach Prentice Hall\n** Anil K. Jain Fundamentals of Digital Image Processing Prentice Hall\nCRYPTOGRAPHY THEORY & PRACTICE\nModule summary\nThe module aims to provide a broad overview of modern cryptography. The module will cover\nthe fundamental security goals achieved through cryptographic algorithms and protocols, how\nthey are formalised, designs that enable achieving those goals, and how formal security\narguments can be made for the design achieving the security goals.\nRelated modules\nPre-requisite modules\nNone\nCo-requisite modules\nNone\nProhibited combinations\nCryptography (MAT00080H)\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThe module aims to provide a broad overview of modern cryptography. The module will cover\nthe fundamental security goals achieved through cryptographic algorithms and protocols, how\nthey are formalised, designs that enable achieving those goals, and how formal security\narguments can be made for the design achieving the security goals.\nModule learning outcomes\nBy the end of the module the students will be able to:\ndescribe and apply the fundamental security properties provided by cryptographic algorithms\nand protocols;\ndescribe how these security properties are formalised;\ndescribe the implications of cryptographic security arguments;\nidentify security requirements for a given practical scenario and identify the appropriate\ncryptographic tools to achieve the security requirements;\nassess whether given cryptographic algorithms and protocols meet identified security\nrequirements; and\nanalyse the security and efficiency of cryptographic protocols from both theoretical and practical\npoints of view.\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n[1] J. Katz, Introduction to modern cryptography, Third edition :: Chapman & Hall/CRC, 2020\n[2] J.-P. Aumasson, Serious cryptography : a practical introduction to modern encryption :: No\nStarch Press, 2018\n[3] C. Paar, Understanding cryptography : a textbook for students and practitioners :: Springer,\n2009\n[4] A. McAndrew, Introduction to cryptography with open-source software :: CRC Press, 2011\n[5] W. Stallings, Cryptography and network security : principles and practice, Seventh edition ::\nPearson, 2017\n[6] A. J. Menezes, Handbook of applied cryptography :: CRC Press, 1997\nEMBEDDED SYSTEMS DESIGN & IMPLEMENTATION\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThe aim of this module is to understand the need for embedded computer systems, and the\nengineering process to design, implement and validate them.\nModule learning outcomes\nArticulate the need for embedded computer systems, and the requirements imposed on them by\ntheir application scenario.\nBe able to apply an engineering process to design, implement and validate embedded systems.\nDemonstrate the different levels of abstraction that are used throughout the design process, and\nbe able to decide the most appropriate abstractions at each step.\nExplore hardware/software implementation trade-offs, and a number of partitioning, mapping\nand evaluation techniques that can be used to analyse that trade-off for a particular application\nscenario.\nProgram computing platforms that have limited performance, energy, memory and storage\ncapacity.\nDesign and evaluate custom hardware architectures.\nUnderstand the process to improve and assure timing properties, including priority assignment,\nscheduling of real-time tasks and schedulability analysis.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is given to each student on each of the two assessments, highlighting the strengths\nand weaknesses of the proposed design. Additional feedback is also given during practical\nsessions, which are also based on design problems.\nIndicative reading\nP. Marwedel, Embedded System Design, Springer, 2011\nENGINEERING 2: AUTOMATED SOFTWARE ENGINEERING\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module builds on ENG1 and introduces advanced techniques for engineering large,\ndata-intensive software systems that consist of components written in different programming\nlanguages and operating on a variety of platforms. In order to manage the complexity of\nengineering such data-intensive systems, ENG2 will introduce the theory, principles and\npractices of model-driven engineering (MDE), focusing on technical topics. These include\nmodelling, metamodelling, model management, model transformation, model-driven traceability,\nworkflows, model validation, and model evolution. Non-technical issues including standards,\ndomain-specific MDE versus general-purpose MDE and MDE processes will also be\nconsidered. The discussion of concepts and technologies for engineering modern data-intensive\nsoftware systems will start from a general discussion about architectural concerns, then move\non to discuss their design, implementation as a collaboration of microservices, and using\ncontainers for reproducible and scalable deployment. ENG2 will discuss assurance practices\naround data-intensive software systems, such as testing and hardening.\nModule learning outcomes\nDemonstrate the principles and practices of modelling and metamodelling.\nImplement and orchestrate domain-specific models, metamodels and model management\noperations.\nDemonstrate the design principles for data-intensive software systems, including their\narchitecture characteristics like availability, scalability, reliability and security, and the\ncharacteristics of the organisation.\nStructure data-intensive systems as combinations of independently maintained microservices,\nand propose benefits and challenges in terms of complexity management, organisational\nscalability, and resource usage.\nDeploy the components of data-intensive systems in a scalable and reproducible manner, by\npackaging them as containers and orchestrating these containers to work with each other.\nDescribe assurance practices in the development and deployment of large data-intensive\nsystems, including testing and hardening.\nArticulate how Model-Driven Engineering integrates with wider system engineering processes\nand policies, including those of a data-intensive software system.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nNewman, Sam. Building Microservices, O'Reilly Media, 2021.\nKleppmann, Martin. Designing Data-Intensive Applications: The Big Ideas Behind Reliable,\nScalable, and Maintainable Systems, O'Reilly Media, 2017.\nWasowski A. Domain-Specific Languages: Effective Modeling, Automation, and Reuse. 1st ed.\n2023. (Berger T, ed.). Springer International Publishing; Imprint Springer; 2023.\nETHICAL HACKING, ANALYSIS & INVESTIGATION\nModule aims\nThe module aims to provide an introductory range of theoretical and practical skills to undertake\nethical hacking, analysis, and investigation of modern computer systems and networks.\nThe module will explore ethical hacking topics such as vulnerability exploitation of cryptographic\nand network protocols, reverse engineering, and other penetration testing techniques, as well as\nmalware analysis and digital investigation of cyber incidents.\nThe module will familiarise students with a range of tools used by ethical hackers and security\npractitioners.\nModule learning outcomes\nBy the end of the module the students will be able to:\nExplain the fundamental concepts of cyber security in systems and networks\nUnderstand the security strengths & weaknesses in network mechanisms\nUnderstand the major threats and attacks in systems and networks under various scenarios,\narchitectures, and threat models\nAnalyse control solutions for network security\nAssess the relative merits of different solution approaches in various security-related contexts\nIndicative assessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 50\nClosed/in-person Exam (Centrally scheduled) 50\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nClosed/in-person Exam (Centrally scheduled) 50\nClosed/in-person Exam (Centrally scheduled) 50\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nJon Erickson. Hacking: The Art of Exploitation. No Starch (2008)\nSikorski, Michael ; Honig, Andrew. Practical Malware Analysis: A Hands-On Guide to Dissecting\nMalicious Software. No Starch Press, Incorporated (2012)\nHIGH-INTEGRITY SYSTEMS ENGINEERING\nModule summary\nThis module teaches students to adapt their software development practice to take account of\nthe general criticality and the specific risks of the software they are developing.\nRelated modules\nStudents on the joint Mathematics and Computer Science programmes who are interested in\nthis module should discuss the necessary prerequisite knowledge with the module leader.\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nGood knowledge of software engineering practice.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module teaches students to adapt their software development practice to take account of\nthe general criticality and the specific risks of the software they are developing. Students will\ngain a broad understanding of the issues involved in designing and implementing critical\nsystems, be aware of the methods used to construct critical systems, and understand the\nlimitations of the various methods, analysis techniques and tools currently in use.\nModule learning outcomes\nUnderstand and articulate the issues involved in designing and implementing critical systems\nApply a range of techniques to the design, and validation of high integrity systems, such as\nfault-tree analysis and failure analysis.\nDiscuss issues of high integrity engineering, both technical and social.\nParticipate in significant discussion periods brainstorming scenarios and discussing previous\nwell-documented examples of system failures\nIntroduce existing software engineering concepts for the development of critical systems\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, through discussion sessions, and after\nthe final assessment as per normal University guidelines.\nIndicative reading\nN.G. Leveson, Safeware: System Safety and Computers, Addison-Wesley, 1995\nHIGH-PERFORMANCE PARALLEL & DISTRIBUTED SYSTEMS\nModule summary\nThis module introduces and explores the use of high-performance computing, and related\ntechnologies.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module introduces and explores the use of HPC and related technologies, covering on and\noff node parallelism, accelerators, and memory management. Students will understand the\nincreasingly important role that HPC plays in science and engineering. Throughout the module,\nstudents will practice by developing programs using a range of parallel programming paradigms\nlike OpenMP and MPI.\nModule learning outcomes\nDemonstrate the development of parallel programs on shared memory systems using popular\nprogramming paradigms.\nBe able to understand appropriate metrics to assess the performance of applications and\nsystems.\nDemonstrate the development of parallel programs on distributed memory systems using\nappropriate parallel programming libraries.\nBe able to explore the design space afforded by parallel and distributed systems, including\nissues of GPU programming, high-speed networking, and I/O.\nBe able to reason about the performance, portability, and productivity of different approaches to\ndeveloping HPC applications.\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\nIntroduction to High Performance Scientific Computing, Eijkhout, Victor; van de Geijn, Robert;\nChow, Edmond\nHUMAN FACTORS: TECHNOLOGY IN CONTEXT\nAdditional information\nPre-Requisite Module:\nHuman-Computer Interaction (HCIN) - COM00018C\nPre-Requisite Knowledge:\nResearch Methods\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nNone.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module will equip students with an understanding of how human characteristics and design\ninfluence interactions with technical systems in organisational and industry contexts. The\nmodule uses real-world case studies to introduce and critically evaluate the contribution of\nhumans in developing and maintaining safe, ethical and secure systems. The module aims to\ndevelop students' skills in:\nAnalysis techniques\nProposing and applying appropriate criteria to assess the rigour and suitability of industrial and\nacademic approaches to human reliability.\nModule learning outcomes\nRecognise the role of human characteristics/factors/mental models in relation to the safe,\nsecure and effective operation and maintenance of interactive systems across applied/industry\ncontexts\nCritically evaluate the quality of designs and propose solutions to security and safety issues\nDemonstrate the ability to locate and, where relevant, apply existing academic research to\ninform the consideration of issues arising within human-technology interactions\nIdentify, apply and critique appropriate techniques for human reliability and error analysis\nIdentify, apply and critique appropriate techniques for security analysis, including issues of\nauthentication, privacy and foreseeable misuse\nUse appropriate frameworks and design techniques to investigate ethical issues in relation to\nhuman-machine interaction\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nINTELLIGENT SYSTEMS: PROBABILISTIC & DEEP LEARNING\nAdditional information\nPre-Requisite knowledge - Understanding of the theory and practice of Machine Learning. For\nundergraduates this is covered in intelligent systems modules (for example, INT2 - Intelligent\nSystems 2: Machine Learning & Optimisation COM00024I or IMLO - Intelligent Systems:\nMachine Learning & Optimisation COM00026I).\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent plus good understanding of the theory and practice of machine\nlearning.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThis module builds on the basic machine learning covered previously in the programme, and\ntakes students up to state of the art methods in modern deep learning. It introduces probabilistic\nmethods, where we can reason about uncertainty, and deep learning based methods, where\nneural networks with many layers prove to be the most powerful general model for learning. We\nwill see a range of methods and architectures for classification and regression problems,\nunsupervised generative models and the mathematics that underlies these techniques. We will\ncover both theory and practicalities: how are these ideas actually implemented in a modern\nmachine learning library like PyTorch?\nModule learning outcomes\nExplain the probabilistic basis of machine learning\nDemonstrate a working knowledge of manifold embedding and kernel methods\nApply a range of Bayesian methods for regression, classification and clustering\nBe familiar with the main deep learning architectures\nDemonstrate the optimisation process and different variants (i.e. gradient descent, stochastic\nalgorithms, ADAM)\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines\nIndicative reading\nSolomon, Justin. Numerical Algorithms. AK Peters/CRC Press, 2015\nLEGAL PRACTICE, TECHNOLOGY & COMPUTER SCIENCE\nModule summary\nLaw and computer science students will work collaboratively in teams to develop a\ntechnology-based solution to a real-life legal practice process problem. From initial analysis of\nthe problem, teams will work to develop a solution to the problem, assessing both legal and\nprocedural issues, system and user design requirements, functionality, costs, benefits and risks.\nStudents from each discipline will contribute know-how from their discipline to the project, whilst\ngaining new understanding and skills. The module will be supported by a leading international\nlaw firm with a technology hub in the region, providing students with access to external\nexpertise in the field, in addition to disciplinary tutor support.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nThe aim of the module is to provide law and computer science students with an opportunity to\ndevelop an applied understanding of how technology and computer science are being applied in\ndeveloping new approaches to the provision of legal services and how these can offer greater\naccessibility to justice, as well as efficiency, quality and costs gains. Students will develop\nknowledge both within their own and the colloborative discipline, as well as a range of analytical,\nproblem-solving, planning, communication and interpersonal skills. The module also aims to\nprovide students with opportunities to interact with experts in legal practice technology and thus\ngain contemporary professional perspectives on the areas covered in the module.\nModule learning outcomes\nOn completion of this module, students should be able to:\nAnalyse a legal process which may be improved for users by application of computer science\nApply design thinking to identify procedural, technical, legal and user issues\nCommunicate orally and in writing relevant principles from their primary discipline to colleagues\nfrom another discipline\nCollaborate and synthesise disciplinary principles to develop potential solutions\nEvaluate potential solutions against user requirements\nFormulate a costed implementation plan for an agreed solution\nPresent a persuasive written and oral case for the solution\nExplain the potential applications of computer science and technology in the development of\nlegal services\nReflect on learning gains and challenges from the module, including cross-disciplinary\ncollaboration\nModule content\nLaw and computer science students will work collaboratively to develop a solution to a legal\nprocess problem, based on a real-life access to justice scenario. This will be developed in\ncollaboration with a law firm.\nThe module will use problem-based learning (PBL) techniques, and be predominantly\ngroup-assessed. Students will receive a problem and, working in teams comprising equal\nnumbers from each discipline will apply PBL techniques to identify:\nsubstantive and procedural issues\nclient and internal commercial issues\nrisks\nprocess requirements\nUsing these as the basis to develop a solution, there will be an element of cross-discipline\nteaching: law students will have to be able to explain law, procedure and process requirements\nto computer science students and the latter will have to explain tech functionality and\ncapabilities, in each case in language understandable to those from the other discipline.\nFollowing initial detailed analysis of the problem, teams will work to develop a solution to the\nproblem, with activity moving from analysis to development. They will plan a programme of work\noutside class activity sessions, with the latter acting as formal workshops/surgeries, during\nwhich teams can obtain feedback from facilitators from both disciplines. There will also be an\nopportunity to obtain feedback from a legal technology expert from a law firm, as part of a\nplenary \"masterclass\".\nThe assessment will require submission of the solution - e.g., system requirements;\nfunctionality; process map; costs; benefits; risk; time-line to implementation - in the form of a\nbusiness proposal, together with an oral presentation by each group. Individual students will\nalso submit a personal reflection on learning gained against the module outcomes.\nIndicative assessment\nTask % of module mark\nEssay/coursework 20\nGroupwork 50\nOral presentation/seminar/exam 30\nSpecial assessment rules\nNone\nAdditional assessment information\nFormative feedback will be provided on a rolling basis by facilitators as teams progress through\nthe analysis and development stages of the module, especially during workshops.\nIndicative reassessment\nTask % of module mark\nEssay/coursework 20\nGroupwork 50\nOral presentation/seminar/exam 30\nModule feedback\nStudents will receive summative feedback as follows:\noral feedback on group presentation\nwritten feedback on group submission\nwritten feedback on individual reflective submission\nIndicative reading\nThe Future of the Professions: Susskind & Susskind \u2013 OUP 2017\nTomorrow\u2019s Lawyers \u2013 Susskind \u2013 OUP 2017\nThe End of Lawyers? Susskind \u2013 OUP 2008\nNETWORK SECURITY\nModule summary\nNetwork Security (NETS): This module covers the basic concepts of cyber security, how these\nare modelled, threat models, and the mechanisms to enforce security policies.\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nThis module aims to provide a broad knowledge of network and system security, addressing\nthreats over a range of network layers and detailing corresponding defensive countermeasures\nand protocols. The module will cover the basic concepts of cyber security (confidentiality,\nintegrity and availability), how these are modelled, threat models (adversary capabilities and\ngoals), and basic control mechanisms to enforce security policies (e.g. access control). Students\nwill learn to understand network security, threats, and the mechanisms that have been\ndeveloped to counter them. It explores a range of different networked systems, the main\nnetwork attacks, and their defence mechanisms.\nModule learning outcomes\nBy the end of the module the students will be able to:\nDescribe the fundamental concepts of cyber security in systems and networks\nIdentify security strengths & weaknesses in network mechanisms\nIdentify major threats and attacks in systems and networks under various scenarios,\narchitectures, and threat models\nPropose control solutions for network security\nAssess the relative merits of different solution approaches in various security-related contexts\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided through work in practical sessions, discussion in seminars, and after each\nassessment as per normal University guidelines.\nIndicative reading\nSherri Davidoff, Jonathan Ham, Network Forensics: Tracking Hackers Through Cyberspace,\nPrentice Hall, 2012\nKevin R Fall, W Richard Stevens, TCP/IP Illustrated, Volume 1: The protocols, Addison Wesley,\n2012\nAndrew Tannenbaum, Computer Networks, Prentice Hall, 2002\nPLAYER EXPERIENCES IN DIGITAL GAMES\nModule aims\nThis module will provide students with a comprehensive understanding of player experience and\nthe different ways in which games can impact players. In addition to learning about what player\nexperience is and how to evaluate it, the module will also cover the effects of games on players\n(e.g. in relation to wellbeing) and the use of games for applied purposes (e.g. behaviour\nchange).\nModule learning outcomes\nDemonstrate an understanding of the breadth of player experience\nSelect appropriate methods for evaluating different kinds of player experience\nConduct playtesting sessions and report on the findings\nCompare and contrast the different ways in which digital games can affect players\nPlan appropriate evaluations for applied games\nIndicative assessment\nTask % of module mark\nEssay/coursework 60\nGroupwork 40\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 60\nGroupwork 40\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nDrachen, A., Mirza-Babaei, P., & Nacke, L. E. (Eds.). (2018). Games user research. Oxford\nUniversity Press.\nStahlke, S., & Mirza-Babaei, P. (2022). The Game Designer's Playbook: An Introduction to\nGame Interaction Design. Oxford University Press.\nQUALITATIVE APPROACHES TO INVESTIGATING UX\nModule aims\nThis module will provide students the methodological approaches to interrogating concepts and\nusers\u2019 subjective experiences with interactive systems. The module provides theoretical and\npractical grounding in methods used for collection and analysis of qualitative data that are used\nin industry and academic research. Students will learn how different qualitative methods can be\nused for a range of purposes, from informing to design to understanding technology use in\ncontext.\nModule learning outcomes\nIdentify and justify use of appropriate qualitative methodology\nRecognise and acknowledge the underpinning epistemological positions of qualitative methods\nRecognise the role of the researcher in the research process\nCritique and contrast the methods of studies against the standards of rigour and validity of the\nchosen methodology\nReport and discuss the results of an analysis appropriate to the method used\nDescribe the important aspects of research governance including ethical conduct and data\ngovernance\nIndicative assessment\nTask % of module mark\nEssay/coursework 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 100\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nQUANTUM COMPUTATION\nModule summary\nThe aim of this module is to introduce the theory of quantum computation. In it we will learn\nabout the pioneering quantum algorithms that promise a qualitative leap in computation power\nover conventional computers.\nElective Pre-Requisites\nThese pre-requisites only apply to students taking this module as an elective.\nA Level Maths or Equivalent; good understanding of programming.\nModule will run\nOccurrence Teaching period\nA Semester 2 2025-26\nModule aims\nIntroducing both the promise and limitations of quantum computation. Gate operations, evolving\nquantum states, calculating the result of measurements on quantum states, designing and\nanalyzing quantum computational circuits, key algorithms (e.g., Shor's, Grover's and the\nDeutsch-Jozsa algorithms).\nModule learning outcomes\nArticulate both the promise and limitations of quantum computation.\nApply some of the many concepts and techniques in quantum computation (e.g., applying gate\noperations and evolving quantum states, calculating the result of measurements on quantum\nstates, designing and analyzing quantum computational circuits);\nExplain some of the key algorithms (e.g., Shor's, Grover's and the Deutsch-Jozsa algorithms)\nand their implications, and are able to simulate these algorithms on quantum states.\nIndicative assessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nOnline Exam -less than 24hrs (Centrally scheduled) 100\nModule feedback\nFeedback is provided through work in practical sessions, and after the final assessment as per\nnormal University guidelines.\nIndicative reading\n*** G. Benenti, et al., Principles of Quantum Computation and Information, vol I, World Scientific,\n2004\n*** G. Benenti, et al., Principles of Quantum Computation and Information, vol II, World\nScientific, 2007\n*** P. Kaye, et al., An Introduction to Quantum Computing, Oxford University Press, 2007\nRESEARCH METHODS IN COMPUTER SCIENCE\nModule summary\nA core module that equips postgraduate taught students with core theorectical and practical\nresearch skills.\nModule will run\nOccurrence Teaching period\nA Semester 1 2025-26\nModule aims\nResearch is about both generating new knowledge and evaluating confidence in knowledge.\nThere are three skills associated with the conduct of good research:\nThe ability to accurately identify from existing literature and systems a meaningful or important\ngap in knowledge, and therefore what constitutes new knowledge in the domain of Computer\nScience\nThe ability to competently intervene in the world (e.g. through developing systems,\nimplementing data collection procedures, conducting experiments\u2026) in order to generate\nknowledge that causes positive change.\nThe ability to evaluate the quality of evidence stemming from an intervention using sound\nanalysis, and communicate that analysis to the scientific community.\nAs the ways of intervening in the world depend strongly on your disciplinary area, the aim of this\nmodule is to provide an introduction to the first and third pillars, namely the conduct of literature\nreviews to identify a research gap; and the methods for analysing research data, interpreting\nsaid analysis, and accurately presenting research outcomes.\nThe module will also cover general principles related to the second pillar that apply across\ndisciplinary areas in the development of novel methods and conduct of experiments.\nModule learning outcomes\nBy the end of this module, students will be able to\u2026\nIdentify a gap in the evidence base within the structure of a formal academic literature review.\nDiscuss the validity and reliability of methods used in extant or novel research.\nDescribe and apply principles of responsible research and innovation to a research project.\nAnalyse a variety of quantitative research data using an array of appropriate inferential\nstatistical tests.\nPresent the outcomes of a research project.\nIndicative assessment\nTask % of module mark\nEssay/coursework 50\nGroupwork 50\nSpecial assessment rules\nNone\nIndicative reassessment\nTask % of module mark\nEssay/coursework 50\nEssay/coursework 50\nModule feedback\nFeedback is provided throughout the sessions, and after the assessment as per normal\nUniversity guidelines.\nIndicative reading\nHowell DC. Fundamental Statistics for the Behavioral Sciences . 9th edition, student edition.\nCengage Learning; 2017.\nGoldbort R. Writing for Science . Yale University Press; 2006.\n"
    ]
}