{
    "text_curriculum\\VU University.pdf": [
        "COMPUTER PROGRAMMING \nCourse Objective \nKnowledge and understanding: \n \nStudents learn problem solving by implementing algorithms in computer programs. \nStudents learn the basic concepts of programming languages. \nApplying knowledge and understanding: Students are trained in writing small computer \nprograms, and applying the concepts learned. \n \nMaking judgements: Students are trained in testing and judging the correctness of their \nown programs, and to correct programming mistakes. \n \nLifelong learning skills: After completing the course, students will be able to grasp future \nprogramming languages and environments by applying the basic concepts learned \nhere. \n \nCourse Content \nIn this course, students learn the basic concepts of (problem solving with) computer \nprogramming. We are using the C++ programming language. \n \nThe course consists of six modules: \n \nThe basics: data types, operators, type conversions, expressions, statements, if, switch, \nloops \nVectors, user-defined functions with parameter passing, scopes \nError handling, exceptions, streams and input errors, file IO, command line parameters, \nassertions and unit testing \nRecursion: functions that call themselves, understanding how functions work \nClasses: DIY data types, interfaces and implementation, constructors and initialisation \nMemory management: pointers, dynamic memory allocation, memory leaks; Tree data \nstructures as recursive data types \nThe six modules build on top of each other. Students reach the course objectives by \nmastering the higher-level modules five and six. \n \nAdditional Information Teaching Methods \nThis course revolves around self-study with the interactive course e-book, in \ncombination with class sessions for deepening understanding (2 times per week), and \npractical programming assignments (individual preparation and guided lab sessions 3 \ntimes per week). \n \n",
        "Method of Assessment \nThroughout the course, the practical programming assignments assess the student's \nlearning progress. The midterm exam assesses proficiency with modules one, two and \nthree. The final exam assesses proficiency with all six modules. \n \nBoth exams are computer-based and contain programming assignments. There will be \na resit exam, covering all six modules. \n \nThe midterm exam and the final exam together result in the exam grade. Here, the \nmidterm counts for 30% and the final exam for 70%. If taken, the resit exam replaces \nthe combined exam grade from midterm and final. \n \nAll practical programming assignments together result in the grade for the computer \npractical (for details, see Canvas). \n \nFor the practical programming assignments, there will be no resit. (The multiple \nassignments can be used to mutually compensate each other.) \n \nFor passing the course, the exam grade must be at least 6.0. The overall grade is the \nweighted average of the exam grade (65%) and the practical programming assignments \n(35%). This overall grade must be 5.5 or better for passing the course. Students with an \noverall grade of 5.5 or better can raise their total grade by up to 1 bonus point by timely \ncompletion of the exercises in the interactive e-book. \n \nEntry Requirements \nStudents must possess the ability to clear, analytical and abstract thinking, as indicated \nby the level of mathematics required for admission to the program. \n \nLiterature \nProgramming in C++, Frank Vahid and Roman Lysecki, interactive e-book, \nhttps://www.zybooks.com/catalog/programming-c-plus-plus \n \nThe contents of this e-book have been tailored to our course. \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nExplanation Canvas \nCanvas is the place where all communication takes place. Students must make sure \nthey receive Canvas notifications in a timely manner. \n \n",
        "Recommended background knowledge \nStrictly speaking, prior programming experience is not required for following this class. \nBut it certainly helps. Prospective students who have never programmed before may \nwant to spend some time during summer trying out programming in a very user-friendly \nway: We have prepared some introductory exercises using the Hedy programming \nlanguage, accessible via the following link: https://hedy.org/hedy/l/4nWLrAf \n \nThe use of Hedy is free of cost. Students must create a Hedy account before use. \n \n",
        "ENGLISH LANGUAGE TEST \nCourse Objective \nAt VU Amsterdam, having a strong command of the language of your study programme \nis crucial to your academic success. Therefore, all first-year Bachelor students must \ntake a Dutch or English language proficiency test at the beginning of their studies. The \nrequired test depends on the language of instruction for your Bachelor's programme. \n \nSee also: Language Proficiency Test - Vrije Universiteit Amsterdam (vu.nl) \n \nCourse Content \nThe test consists of multiplechoice and fill-in-the-blank questions on the following topics: \n \nGrammar \nSpelling and punctuation \nStructuring \nVocabulary/usage \nPhrasing \nReading comprehension \nPronunciation \nClassroom English \nAdditional Information Teaching Methods \nThe language proficiency test will take place in September in the DigiTenT at the VU. \n \nMethod of Assessment \nThe language proficiency test is a digital test consisting of 200 closed questions. \n \nAdditional Information \nThe VU English Language Test is linked to a first-year course. The final grade for this \ncourse is awarded only after passing the English Language Test. Students who do not \nobtain a satisfactory result for the test have to take the refresher course offered by the \nTaalloket. \n \nFor more information on the VU English Language Test, please see also: Language \nProficiency Test - Vrije Universiteit Amsterdam (vu.nl) \n \nCustom Course Registration \nYou do not need to register for the test. The Educational Office of your faculty will \nensure your registration for the language proficiency test. Once registered, you can find \nthe test\u2019s date and time on your personal timetable. If you have not been registered by 8 \n",
        "September, please contact the student desk. You can also check thetimetable of your \nprogramme for the test schedule. \n \nEnsure you know your VUnet ID and corresponding password, as you will need these \ndetails to log in to the language test. Tip: change your passwordto something you can \neasily remember. \n \n",
        "LOGIC AND SETS FOR CS \nCourse Objective \nAfter completing this course, the student can: \n \nexpress logical statements in propositional and predicate logic (Knowledge and \nunderstanding) (Applying knowledge and understanding) \nreason about the meaning of such formulas through truth tables and models (Applying \nknowledge and understanding) (Making judgements) \nargue formally whether one formula implies another one, or that they are equivalent \n(Applying knowledge and understanding) (Making judgements) \nreduce a propositional formula to disjunctive or conjunctive normal form (Knowledge \nand understanding) (Applying knowledge and understanding) \nexpress propositional formulas in logic circuits and OBDDs (Knowledge and \nunderstanding) (Applying knowledge and understanding) \nFurthermore, the student is able to: \n \nreason about set constructions through Venn diagrams and the algebra of sets \n(Applying knowledge and understanding) (Making judgements) \nconstruct and interpret formal, graphic, and matrix representations of sets, relations, \nand functions (Applying knowledge and understanding) (Making judgements) \ndetermine and argue whether: (Applying knowledge and understanding) (Making \njudgements) \na. a relation is reflexive, transitive, symmetric, or antisymmetric. \nb. a relation is an ordering relation, equivalence relation, or a function \nc. a function is injective or surjective \nconstruct and interpret compositions of relations (or functions) and their inverses \n(Applying knowledge and understanding) (Making judgements) \nconstruct a proof by mathematical induction (Applying knowledge and understanding) \nCourse Content \nThe sets part of the course starts by introducing the concepts of sets, Venn diagrams, \nproduct sets and relations. The student then learns the main characteristics and \nproperties of three particular types of relation: ordering relations, equivalence relations \nand functions. The sets part concludes with a study of the principle of mathematical \ninduction. \n \nThe logic part focuses in the first place on propositional logic: truth tables, boolean \noperators, functional completeness, logical puzzles, SAT-solving, logic circuits and \nOBDDs. In addition the student will learn the meaning and use formulas of predicate \nlogic, to express mathematical properties and sentences from natural language. \n \n",
        "Additional Information Teaching Methods \nEvery week, there is one lecture and one exercise class for the logic part of the course, \nand one lecture and one exercise class for the sets part of the course. \n \nMethod of Assessment \nA written midterm exam (40% of the grade) and a written final exam (60% of the grade). \nFor both the midterm and the final exam, at least a 5.0 must be achieved (and the \noverall mark must be at least 5.5.). \n \nThe resit exam covers all material of the course. \n \nIt is not possible to resit only the midterm exam or only the final exam of the course. \n \nLiterature \nAll course materials are provided via Canvas. \nAdditional Information Target Audience \nBachelor Computer Science ( ) \n \n \n",
        "DATA STRUCTURES AND ALGORITHMS FOR CS \nCourse Objective \nAfter taking this course, you: \n \nhave basic knowledge of data structures and algorithms, \nknow that different data structures are suitable for different computational problems, and \nare able to analyze the performance of algorithms, with regard to their time and space \nrequirements. \nThe following list presents the course objectives according to Dublin Descriptors. \n \nLearn the notations and the language of data structures and algorithms. (Knowledge \nand understanding.) \nLearn some basic data structures including linear data structures (e.g., arrays, linked \nlists, queues, and stacks) and several efficient dictionary data structures (e.g., binary \nsearch trees, AVL trees, and hash tables). Also, familiarize with performances of the \ndifferent data structures with regard to their query and storage requirements. \n(Knowledge and understanding.) \nLearn algorithms for solving some basic problems including sorting, searching, and a \nfew graph-related algorithms like BFS and DFS. \nBe able to use the data structures and the algorithms learned from the course to solve \nan algorithmic problem. (Applying knowledge.) \nGiven an algorithmic problem, pick the most appropriate data structure in order to speed \nup a designed algorithm for the problem and analyze its performances. (Making \njudgements.) \nFamiliarize with few real-life problems that can be modeled as an algorithmic problem \nand can be thus studied using algorithms and data structures. (Communication.) \nCourse Content \nYou will be acquainted with some basic linear data structures (e.g. arrays, lists, queues, \nand stacks), and several efficient dictionary data structures (e.g., binary search trees, \nAVL trees, hash tables). Although our lectures and discussions will be from a theoretical \nperspective, we will also discuss their implementation details whenever needed. Some \nfundamental algorithms will be discussed to solve basic problems: sorting, searching, \nand a few graph algorithms like BFS and DFS. It will be also explained how the time \nand space complexity of algorithms can be analyzed. \n \nAdditional Information Teaching Methods \nThere will be two lectures and one exercise sessions per week. Attendance is not \nmandatory, but it is strongly recommended. \n \nMethod of Assessment \n",
        "There will be one midterm exam (50%),and one final exam (50%). Roughly speaking, \nthe midterm exam covers the first half of the course and the final exam covers the \nsecond half of the course. Your final grade is simply the sum of the grades you have \nobtained for the two exams. There is no minimum grade requirements for two exams in \norder to pass the course, except that their sum has to be at least 55. \n \nThe resit of the course covers the entire course and it replaces both the midterm exam \nand the final exam. \n \nEntry Requirements \nOfficially speaking, the course does not have any entry requirements, but the \nknowledge of the following topics is strongly advised in order to be able to follow the \ncourse. \n \ncalculus and in particular geometric and arithmetic series, and \ndiscrete mathematics, and in particular mathematical induction. \nLiterature \nIntroduction to Algorithms (3rd edition), by Thomas H. Cormen, Charles, E. Leiserson, \nRonald L. Rivest, and Clifford Stein, MIT Press 2009. \n \nExplanation Canvas \nWe will use Canvas for our communications, posting announcements, publishing \nmaterials of the course (e.g., course slides, weekly exercises, and any other additional \nrelated materials). \n \nRecommended background knowledge \nAs mentioned earlier, a good knowledge in calculus and discrete math is strongly \nadvised in order to be able to follow the course. \n \n",
        "PERVASIVE COMPUTING \nCourse Objective \nWe expect that by the end of this course, students will be able to: \n \nDesign a realistic smart system with the potential to benefit human lives. The system \nacquires and processes audio and video data and uses pattern recognition to make \ndecisions that affect the environment accordingly. (Knowledge and understanding) \n(Applying knowledge and understanding) (Making judgments) (Lifelong learning skills) \nBuild a simplified version of this system, based on programmable microcontrollers. \n(Applying knowledge and understanding) (Making judgments) (Lifelong learning skills) \nWork together in a team, collaboratively identifying not only the technical, but also the \nsafety or ethical issues with their designs, and then sharing their challenges and \ndiscoveries through reports, presentations, and in-class demonstrations. (Lifelong \nlearning skills) (Communication) \nCourse Content \nPervasive (or ubiquitous) computing is a trend based on Mark Weiser's vision of \ncomputers available \"always and everywhere\", embedded in everyday life. This course \nis an introduction to pervasive computing systems that assist people in their daily lives. \nThink about a self-driving car, a speech-controlled wheelchair, an automatic insulin \npump for diabetic patients, or a navigation system for visually impaired pedestrians. \n \nThese systems: \n \nsense the context (time, user's location, blood sugar concentration, road scenery, etc), \nrecognize data patterns, reason and make intelligent decisions, and \nact upon the environment, by controlling the wheels or the pump motor, suggesting the \nbest route, or just notifying a caretaker. \nThe main components of such a system are sensors, controllers, and actuators. In this \ncourse, the students will learn different techniques to acquire signals from the \nenvironment, process these raw signals in order to infer context by using machine \nlearning, and to write software agents for control. During the practical sessions, the \nstudents will get experience with these techniques and build their own \nmicrocontroller-based smart system. Programming is done in MATLAB and C++. \n \nGuest lectures, given by researchers working in relevant fields are planned as well. \n \nAdditional Information Teaching Methods \nLectures, mandatory practical sessions. \nMethod of Assessment \n",
        "Compulsory practical assignments and a digital exam in TestVision. The final grade is \ncalculated as Final grade = (0.5*PRAC) + (0.5*EXAM). A pass requires both \ncomponents to be >=5.5. It is possible to resit the exam, but not the practical. \n \nEntry Requirements \nKnowledge of programming in C++ is recommended. \n \nLiterature \nSilvis-Cividjian, N. (2017), Pervasive Computing - Engineering Smart Systems, Springer \nInternational Publishing, ISBN 978-3-319-51654-7 \n \nExplanation Canvas \nAll materials can be found in Canvas. \n \n",
        "WEB TECHNOLOGY \nCourse Objective \nEveryone uses the Web, but how was it originally built, how has it evolved to what it is \nnow, and how might it further develop in the future? The objectives of this course are to \nenable the student to formulate answers to these questions. While the course is \nprimarily focused on technological aspects, as a professional in academia or industry, \nyou need to be able to relate technological developments on the Web to relevant trends \nin science and society in general. \n \nAt the end of the course, students will be able to: \n \nKnowledge and understanding: Understand, on an introductory level, the key ideas, \nlanguages, and protocols underlying the Web. \nApplying knowledge and understanding: Be able to apply this knowledge by designing \nand implementing a basic Web application. \nMaking judgements: Be able to validate and reflect on the impact of technical design \ndecisions on the functionality and usability in a Web context. \nCourse Content \nThe lectures and online materials teach you the key ideas languages and protocols \nunderlying the Web. These ideas include separation of concerns in terms of content \nversus style and client versus server, and the notion of device independence. Important \nWeb languages and protocols include URI, HTTP, HTML, CSS, and JavaScript. By \nparticipating in the practical sessions and by making the assignments, you will develop \nthe skills you need to apply these techniques to create basic Web content yourself and \nto systematically validate and assess more advanced Web content made by yourself \nand others. The course will teach you the basic building blocks of the Web as it is today, \nand understanding how they are related will also help you understand future \ndevelopments. During the course, you will: \n \ncreate your own HTML content and formally validate it on syntactical correctness \ncreate your own CSS style sheets to render the same HTML content differently on \ndifferent devices \napply JavaScript code made by yourself or others and use it to enrich the interactive \nbehavior of your own Web content, and learn how to debug such applications \nbuild a Web server with a RESTfull HTTP API \nwrite a technical report in which you evaluate your own website on international \naccessibility criteria and reflex on your previous assignments. \nAdditional Information Teaching Methods \n",
        "Lectures (4x2 hours p/week), Practical sessions (2x4 hours p/week, attendance \nmandatory), homework (preparation lectures, preparation practical sessions, making \nassignments, preparing the exam) (26 hours p/week). \n \nMethod of Assessment \nThe final grade is determined from the following components: \n \nIndividual exam counts for 30%. \nThree or four (group) assignments count for 60% (4x15% or 3x20%). \nMaking the exercises in the online textbook counts for 10%. \nTo pass the course both the final grade and the individual exam need to be equal or \nabove 5.5. \n \nThere will be a resit for the individual exam only. \n \nLiterature \nProvided online via ZyBook & Canvas. \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nCustom Course Registration \nRegistration is compulsory at least 4 weeks before the course starts. \nGroup enrolment takes place in Canvas. \nExplanation Canvas \nFurther information for this course will be made available online (Canvas). All students \nmust be enrolled in the course Canvas community. \n \nRecommended background knowledge \nAn introductory programming course, being able to use a command line interface such \nas bash or Powershell. \n \n",
        "COMPUTER ORGANIZATION \nCourse Objective \nExplain the basic concepts, historical objectives, and modern functions of digital \ncomputers. (Knowledge and understanding) \nDescribe the basic architecture and operation of digital computers. (Knowledge and \nunderstanding) \nUse proficiently binary data representation, number representation, and arithmetic and \ndata conversion. (Knowledge and understanding) (Applying knowledge and \nunderstanding) \nExplain at a proficient level the architecture and operation of each of the main \ncomponents of a digital computer: the basic processing unit, the hierarchical memory \nsystem, the I/O system, and the interconnectionsystem. (Knowledge and \nunderstanding) (Communication) \nExplain at a basic level various system mechanisms for building faster single-node \nsystems, such as pipelining and caching, and large-scale systems. (Knowledge and \nunderstanding) (Communication) \nDemonstrate proficiency in implementing basic operations of digital computers in \nrealistic scenarios. (Knowledge and understanding) (Applying knowledge and \nunderstanding) (Lifelong learning skills) \nAnalyze at a basic level the tradeoffs inherent to the design of digital computers, \nconcerning among others performance (simple modeling), scalability (Amdahl's Law), \navailability, energy consumption, and cost. (Applying knowledge and understanding) \n(Making judgements) (Lifelong learning skills) \nCourse Content \nComputers are everywhere, in industry, academia, governance, and many other \nactivities that impact our society. But what are they? How do they work? Why do they \ncurrently work the way they do? How to analyze them and to improve their \nperformance? \n \nMatching the requirements of the IEEE/ACM CS Curriculum, topics for this course \ninclude: the architecture, the structure, the operation, and the interconnection of \ncomputer components into computer systems, including modern architectures, data \nrepresentation, assembler programming, virtual machines, the structure of translators, \ncompiling and loading, basic operating systems concepts (I/O, interrupt handling, \nprocess). \n \nAdditional Information Teaching Methods \nLectures 4h/week. \nTutorial (Instructie) 2h/week. \nPractical work (Lab) 4h/week, from week 3. \n",
        "Self-study in teams. \nThis course uses dr. Iosup's method for gamification. \nMethod of Assessment \n(Mandatory) basic lab assignments. (Turn in to SAs) \n(Mandatory) final exam, written, multiple-choice. \n(Optional) in-class exercises, oral and written. \n(Optional) mid-term exam, written, multiple-choice. The results of the mid-term exam \ncount only if the final exam is also taken by the student, and only if it increases the final \ngrade of the student. \n(Optional) self-study booklet and exam pack. (Turn in to TA) \n(Optional) advanced lab assignments. (Turn in to SAs) \nAll partial results (including the lab, and the mid-term and final exams) are only valid \nduring one academic year. \nThe end grade is the total number of points accumulated across all assessment \npossibilities scored divided by 1000. \nIt is possible to score a perfect 10 as the final grade. \n \nThe different course activities are graded as follows: \n \nExam, multiple-choice questions (max 7,500 points) \nSelf-study assignments, including exam preparation (max 2,000 points) \nLab assignments (max 4,000 points) \nIn-class activity (max 50 points per session) \nVarious bonus activities. \nStudents do not have to complete every course activity but are free to choose their own \npath of advancement. \n \nThere is only one resit opportunity for the exam. \n \nLiterature \nBooks (students can pick any): \n \nCarl Hamacher and Zvonko Vranesic, Computer Organization, 6th edition, McGraw-Hill \nEducation, 2011. ISBN-13: 978-0073380650 \nDavid A. Patterson and John L. Hennessy, Computer Organization and Design: The \nHardware/Software Interface, 5th edition, Morgan Kaufmann, 2013. ISBN-13: \n978-0124077263 \nAdditional Study Materials: \n \nCourse and Lab guides are also provided via Canvas. \n",
        "Additional Information Target Audience \nBachelor Computer Science ( ). \nBachelor Mathematics ( ) \nCustom Course Registration \nThe course includes two types of group activities: lab and self-study. \n \nGroup enrolment takes place in Canvas. In the past few years, students could choose to \nattend lab sessions on one of two separate days. Choices are made available at the \nstart of the course. \n \nRecommended background knowledge \nMathematics students should have taken at least one prior course in computer \nprogramming. \n \n",
        "REQUIREMENTS ENGINEERING \nCourse Objective \nIn this course, you will learn about requirements engineering practices. for eliciting, \ndocumenting, and managing requirements (Knowledge and understanding). \n \nThrough theory and hands-on exercises, you will gain insights into how these practices \ncan be applied during software development (Applying knowledge and understanding). \n \nAdditionally, you will learn about different software lifecycle models and how \nrequirements engineering activities fit into these models. \n \n(Knowledge and understanding) (Applying knowledge and understanding) \n \nAfter following the course, you will be able to reason and make decisions about \nadequate requirements engineering elicitation, documentation, and management \ntechniques taking into consideration specific software project characteristics (Making \njudgements). \n \nAdditionally, you will be able to apply these techniques in concrete project examples. \n(Applying knowledge and understanding) (Lifelong learning skills) \n \nCourse Content \nA good requirements specification is critical for software project success. This course \ngives an introduction to processes, methods, and representation forms for specifying \nand managing requirements. It also gives an overview of the whole software \ndevelopment lifecycle. \n \nTopics include requirements elicitation, analysis, modeling, and validation. Current \nresearch topics such as continuous user participation and requirements mining will also \nbe covered. Part of the course entails assignments performed in groups and individual \nnon-graded exercises. \n \nAdditional Information Teaching Methods \nThe course will be composed of theoretical lectures and practical lectures in which \nindividual exercises will be solved by students and discussed. \nMethod of Assessment \nAssignments (group): 70% \nFinal written exam (individual): 30% \nQuizzes (individual): pass/fail \n \n",
        "There is a resit for the final written exam. There are no resits for any of the graded \nassignments or quizzes. \n \nNote: should the lecture be given partially online, the assignments will count for a 100% \nof the grade and the final written exam will be in apass-fail modality. \n \nLiterature \nSelected chapters (to be announced in lecture) of the following books: \n \nMandatory (We will only read specific chapters from this book; please, wait for the first \nlecture to decide if you should buy the book): \n \nRequirements Engineering, Axel van Lamsweerde, Wiley, 2009. \nSelected chapters of the following books (available in Canvas): \n \nKarl Wiegers and Joy Beatty\u2028, Software Requirements, Microsoft Press, 2013. \nMartina Seidl, Marion Scholz, Christian Huemer, Gerti Kappel, UML@Classroom: An \nIntroduction to Object-Oriented Modeling, Springer, 2015. \nBernd Br\u00fcgge and Allen H. Dutoit, Object-Oriented Software Engineering, Pearson, \n2010. \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nRecommended background knowledge \nBasic programming experience. Some knowledge about the software lifecycle is of \nadvantage. \n \n",
        "COMPUTER NETWORKS \nCourse Objective \nAfter successfully completing the Computer Networks course, you are able to: \n \nExplain the basic principles and modern functions of computer networks and data \ncommunication. (Knowledge and understanding) \nDescribe the layered network architecture and explain the essential function(s) in these \nlayers. (Knowledge and understanding) \nApply basic physics, theorems from information theory, and network protocol properties \nto calculate network properties such as maximum bit rate, minimum round-trip latency, \nwindow size, etc. (Applying knowledge and understanding) \nApply networking mechanisms and algorithms to detect and correct transmission errors, \ncompute routing tables, set window sizes, etc. (Applying knowledge and understanding) \nExplain the concept of Quality of Service, why different applications have different \nnetworking requirements, and how these requirements translate to network and protocol \nproperties. (Knowledge and understanding) (MakingJudgements) \nExplain issues related to performance and scalability in today's popular networking \nprotocols. (Knowledge and understanding) (Making Judgements) \nDemonstrate proficiency in socket programming by implementing basic networked \napplications. (Knowledge and understanding) (Applying knowledge and understanding) \nCourse Content \nThe emphasis in this course is on fundamental concepts in digital communication. In \nmodern computer networks, data communication takes place by sending data from A to \nB via a layered architecture where each. layer implements a different abstraction. The \nhigher layers are responsible for handling web pages, emails, and similar things, that \nare translated into packets, bits, and eventually digital signals on physical links (e.g., \nlight pulses, electrical signals in copper wires, radio waves). \n \nThis layered architecture with increasing levels of abstraction and separation of \nconcerns, is a fundamental approach that you will encounter in all aspects of computer \nscience (and beyond). Within this architecture, we will concern ourselves with questions \nlike: what route should the data follow through the network, what do we do when errors \noccur, how do we interconnect two networks that have completely different properties, \netc. \n \nFollowing the IEEE/ACM Computer Science curriculum, topics to be discussed include \nthe layered network architecture, different types of networks (e.g., wired and wireless, \nLAN and WAN), multiplexing, error control, flow control, routing and forwarding, names \nand addresses, high-level architectures of networked applications (peer-to-peer, \nclient/server, etc), performance issues, and scalability issues. These issues are \n",
        "discussed while exploring the technology behind the Internet and its popular protocols \n(e.g., TCP, UDP, Ethernet, Wifi, etc.). \n \nAdditional Information Teaching Methods \nLectures, labs, and tutorials. This course is gamified. \nMethod of Assessment \n(Mandatory) Basic lab assignments. (Turn in to SAs) \n(Mandatory) Final exam, multiple-choice. \n(Optional) Mid-term, multiple choice. The results of the mid-term exam count only if the \nfinal exam is also taken by the student, and only if it increases the final grade of the \nstudent. \n(Optional) Optional lab assignments. (Turn in to SAs) \n(Optional) Self-study assignment. (Turn in to TAs) \n(Optional) In-class exercises, oral and written. \n \nAll partial results (including the lab, and the mid-term and final exams) are only valid \nduring one academic year. \nThe end grade is the total number of points accumulated across all assessment \npossibilities scored divided by 1000. \nIt is possible to score a perfect 10 as the final grade. \n \nThe different course activities are graded as follows: \n \nExam, multiple-choice questions (max 7,500 points) \nSelf-study assignments (max 2,000 points) \nLab assignments (max 4,000 points) \nIn-class activity (max 50 points per session) \nThere is only a resit opportunity for the exam. \n \nLiterature \nAndrew S. Tanenbaum and David Wetherall, Computer Networks, 5th or 6th ed. \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nAdditional Information \nCurrent information can be found on Canvas: canvas.vu.nl \nRecommended background knowledge \nUniversity-level programming course. \nBasic knowledge of the Python programming language. \n \n",
        "DISCRETE MATH AND CALCULUS \nCourse Objective \nThe student knows basic concepts from graph theory and can solve problems about \nand with those in explicit situations. (Knowledge and understanding) (Applying \nknowledge and understanding) \nThe student knows basic theorems and algorithms from graph theory and can use these \nto compute and/or prove certain properties in explicit situations. (Knowledge and \nunderstanding) (Applying knowledge and understanding) \nThe student knows basic concepts from combinatorics and can solve problems about \nand with those in explicit situations. (Knowledge and understanding) (Applying \nknowledge and understanding) \nThe student knows basic theorems and techniques from combinatorics and can use \nthese to compute and/or prove certain properties in explicit situations. (Knowledge and \nunderstanding) (Applying knowledge and understanding) \nThe student knows basic concepts from calculus and can solve problems about and \nwith those in explicit situations. (Knowledge and understanding) (Applying knowledge \nand understanding) \nCourse Content \nThis course is about three subjects: graph theory, combinatorics and calculus. \n \nAdditional Information Teaching Methods \nLectures and tutorials. \n \nMethod of Assessment \nWritten exam. \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \n \n",
        "SYSTEMS PROGRAMMING PROJECT \nCourse Objective \nStudents learn to apply programming concepts in the context of a larger, individual project. After \ncompleting the course, students will be able to plan, develop, and test larger programs for \ncorrect behavior according to a given specification. (Knowledge and understadning) (Applying \nknowledge and understanding) (Making Judgements) \n \nCourse Content \nIn this course, you will implement an emulator capable of executing IJVM byte-code. The \nimplementation will be done in C. The assignment is split into several smaller parts that build up \nto the final deliverable. \n \nAdditional Information Teaching Methods \nOne introductory lecture in the first week. 4 weeks of practical work. \n \nMethod of Assessment \nThe student\u2019s knowledge will be assessed by means of a practical programming assignment \nand an oral evaluation. \n \nBoth the practical assignment and the oral evaluation require a passing grade. The final grade \nconsists of 100% of the grade of the practical programming assignment. The oral evaluation is \ngraded with pass/ fail. \n \nThere will be no resits for either of the assessments. \n \nLiterature \nThe course syllabus. \nExtra (optional) reading: \nRitchie, D. M., Kernighan, B. W., & Lesk, M. E. (1988). The C programming language. \nEnglewood Cliffs: Prentice Hall. \nAndrew, S. Tanenbuam. \"Structured Computer Organization\". Prentice-Hall, Inc. New Jersey \n(1999). \nRecommended background knowledge \nThis course is a Programming practical so we expect you to be proficient at the level of \nComputer Programming (XB_40011). A good grasp of systems architecture is also \nrecommended.\n \n",
        "OBJECT-ORIENTED AND FUNCTIONAL PROGRAMMING \nCourse Objective \nThe goal of this course is to obtain familiarity and experience with advanced programming \nlanguage concepts, such as inheritance and pattern matching, as well as improving general \nprogramming skills. \n \nAfter taking this course, you will be able to: \n \nUnderstand & apply concepts from object-oriented programming such as subtyping and \ninheritance. (Knowledge and understanding) (Applying knowledge and understanding) \nUnderstand & apply concepts from functional programming such as pattern matching and \nhigher-order functions. (Knowledge and understanding) (Applying knowledge and \nunderstanding) \nDesign and implement a moderately large program from scratch. (Applying knowledge and \nunderstanding) (Making judgements) \nProduce clear, readable code. (Applying knowledge and understanding) (Making judgements) \n(Lifelong learning skills) \nCourse Content \nThe lectures cover various programming concepts from Object-oriented and Functional \nprogramming and how they occur in various programming languages. These topics include \ninheritance, subtyping, parametric polymorphism, side effects, higher-order functions, and \npattern matching. The lectures also cover how to produce clear, readable code. \n \nWe will use the programming language Scala, as it supports a wide array of programming \ntechniques. \n \nThere are several individual programming exercises that offer practice with writing programs \nwith the concepts discussed in the lectures. These give the students experience with designing \nand implementing moderately large programs from scratch, train the students in producing clear, \nreadable code, and provide an opportunity to use the advanced concepts from the lectures. \n \nThere are also several multiple-choice exercises that offer practice with reading programs that \ninvolve the concepts discussed in the lectures. These typically present a small program, with \naccompanying multiple-choice questions such as what is the output of this program, what is the \ntype of certain function, what type of error is present, etc? These programs help with \nunderstanding the details of how the program concepts work. Such questions will be presented \non canvas and in the lectures. The exam is a digital multiple-choice proctored exam taken at the \nVU which mainly presents these types of questions. \n \nAdditional Information Teaching Methods \nLectures: 4 hours per week (in total 28 hours). Practical sessions: 4 hours per week (in total 28 \nhours). \nMethod of Assessment \nWritten exam (40% of grade) and programming exercises (60% of grade). \n",
        " \nBoth grades have to be at least 5.5. There is no resit opportunity for the programming exercises. \n \nEntry Requirements \nComputer Programming (XB_40011) or Systems Programming Project (XB_0123) (formerly \nknown as Computer Programming Project (X_400556)). \n \nLiterature \nMaterials will be provided through Canvas. \nAdditional Information Target Audience \nBachelor Computer Science ( ) \n \n",
        "STATISTICAL METHODS \nCourse Objective \nAfter this course, the student should be able to: \n \nunderstand the setup of a probability space, events, probability, and conditional probability; \n(Knowledge and understanding) \nuse the basic rules of probability theory (sum rule, product rule, law of total probability, Bayes' \nrule); (Applying knowledge and understanding) \nunderstand what a random variable is, and what its distribution is, both for discrete and \ncontinuous random variables (this includes the concepts of probability mass function, probability \ndensity function, and cumulative distribution function); (Knowledge and understanding) \ncompute the expectation and variance of a random variable; (Applying knowledge and \nunderstanding) \ncompute the mean and variance of a sum of independent random variables; (Applying \nknowledge and understanding) \nderive discrete probability distributions for probabilistic experiments associated with the \nBernoulli, Binomial, Negative Binomial, and Poisson distributions; (Applying knowledge and \nunderstanding) \ncompute probabilities for continuous random variables, specifically the uniform, exponential, and \nnormal distribution; (Applying knowledge and understanding) \ndo calculations based on the law of large numbers and central limit theorem; (Applying \nknowledge and understanding) \nreproduce the definition of an estimator, do elementary computations on point estimators; \n(Applying knowledge and understanding) \nunderstand what a confidence interval is and derive it in simple settings using a pivot; \n(Knowledge and understanding) (Applying knowledge and understanding) \nunderstand the setup of classical hypothesis testing (critical region, p-value, type of errors) and \napply this to simple hypothesis testing problems; (Knowledge and understanding) \nderive the likelihood ratio test in simple settings; (Applying knowledge and understanding) \nget basic knowledge of the statistical software package R; (Knowledge and understanding) \napply concepts introduced in the course in 2 assignments which are to be implemented using \nthe statistical software package R. (Applying knowledge and understanding) \nCourse Content \nFrom the book by From Pishro-Nik: \n \nChapter 1: Basic concepts \nChapter 3: Discrete random variables, Bernoulli, Binomial, Negative Binomial, Poisson \nChapter 4: Continuous random variables; sections 4.0, 4.1 and from 4.2 uniform, exponential \nand normal random variables \nChapter 7: Law of large numbers and central limit theorem; sections 7.0 and 7.1 \nChapter 8: Classical statistics (point estimation, interval estimation, hypothesis testing); sections \n8.1, 8.2, 8.3 and 8.4 \nAdditional Information Teaching Methods \n",
        "6 weeks with 4 hours lecturing each week. Exercise classes. Two R assignments, to be done in \ngroups of 2. \n \nAttendance to lectures and classes is not mandatory but strongly recommended. \n \nMethod of Assessment \nThe exam counts for 80%. Each of the assignments counts for 10%. To pass the course, the \n(unrounded) grade of the exam needs to be at least 5. \n \nEntry Requirements \nCalculus (functions, differentiation and integration) and elementary set theory. \n \nLiterature \nHossein Pishro-Nik, Introduction to Probability, Statistics and Random Processes. \n \nThe book can be ordered but is also freely available on www.probabilitycourse.com. \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \n \n",
        "NETWORKS AND GRAPHS \nCourse Objective \nAfter taking this course, student will be able to formally reason about graphs and use them to \nsolve fundamental computational tasks. \n \nThe course introduces basics of graph theory and graph algorithms. In particular, you will be \nable to: \n \nMathematically analyze basic properties of graphs \nApply graph algorithms in computational tasks such as shortest paths and spanning trees \nAnalyze performance of such algorithmic tasks \nLearning goals: \n \nG1: Learning basic concepts in graph theory. (Knowledge and understanding) \nG2: Learning and reasoning about graphs and their properties (Knowledge and understanding) \nG3: Familiarity with standard graph algorithms (Knowledge and understanding) \nG4: Analyze performance and correctness of different algorithms (Knowledge and \nunderstanding) (Making judgements) \nG5: Applying fundamental graph algorithms for solving computational tasks (Applying \nknowledge and understanding) (Communication) \nG6: Developing problem solving skills by using algorithmic techniques such as dynamic \nprogramming and greedy (Applying knowledge and understanding) \n \nCourse Content \nMany real world problem involve interactions on a network, which is mathematically represented \nby \"graphs\". Graphs are fundamental objects appearing many computational tasks all across \ncomputer science (e.g. computer networks, data analysis, databases, machine learning, etc). \nThis course focuses on graph theory, graph algorithms, and their applications. We reason about \ngraphs mathematically and along the way develop further skills to formally analyze algorithms. \n \nThe topics include basic concepts and techniques in graph theory and graph algorithms: \n \nIntro to discrete math and review of proof techniques \nGraph theory concepts \nDirected graphs \nImportant graph classes (bipartite graphs, Eulerian graphs, Hamiltonian graphs, random graphs) \nConnectivity \nShortest path algorithms \nMinimum spanning tree algorithms \nCuts and flows \nAdditional Information Teaching Methods \nThere are two main lectures (at VU campus) per week. Moreover, there is one exercise class \nper week. Attendance is not mandatory but bonus points will be given based on active \nparticipation in exercise classes. \n",
        " \nMethod of Assessment \nThe final grade is determined by two written exams: The midterm and the final exam. The \nmidterm accounts for 40 percent and the final exam accounts for 60 percent of the grade. Active \nparticipation in interactive exercise sessions will result in a bonus of up to %5 of the total grade. \nIn these sessions students will work in groups to solve problems. \n \nLiterature \nLecture slides will be provided and textbook is not required, however the following textbooks are \nrecommended: \n \nGraph Theory, by J. A. Bondy , U. S. R. Murty (Hardcover ISBN: 978-1-84628-969-9) [available \nonline at VU library] \n \nIntroduction to Algorithms, Fourth Edition, by Thomas H. Cormen, Charles E. Leiserson, Ronald \nL. Rivest and Clifford Stein (ISBN: 978-0262046305) \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \n \nRecommended background knowledge \nData Structures and Algorithms, Logic and Sets, Statistical methods. \n \n",
        "OPERATING SYSTEMS \nCourse Objective \nGet insight into the internals of modern operating systems. Both theory (architecture, design \nprinciples, interfaces, etc.) and practice (operating system implementation aspects, user-level \nsystems programming in C, etc.). \n \nUpon completion of this course, you will: \n \nhave a basic understanding of the operating systems design and implementation principles \nadopted by mainstream operating systems such as Linux (K&U) \nhave knowledge of key operating systems concepts, including: history and evolution of \noperating systems, core operating systems abstractions, system calls, virtualisation, basic and \nadvanced operating systems architectures (K&U, AK&U, LS) \nhave knowledge of process management principles (K&U, AK&U, MJ) \nhave knowledge of memory management principles (K&U, AK&U, MJ) \nhave knowledge of file systems principles (K&U, AK&U, MJ) \nhave knowledge of input/output principles (K&U, AK&U, MJ) \nhave knowledge of concurrency principles (K&U, AK&U, MJ) \nThe acronyms above refer to the Dublin Descriptors covered by each learning objective, \nspecifically: \n \nKnowledge and Understanding (K&U), \nApplied Knowledge and Understanding (AK&U), \nMaking Judgment (MJ), \nLearning Skills (LS), and \nCommunication (C). \nCourse Content \nThis course gives an introduction to the internals of operating systems. The following topics are \ncovered: operating system architectures, processes, threads, synchronisation, memory \nmanagement, file systems, input/output, and virtualisation. \n \nThe course uses real-world operating systems such as Linux and MINIX 3 as examples, \nproviding insights into both the theory and practice of modern operating systems. \n \nAdditional Information Teaching Methods \nLectures and practicals. \nMethod of Assessment \nWritten exam on the material covered in lectures and four individual programming assignments \nin C. The final grade is the weighted average of the exam grade (50%) and the assignments \n(50%). \n \nTo pass the course, the exam grade must be at least 5.5, each assignment grade must be at \nleast 4.0, and the final grade must be at least 5.5. There is no resit opportunity for the \nprogramming assignments. \n",
        " \nEntry Requirements \nXB_40011 Computer Programming or XB_0123 Systems Programming Project (formerly known \nas X_400556 Computer Programming Project) . \n \nLiterature \nTanenbaum, A.S., Bos, H.J., \"Modern Operating Systems\", Fifth edition, Pearson. \n \nhttps://www.pearson.com/en-us/subject-catalog/p/modern-operating-systems/P200000003295/9\n780137618880 \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nRecommended background knowledge \nGood programming skills. \n \n",
        "HISTORY OF SCIENCE FOR CS \nCourse Objective \nStudents acquire knowledge and understanding about the history of computing from various \nperspectives: computing as a scientific goal, computing as a government (administrative or \nmilitary) objective / ideal, computing as an economic enterprise (Knowledge and \nunderstanding). \n \nStudents can apply that knowledge and understanding to describe the meanings digital culture \nhas or may have for various people in contemporary society (Applying knowledge and \nunderstanding). \n \nStudents are able to communicate their knowledge and understanding in an effective way, and \nfrom various perspectives - thereby they will be better equipped to reflect on their subject of \nstudy (Communication) (Making judgements) \n \nCourse Content \nVarious subjects from the history of computing will be treated. Several highlights will be \ndiscussed and placed within the social context of its time. By discussing these highlights from \nseveral points of view the history of computing will serve as a way to illustrate the various roles \nof computing in society. \n \nAdditional Information Teaching Methods \nLectures and short assignments. Workgroup sessions. Optional quizzes helping to study; \nextracurricular activities for more in-depth info. \nMethod of Assessment \nWritten exam; assignments yield a bonus of 1 point if all three assignments are graded and the \naverage score is 6 or better. \n \nLiterature \nThomas Haigh and Paul Ceruzzi, A new history of modern computing, MIT (2021) \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nAdditional Information \nMore information with the course coordinator: W&N room A652, d.j.beckers@vu.nl. \n \nExplanation Canvas \nAll info about the course is available through Canvas. The \"Modules\" page offers a \nchronological overview of the lectures, indicating when to prepare what, and optional extras. \n \n \n",
        "LINEAR ALGEBRA \nCourse Objective \nAll that's below falls under: \n \nKnowledge and understanding \nApplying knowledge and understanding \nMaking judgements \nCommunication \nLifelong learning skills (since Linear Algebra appears in all of science and industry) \nBesides being able to explain, interrelate, know the basic properties of, and construct simple \narguments with the concepts listed above, the student will learn the following skills (organized \nby topic): \n \nLinear systems: \n \nCan solve systems of linear equations using row-reduction \nCan determine the number of solutions of a linear system \nCan prove or disprove simple statements concerning linear systems \nLinear transformations: \n \nCan determine if a linear transformation is one-to-one and onto \nCan compute the standard matrix of a linear transformation \nCan use row-reduction to compute the inverse of a matrix \nCan prove or disprove simple statements concerning linear transformations \nSubspaces and bases: \n \nCan compute bases for the row and column space of a matrix \nCan compute the dimension and determine the basis of a subspace \nCan prove or disprove simple statements concerning linear systems \nEigenvalues and eigenvectors: \n \nCan compute the eigenvalues of a matrix using the characteristic equation \nCan compute bases for the eigenspaces of a matrix \nCan diagonalize a matrix \nCan prove or disprove simple statements concerning eigenvalues and eigenvectors \nOrthogonality: \n \nCan compute the orthogonal projection onto a subspace \nCan determine an orthonormal basis for a subspace using the Gramm-Schmidt algorithm \nCan solve least-squares problems using an orthogonal projection \nCan orthogonally diagonalize a symmetric matrix \nCan compute a singular value decomposition of a matrix \nCan prove or disprove simple statements concerning orthogonality \nCourse Content \n",
        "The topics that will be treated are listed below. For every topic, the relevant concepts are listed. \n \nLinear systems: \n \nlinear system (consistent/inconsistent/homogeneous/inhomogeneous), (augmented) coefficient \nmatrix, row equivalence, pivot position/column, (reduced) echelon form, basic/free variable, \nspanning set, parametric vector form, linear (in)dependence. \n \nLinear transformations: \n \nlinear transformation, (co)domain, range and image, standard matrix, one-to-one and onto, \nsingularity, determinant, elementary matrices. \n \nSubspaces and bases: \n \nsubspace, column and null space, basis, coordinate system, dimension, rank. \n \nEigenvalues and eigenvectors: \n \neigenvalue, eigenvector, eigenspace, characteristic equation/polynomial, algebraic multiplicity, \nsimilarity, diagonalization and diagonalizability. \n \nOrthogonality: \n \ndot product, norm, distance, orthogonality, orthogonal complement, orthogonal set/basis, \northogonal projection, orthonormality, orthonormal basis, Gramm-Schmidt process, least \nsquares problem/solution, orthogonal diagonalization, singular value/vector, singular value \ndecomposition, Moore-Penrose inverse. \n \nAdditional Information Teaching Methods \nThe course is spread over a period of seven weeks. Each week there will be two theoretical \nclasses of 90 minutes each and two exercise classes of 90 minutes each. \nMethod of Assessment \nThere is a written exam at the end of the course. \nLiterature \nLinear Algebra and its Applications, by David C. Lay, Steven R. Lay and Judi J. McDonald, \nglobal edition (sixth edition), Pearson or other material provided in the course. \n \nAdditional Information Target Audience \nBachelor Artificial Intelligence ( ) \nBachelor Computer Science ( ) \n \n",
        "SOFTWARE DESIGN \nCourse Objective \nThe main objective of the course is to let you master model-based design methodologies and \ntechniques, obtain insights and knowledge about recurrent software design problems and object \norientation. (Knowledge and understanding) \n \nIn addition, you will develop critical reasoning skills: for a given software problem, you will be \nable to select and apply design principles and the most appropriate object-oriented design \npatterns. (Making judgements) (Applying knowledge and understanding) (Lifelong learning \nskills) \n \nCourse Content \nDeveloping real software systems is complex; they are large, and their development often starts \nwhen their requirements are still not fully specified. The goal of software design is to model \ncomplexsoftware systems in a systematic manner. The lectures will cover and apply a number \nof software modeling techniques and principles. You will learn which technique is the most \nappropriate for which problem, how to describe a (software) problem using models, and how to \nuse such models to reason about and communicate key aspects of your software. \n \nThe course also introduces several design patterns for creating robust, better-organized, and \nmaintainable software systems. Design patterns can be considered as standardized blueprints \nfor solving recurrent design problems regarding object-oriented software systems. \n \nThe course makes use of the Unified Modelling Language (UML). \n \nAdditional Information Teaching Methods \nLectures (H). Practical sessions (W). \n \nMethod of Assessment \nIn this course the assessment is composed of two components: \n \n- Team project (70% of the final grade): it will be carried out throughout the whole course by \ngroups of students; the required methods and principles for the project will be covered during \nthe lectures and laboratory sessions throughout the whole duration of the course. \n \nThe result of the team project is composed of two parts: (i) a modelling part, and (ii) an \nimplementation part. \n \nBoth the modeling and implementation parts will be evaluated by the teaching team according to \na shared assessment rubric. Within the team project, each of you will be responsible for a \ncertain part of the project; as a team, you will report the responsibilities that each team member \ntook in the project. \n \n",
        "- Written exam (30% of the final grade): it consists of a set of multiple-choice questions. The \nexam aims to assess your understanding and knowledge of the methods, principles, and \npractical insights discussed in the lectures. \n \nLiterature \nMartina Seidl, Marion Scholz, Christian Huemer, Gerti Kappel, \"UML@Classroom: An \nIntroduction to Object-Oriented Modeling\", 2015. \nJohn Ousterhout, \u201cA philosophy of software design\u201d, Yaknyam Press, 2018. \nMartin P. Robillard, \u201cIntroduction to Software Design with Java\u201d, Springer, 2019. \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nRecommended background knowledge \nObject-oriented principles in any programming language (for instance in Scala, Java, C/C++, \nPython). \n \n",
        "DATABASES \nCourse Objective \nThe students will learn: \n \nto design and evaluate database schemas using Entity-Relationship diagrams, (Applying \nknowledge and understanding) (Making judgements) \nto understand the relational model (including integrity constraints such as key constraints and \nforeign key constraints), (Knowledge and understanding) \nto translate Entity-Relationship diagrams into relational schemas (and to enforce cardinality \nconstraints by design), (Applying knowledge and understanding) \nto reason about good and bad database design using functional dependencies, (Making \njudgements) \nto apply normalization algorithms to transform a database schema into (various) normal forms, \n(Applying knowledge and understanding) \nto understand concurrency concepts like transactions, schedules and concurrency anomalies, \nand (Knowledge and understanding) \nto reason about different techniques for concurrency control (lock based concurrency control, \noptimistic concurrency control, multiversion concurrency control). (Making judgements) \nCourse Content \nThe course is concerned with base principles and important aspects of relational databases. \nThe course objective is to obtain a good knowledge and understanding of relational database \nsystems. This includes the ability to develop good database models, and to query and update \ndatabases using SQL. \n \nAdditional Information Teaching Methods \nLectures, exercise/practicum classes and individual homework. \nMethod of Assessment \nThe homework is mandatory for qualifying for the exam (70% of the homework points to qualify \nfor the exam). In the case that at least 90% of the homework points are obtained, 0.5 bonus \npoints are awarded for the final grade. At the end of the course, there is a final exam. \nThe overall grade is the grade of the final exam plus the possibly 0.5 bonus point obtained for \nthe homework. (The bonus is only added for students who pass the exam with a grade of at \nleast 5.5.) \n \nThere is no resit opportunity for the homework. \n \nLiterature \nDatabase Systems, The Complete Book, by: Hector Garcia-Molina & Jeffrey D. Ullman & \nJennifer Widom. 2nd edition. \n \nAdditional Information Target Audience \nBachelor Artificial Intelligence ( ) \nBachelor Business Analytics ( ) \nBachelor Computer Science ( ) \n",
        "Recommended background knowledge \nBasic programming skills help.\n \n",
        "ACADEMIC WRITING FOR CS \nCourse Objective \nThe aim of this course is to improve your academic writing skills. More specifically, you will: \n \ngain insight into the specific characteristics of formal written English (knowledge and \nunderstanding); \nlearn the conventions of using sources through quoting, referring and paraphrasing; (Knowledge \nand understanding) (Communication) (Lifelong learning skills) \ndevelop your academic skills with regard to text structure, linguistic accuracy, and clarity of \nexpression. (Knowledge and understanding) (Communication) (Lifelong learning skills) \nIn addition, you will be able to apply this knowledge by writing a text about an academic topic, \nwhich uses academic sources appropriately; has no major grammatical errors; uses a clear text \nstructure; and has a style which is suitable for academic texts. (Applying knowledge and \nunderstanding) (Communication) (Making judgements) (Lifelong learning skills) \n \nCourse Content \nIn the course, we will focus on generic skills that are relevant for academic writing: creating an \nappropriate formal style and using standard academic phrases and creating a clear structure for \nyour text. You will write a text about a topic from your discipline, based on academic sources, \nusing a referencing style that is standard in your discipline. We will also pay attention to general \nprinciples of good writing, such as guiding the reader through the text and creating a good flow \nin the text. We will address these topics in such a way that you will be able to apply these \nprinciples in any text that you write after following the course. \n \nIn addition, you will get individual feedback on your own texts, which will allow you to gain \ninsight into your own strengths and weaknesses in terms of linguistic accuracy (grammar, \npunctuation, spelling and vocabulary). \n \nAdditional Information Teaching Methods \nLectures and seminars. \nMethod of Assessment \nSeveral short assignments (required; pass/fail) and a final paper (required; pass/fail). \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \nAdditional Information \nThis course has obligatory attendance (80% of all classes). \nExplanation Canvas \nCourse and reading materials will be made available via Canvas. \n \n",
        "PROFESSIONAL DEVELOPMENT \nCourse Objective \nUpon completion of this course, students will: \n \ndevelop an understanding of a number of different career paths that are available to them in the \neducation sector (knowledge and understanding) \ndevelop an understanding of a number of different career paths that are available to them in the \nindustry (knowledge and understanding) \nbe able to make informed choices when taking the first steps toward the job market (apply \nknowledge and understanding) (critical thinking) (making judgements) \nlearn and be able to apply the main features of technical interviewing (knowledge and \nunderstanding) (apply knowledge and understanding) (making judgements) (Communication) \n(learning skills) \nbe aware of the relevance of ethics, diversity, and inclusion within the professional world of \nComputer Science (apply knowledge and understanding) (critical thinking) (making judgements) \nCourse Content \nDuring this course, students will be exposed to several guest lectures from staff members and \nguests from the industry who will talk about topics relevant to students trying to get a first \nimpression of their options in the labor market. These topics include an overview of possible \ncareer paths in education with a degree in Computer Science, including pursuing a Ph.D. and \nan academic career. Further, there will be guests from the industry, who will talk about \ninternships and different career paths. Technical interviewing will be covered as well. In addition, \nthe course will cover the topics of ethics, diversity, and inclusion in the professional field of \nComputer Science. \n \nAdditional Information Teaching Methods \nGuest lectures. \n \nMethod of Assessment \nIndividual (pass/fail) assignments. \n \nLiterature \nThe course materials will be posted on Canvas. \n \nAdditional Information Target Audience \nThis is a constrained-choice course for the students enrolled in   of the Bachelor Computer \nScience. \n \n",
        "INFORMATION MANAGEMENT FOR CS \nCourse Objective \nThrough this course, students will study the topic of information management in breadth and in \ndepth. After taking this course, the student will be able to: \n \nExplain the strategic relevance of information systems for modern organizations; (Knowledge \nand understanding) (Applying knowledge and understanding) \nAnalyze the level of competition within an industry and determine is implications for an \ninformation systems strategy; (Applying knowledge and understanding) \nUnderstand the impact of the advent of the internet on the management of information within \nand between organizations; (Knowledge and understanding) \nIdentify the various phases in the development of an information system; (Applying knowledge \nand understanding) \nModel simple and moderately complex business processes with a formal modeling technique \n(Petri nets); (Making judgements) (Applying knowledge and understanding) \nAnalyze process models with respect to various behavioral properties. (Lifelong learning skills) \nCourse Content \nNo organization can do without information systems. For some organizations, such systems are \neven of strategic relevance, as they offer a clear competitive advantage. Think, for example, of \nhow Amazon has become such a dominant retailer or how an organization like Uber has \nconquered the taxi market. \n \nThis course explains the relevance and use of information systems in modern organizations. We \nwill briefly sketch how the role of information systems has developed over the years to reach its \ncurrent ubiquitous level. Special attention is devoted to the rise of the internet and its impact on \ntraditional organizations, as well as the emergence of new types of (cloud-based) organizations. \n \nReasoning from the organizational importance of information systems, we will look into the way \ninformation systems are developed such that organizations can achieve their objectives. We will \npay considerable attention to an important phase in information system development, namely \nhow we analyze and model business processes. For this purpose, we will rely on the use of \nclassical Petri nets. \n \nThis course will approach the topic of information management in breadth and in depth. Breadth \nis achieved by giving an overview of all relevant topics in the area of information management; \ndepth is attained by introducing students to a powerful, formal modeling technique that they will \nlearn to master in the context of organizational analysis. \n \nAdditional Information Teaching Methods \nThis course consists of lectures and practicals. Attendance is not mandatory but highly \nencouraged. \nMethod of Assessment \nIntermediate exam (individual, 30%) and final project (group-based, 70%). \n \n",
        "Resit option: resit for intermediate exam, re-submission of the final project. \n \nLiterature \n\"Business Information Management: Improving Performance using Information Systems\", by \nDave Chaffey and Steve Wood. ISBN: 9780273686552. \n\"Modeling Business Processes\", Wil van der Aalst and Christian Stahl. ISBN: 9780262015387 \n(print), 9780262296465 (eBook). \nAdditional Information Target Audience \nBachelor Computer Science ( ) \n \n",
        "LOGIC AND MODELLING \nCourse Objective \nStudents will learn to: \n \nDescribe fundamental principles of user experience and human factors (Knowledge and \nunderstanding) \nDescribe fundamental input and output techniques for human-computer interaction (Knowledge \nand understanding) \nGather requirements for designing interactive systems (Applying knowledge and understanding) \nApply prototyping methods for interactive systems (Applying knowledge and understanding) \nEvaluate interactive systems (Making judgements) \nValidate empirical evaluations of interactive systems (Making judgements, Applying knowledge \nand understanding) \nCommunicate design solutions and evaluations on an academic level (Communication) \nWork in teams to achieve a common goal (Communication) (Lifelong learning skills) \nCourse Content \nThe lectures in this course will discuss and present examples of concepts and methods in the \nfield of human-computer interaction. It will cover in detail all steps in the human-centered design \nlifecycle; We will discuss methods for requirement analysis, designing, and building prototypes \nof interactive systems, and evaluating them. In practical sessions, students will practice the use \nof relevant methods within the context. Some of the topics covered in the course are: User \nNeeds Analysis, Conceptual Design, Mockups, and Prototypes, Usability, Evaluation of \nPrototypes and technology for interactive systems. \n \nAdditional Information Teaching Methods \nLectures, practical sessions. \nMethod of Assessment \nThe final grade is determined by the partial grades of the following deliverables: \n \ncourse assignments (group and possibly individual); \nexam (individual). \nThe final grade will be calculated based on the assignment grades and the exam grade (FINAL \nGRADE = 0.6 ASSIGNMENTS + 0.4 EXAM). To pass the course, students need to complete all \nassignments and pass both parts (Grade >= 5.5). \n \nLiterature \nRecommended Literature: \n \nMacKenzie, I. S. (2012). Human-computer interaction. Elsevier Science. \n \nISBN: 9780124058651. Available for free online from the VU Library for registered VU students \n(https://vu.on.worldcat.org/oclc/875263048) \n \nAdditional Information Target Audience \n",
        "Bachelor Computer Science ( ) \nExplanation Canvas \nAll details of the course will be published on the Canvas page. \nRecommended background knowledge \nBasic programming skills, basics statistics, data collection. \n \n",
        "HUMAN-COMPUTER INTERACTION \nCourse Objective \nThis course is an introduction to security and safety engineering for Bachelor Students in \nComputer Science to \n \nbuild awareness of security and safety issues in software systems, \napply security and safety threat analysis and mitigation techniques at conceptual level to \npractical case studies, and \ninspire students to further their education in computer security by exposing them to industrial \npractices. \nThe course is organised along the principles of scientific peer reviews and expects motivated \nstudents to reach the highest educational objective in Bloom\u2019s cognitive taxonomy (Judgement). \n \nCourse Content \nAfter completing this course, the student will be able to: \n \nApply the conceptual elements of security and safety engineering for security and safety risk \nanalysis (assets, threats, risks and controls) on a concrete problem [Applying knowledge and \nunderstanding, Communication] \nIdentify and review pros and cons of qualitative techniques on the concrete problem instance by \nreviewing the work of their peers. [Making judgements, Communication, Lifelong learning skills] \nApply the general methodology so learned to the industrial software vulnerability assessment \ntechniques on a concrete problem. [Applying knowledge and understanding, Lifelong learning \nskills] \nAdditional Information Teaching Methods \nThe course is organised into weekly lectures coupled with practical assignments where the \nstudents will apply gained theoretical knowledge on one or more case studies of a software \nsystem. \n \nLectures and discussion/Q&A sessions. These activities will cover risk analysis, authentication \nand identification, assets, threats and security controls, software vulnerability and IT system \nassessment and introduce the concepts the students will be asked to apply. \nAll questions will be answered in the Q&A sessions \nSecurity Risk Analysis report(s). Each student will write a risk analysis report that is submitted in \nincremental stages with weekly deadlines including assets, threat analysis and security controls. \nEach report includes a new part corresponding to the newly introduced material and a rebuttal \nof the received reviews on the previous part as in scientific articles \nStudents who do not submit by the deadline will not be able to review the reports of their peers. \nIndividual peer reviews. Each student will review the assignments submitted by their peers \naccording a detailed grading scheme provided and exemplified by the lecturers \nEach student will have to review five assignments for each type of assignment. \nThe feedback of students of past editions of the course is that the average time for peer \nevaluation is estimated at one hour per (good) review. \n",
        "Class presentation and public review. To provide intermediate feedback and to learn to identify \nand review a variety of applications of the technique students will be asked to discuss their \nassignments in front of the class. \nAttending the discussion classes is mandatory, also for students that have already discussed in \nprevious sessions. \nMethod of Assessment \nGiven the tight timeline, at the beginning of the course students will have to submit a short (1/3 \npage) essay on their study strategy and grade expectation. Those that do not submit by the \ndeadline will get a NS \"No Show\" as the final grade. \n \nThe overall grade is determinbed as follows: \n \n60% for the reportseach of which is divided as \n65% on the evaluation of the report as graded by the peers \n35% for the participation to the peer review process and the quality of the reviews as \nre-evaluated by the lecturers and teaching assistants \n40% for the final exam for the score of vulnerability assessments \nPass or fail \n \nQuality of the reviews. Additional points beyond the participation will be deducted to students \nwho write poor (e.g. generic such as \"it is ok, full points\") or unfair reviews. \nPresentation of the reports in class. If a student is asked to present his/her report in class and is \nabsent or not able to do present it, the assignments will be considered void. \nStudents must reach 5.5 on both the report and the final exam. \n \nPlagiarism and Fraud Check \n \nIf the number of students is so large that discussions in front of the class cannot be organised \nfor all students to present at least once, a digital exam will be organised to assess the \nknowledge of the reviewed material. Students who have not presented must score at least \n6/10in the confirmation exam for the assignments score to be considered valid. \n \nResit \n \nThere is a resit for the final exam on vulnerability assessment. \n \nIt is not possible to resit the assignments and the peer reviews. Students can only resit failed \nreviews due to additionally deducted points by writing a report analyzing the reviews of all other \nstudents for each failed report. \n \nEntry Requirements \nWhile there is no formal entry requirements, students who do not have the background \nknowledge provided by the courses on Computer Networks, Operating Systems, \nWeb/Application Software development will encounter some difficulties in the course. \n",
        " \nLiterature \nGibson. Managing Risk in Information Systems. Jones & Bartlett \nThis book offers a general structure of the security assessment process in industry and can be \nfollowed for the high level process of threat and security \nAdditional Lecture Material \nSlides and Additional Material will be provided in Canvas \nCommon Vulnerability Scoring System Standard v3.1 and v4.0 \nNational institute of Standards and Technology - 800-* family \nSESAR OpenSky Security Risk Assessment Method SecRAM simplified version used by \nEurocontrol \nAnderson. Security Engineering. Wiley. \nThe previous version of the book is available on line https://www.cl.cam.ac.uk/~rja14/book.html \nShostack, A. (2014). Threat modelling: Designing for security. Wiley \nSelected chapters will be made available on canvas for educational use. \nAdditional Information Target Audience \nComputer Science Bachelor ( ) \nAdditional Information \nPlease see the information on Canvas. \n \nCustom Course Registration \nGiven the tight timeline, at the very beginning of the course students will have to submit a short \n(1/3 page) essay on their study strategy and grade expectations. Those that do not submit by \nthe deadline will get a NS \"No Show\" as the final grade. \n \nExplanation Canvas \nThe submission of the report and the peer review of the reports will be done in \nCanvas/FeedbackFruit. \n \nBecause of the way the system works by automatically assigning reviewers, it is not possible to \ngrant any deadline extension for the submission of the reports and the submission of the \nreviews. \n \nStudents should therefore carefully plan their activities and submit also a draft version of their \nreports well in advance of the deadline (multiple submissions are possible) rather than waiting \nfor the last moment. \n \nRecommended background knowledge \nWhile there is no formal entry requirements, students who do not have the background \nknowledge provided by the courses on Computer Networks, Operating Systems, \nWeb/Application Software development will encounter some difficulties in the course. \n \n",
        "SECURITY AND SAFETY ENGINEERING \nCourse Objective \nThis course is an introduction to security and safety engineering for Bachelor Students in \nComputer Science to \n \nbuild awareness of security and safety issues in software systems, \napply security and safety threat analysis and mitigation techniques at conceptual level to \npractical case studies, and \ninspire students to further their education in computer security by exposing them to industrial \npractices. \nThe course is organised along the principles of scientific peer reviews and expects motivated \nstudents to reach the highest educational objective in Bloom\u2019s cognitive taxonomy (Judgement). \n \nCourse Content \nAfter completing this course, the student will be able to: \n \nApply the conceptual elements of security and safety engineering for security and safety risk \nanalysis (assets, threats, risks and controls) on a concrete problem [Applying knowledge and \nunderstanding, Communication] \nIdentify and review pros and cons of qualitative techniques on the concrete problem instance by \nreviewing the work of their peers. [Making judgements, Communication, Lifelong learning skills] \nApply the general methodology so learned to the industrial software vulnerability assessment \ntechniques on a concrete problem. [Applying knowledge and understanding, Lifelong learning \nskills] \nAdditional Information Teaching Methods \nThe course is organised into weekly lectures coupled with practical assignments where the \nstudents will apply gained theoretical knowledge on one or more case studies of a software \nsystem. \n \nLectures and discussion/Q&A sessions. These activities will cover risk analysis, authentication \nand identification, assets, threats and security controls, software vulnerability and IT system \nassessment and introduce the concepts the students will be asked to apply. \nAll questions will be answered in the Q&A sessions \nSecurity Risk Analysis report(s). Each student will write a risk analysis report that is submitted in \nincremental stages with weekly deadlines including assets, threat analysis and security controls. \nEach report includes a new part corresponding to the newly introduced material and a rebuttal \nof the received reviews on the previous part as in scientific articles \nStudents who do not submit by the deadline will not be able to review the reports of their peers. \nIndividual peer reviews. Each student will review the assignments submitted by their peers \naccording a detailed grading scheme provided and exemplified by the lecturers \nEach student will have to review five assignments for each type of assignment. \nThe feedback of students of past editions of the course is that the average time for peer \nevaluation is estimated at one hour per (good) review. \n",
        "Class presentation and public review. To provide intermediate feedback and to learn to identify \nand review a variety of applications of the technique students will be asked to discuss their \nassignments in front of the class. \nAttending the discussion classes is mandatory, also for students that have already discussed in \nprevious sessions. \nMethod of Assessment \nGiven the tight timeline, at the beginning of the course students will have to submit a short (1/3 \npage) essay on their study strategy and grade expectation. Those that do not submit by the \ndeadline will get a NS \"No Show\" as the final grade. \n \nThe overall grade is determinbed as follows: \n \n60% for the reportseach of which is divided as \n65% on the evaluation of the report as graded by the peers \n35% for the participation to the peer review process and the quality of the reviews as \nre-evaluated by the lecturers and teaching assistants \n40% for the final exam for the score of vulnerability assessments \nPass or fail \n \nQuality of the reviews. Additional points beyond the participation will be deducted to students \nwho write poor (e.g. generic such as \"it is ok, full points\") or unfair reviews. \nPresentation of the reports in class. If a student is asked to present his/her report in class and is \nabsent or not able to do present it, the assignments will be considered void. \nStudents must reach 5.5 on both the report and the final exam. \n \nPlagiarism and Fraud Check \n \nIf the number of students is so large that discussions in front of the class cannot be organised \nfor all students to present at least once, a digital exam will be organised to assess the \nknowledge of the reviewed material. Students who have not presented must score at least \n6/10in the confirmation exam for the assignments score to be considered valid. \n \nResit \n \nThere is a resit for the final exam on vulnerability assessment. \n \nIt is not possible to resit the assignments and the peer reviews. Students can only resit failed \nreviews due to additionally deducted points by writing a report analyzing the reviews of all other \nstudents for each failed report. \n \nEntry Requirements \nWhile there is no formal entry requirements, students who do not have the background \nknowledge provided by the courses on Computer Networks, Operating Systems, \nWeb/Application Software development will encounter some difficulties in the course. \n",
        " \nLiterature \nGibson. Managing Risk in Information Systems. Jones & Bartlett \nThis book offers a general structure of the security assessment process in industry and can be \nfollowed for the high level process of threat and security \nAdditional Lecture Material \nSlides and Additional Material will be provided in Canvas \nCommon Vulnerability Scoring System Standard v3.1 and v4.0 \nNational institute of Standards and Technology - 800-* family \nSESAR OpenSky Security Risk Assessment Method SecRAM simplified version used by \nEurocontrol \nAnderson. Security Engineering. Wiley. \nThe previous version of the book is available on line https://www.cl.cam.ac.uk/~rja14/book.html \nShostack, A. (2014). Threat modelling: Designing for security. Wiley \nSelected chapters will be made available on canvas for educational use. \nAdditional Information Target Audience \nComputer Science Bachelor ( ) \nAdditional Information \nPlease see the information on Canvas. \n \nCustom Course Registration \nGiven the tight timeline, at the very beginning of the course students will have to submit a short \n(1/3 page) essay on their study strategy and grade expectations. Those that do not submit by \nthe deadline will get a NS \"No Show\" as the final grade. \n \nExplanation Canvas \nThe submission of the report and the peer review of the reports will be done in \nCanvas/FeedbackFruit. \n \nBecause of the way the system works by automatically assigning reviewers, it is not possible to \ngrant any deadline extension for the submission of the reports and the submission of the \nreviews. \n \nStudents should therefore carefully plan their activities and submit also a draft version of their \nreports well in advance of the deadline (multiple submissions are possible) rather than waiting \nfor the last moment. \n \nRecommended background knowledge \nWhile there is no formal entry requirements, students who do not have the background \nknowledge provided by the courses on Computer Networks, Operating Systems, \nWeb/Application Software development will encounter some difficulties in the course. \n \n",
        "SOFTWARE ENGINEERING PROCESSES \nCourse Objective \nThe main goal of the course is to provide students with theory and practice on concepts, \nprocesses, and tools related to software development and maintenance. These include \ntraditional software quality factors, software testing techniques, and modern software \nengineering processes (i.e., collaborative development and DevOps). \n \nUpon completion of the course, students will be able to: \n \nUnderstand and explain software quality factors (Knowledge and understanding); \nUnderstand, explain, and apply basic software testing techniques (Knowledge and \nunderstanding) (Applying knowledge and understanding); \nUnderstand and explain the fundamentals of DevOps and how DevOps teams can build and \ndeliver software with the help of existing tools (Knowledge and understanding); \nImplement a Continuous Integration/Deployment pipeline (Applying knowledge and \nunderstanding). \nCourse Content \nDeveloping real software systems is complex. They have various dimensions (e.g., they are \nusually large), they involve several people (having different backgrounds) collaborating and \nsynchronizing with each other, they need various resources of different types, and their \ndevelopment often starts when the customer requirements are still unclear. The main steps of a \nsoftware engineering process are analysis of requirements, software design, implementation, \ntesting, and maintenance. While other courses cover early activities in a software engineering \nprocess (Requirements Engineering and Software Design), this course covers the continuous \nactivities performed by software engineers to develop, maintain, and operate software systems. \n \nThe topics covered by the course are: \n \nIntroduction to software quality \nIntroduction to software testing \n- DevOps \n \nContinuous Integration (CI) and Continuous Deployment (CD) \nCollaborative development (e.g., version control systems, code review) \nOpen-source software development \nAdditional Information Teaching Methods \nThe course contains lectures about the listed topics above. In addition, there will be at least one \nguest lecturer from the industry who will bring their case to show how software development and \nmaintenance happens in practice. \n \nMethod of Assessment \nThe grade will be based on assignment(s) (group-based, 80%) and a digital exam \n(multiple-choice questions, 20%). \n \n",
        "Resit option: re-submission of a simplified version of the assignment(s) and re-take of the digital \nexam. \n \nTo pass the course, it's mandatory to have a passing grade for each assignment and a passing \ngrade for the digital exam. \n \nLiterature \nThe course material will be handed out by the lecturers and distributed online (Canvas). It is \ncomposed of a selection of book chapters, relevant scientific articles, and documentation of the \nused software/tools. \n \nAdditional Information Target Audience \nBachelor Computer Science ( ). \n \nExplanation Canvas \nFurther information for this course will be made available online (Canvas). All students must be \nenrolled in the course on Canvas. Group enrollment takes lace in Canvas. \n \nRecommended background knowledge \nRequirements Engineering, Software Design.\n \n",
        "BACHELOR PROJECT COMPUTER SCIENCE \nCourse Objective \nUpon successful completion of the Bachelor Project Computer Science, students will be able to: \n \nDescribe an open problem in the domain of computer science; \nSearch and identify scientific literature relevant to the chosen problem; \nDesign a scientific and systematic approach to solving the chosen problem; \nExecute a project by following the approach, which may involve designing and conducting \nexperiments, developing tools or techniques, collecting and analyzing data; \nClearly and concisely present the contributions of the project as well as demonstrate the validity, \neffectiveness, and limitations of the chosen approach; \nReport the findings in writing in the form of a coherent story to a general CS audience; \nPresent their project (i.e., the motivation for the study, the methodology, the findings, and \nconclusions) to a general CS audience. \nEach learning outcome of the bachelor Project Computer Science covers all the Dublin \nDescriptors (Knowledge and Understanding, Applying knowledge and understanding, Making \njudgements, Communication, Lifelong learning skills). \n \nCourse Content \nThe CS Bachelor Project marks the culmination of the Bachelor's programme in Computer \nScience. During this project, you will tackle a clear and focused question within your area of \ninterest in computer science. The skills and knowledge you have gained throughout your studies \nand the experience from this project will equip you for further graduate studies or a career in the \nindustry. \n \nThe CS Bachelor project can be either purely theoretical or applied (possibly involving practical \nimplementation). Regardless of its nature, the project must adhere to VU\u2019s scientific standards. \nThe scientific work you perform, along with related tasks such as identifying and reviewing \nrelevant prior research, evaluating findings, and presenting your work in the thesis, are all \ncritically important. \n \nAdditional Information Teaching Methods \nThe CS Bachelor Project officially begins in period 5 and spans periods 5 and 6. Prior to the \nstart, students must find a project and a supervisor. A list of available project topics is provided \nvia Canvas in periods 2 or 3. Students should contact the supervisors who proposed the topics \nand, after an orientation meeting, confirm their collaboration. Students needing assistance in \nfinding a suitable supervisor can reach out to the course coordinator. Students may also choose \nto do their project in semester 1. To find a project and a supervisor, and plan the following steps, \nthey need to contact the course coordinator. \n \nStudents define the exact nature and scope of their CS Bachelor Project in collaboration with \ntheir supervisor. They can choose a topic from the list available via Canvas, or propose a topic \nthat aligns with the research interests of a potential supervisor. Another option is to find an \ninternship where they can carry out relevant research. Notice that it is necessary to seek the \n",
        "approval of a VU staff member who can act as the examiner before starting any internship. The \ncourse coordinator can advise students on this matter. \n \nProjects may be carried out individually or in a group, where each student has a specific role. \nSupervision meetings may also be carried out in a group fashion. \n \nMethod of Assessment \nThe project work results in a written report (thesis) and an oral presentation towards the end of \nperiod 6, which are assessed individually by two examiners. \n \nThe final grade is awarded by the first and second examiners as follows: 50% for the technical \ncontributions, 40% for the written report (i.e., thesis), and 10% for the oral presentation. A \ndetailed assessment rubric is provided via Canvas. \n \nThe deadlines for submitting the final version of the thesis and doing the presentation are \nplanned by the students in agreement with the supervisor. For students who wish to graduate in \nAugust, the supervisor must submit their graded thesis and final assessment form by July 31. \n \nFor students who wish to graduate in February, the supervisor must submit their graded thesis \nand final assessment form by January 31. More information is provided on Canvas. \n \nEntry Requirements \nBefore starting the Bachelor Project Computer Science (XB_40001), students must have \ncompleted at least 120 EC of the Computer Science Bachelor's programme. \n \nAdditional Information Target Audience \nBachelor Computer Science ( ) \n \nExplanation Canvas \nDetailed information about the Bachelor Project is offered on its Canvas page. The Canvas \npage is published in period 1.\n \n",
        "AUTOMATA AND COMPLEXITY \nCourse Objective \nThe first part of the course, on automata and languages, deals with the. concepts of formal \nlanguage, grammar, and automaton. Two types of languages are covered: regular and \ncontext-free languages. Regular. languages in the form of regular expressions are ubiquitous in \ncomputer science. They are used in search queries and text manipulation. \n \nContext-free languages and grammars (e.g. the Backus\u2013Naur form) are the prevailing \nstandards for describing programming languages. We also discuss parsing algorithms to \ndetermine whether a given string is in a context-free language. The automata-theoretic \ncounterparts for regular and context-free languages are finite automata and the more powerful \npushdown automata. \n \nThe students will learn to: \n \ndesign finite automata and create regular expressions for a given regular language, [Knowledge \nand understanding] [Applying knowledge and understanding] \napply algorithms to translate between finite automata, right-linear grammars, and regular \nexpressions, [Knowledge and understanding] [Applying knowledge and understanding] \napply algorithms to make automata deterministic and minimal, [Knowledge and understanding] \n[Applying knowledge and understanding] \ndesign pushdown automata and create context-free grammars for a given context-free \nlanguage, [Knowledge and understanding] [Applying knowledge and understanding] \napply algorithms to translate between pushdown automata and context-free grammars, \n[Knowledge and understanding] [Applying knowledge and understanding] \nuse pumping lemmas to reason about whether a language is regular or context-free, [Applying \nknowledge and understanding] [Making judgements] \napply algorithms for parsing context-free languages. [Knowledge and understanding] [Applying \nknowledge and understanding] \nIn the second part of the course, on computability theory, the central question is: what \ncomputations can be performed on a computer? To reason about computability, we introduce \nthe mathematical model of Turing machines and discuss the Church-Turing thesis. We discuss \nexamples of undecidable problems: the halting problem and the Post correspondence problem. \nIt is shown how the undecidability of new problems can be shown by reduction from a known \nundecidable problem. Finally, we discuss a classification of decidable/computable problems into \nimportant complexity classes, notably P, NP, and NP-complete problems, together with the \ncorresponding reduction arguments. \n \nThe students will learn to: \n \nreason whether a given problem is decidable (computable) or undecidable (not computable), \n[Making judgements] \nunderstand the classification of decidable problems in the complexity hierarchy (e.g. P, NP, \nEXP) of, and [Knowledge and understanding] \n",
        "reason about the complexity of a problem via the reduction to/from problems with known \ncomplexity. [Making judgements] [Communication] [Lifelong learning skills] \nCourse Content \nThis course treats automata & formal languages and computability theory. \n \nThe student gets acquainted with important notions and algorithms regarding formal languages, \nautomata, grammars, compilers, computability, and complexity. \n \nThis course addresses foundational questions in computer science: \n \nWhat can be computed? What are the limitations to what computers can do? \nHow much time and memory does solving a problem require? \nWhat is a (programming) language? \nHow can languages be recognized by computers (automata)? \nWhich problems can be solved by what kinds of automata? \nThis course conveys the important idea that certain problems cannot be solved by computers. A \ncomputer scientist must be able to reason whether a given problem is computable (decidable) \nor not. Moreover, a computer scientist should be able to reason what language/complexity class \na given problem belongs to, and hence what kind of automata/algorithms are needed to tackle \nthe problem. \n \nAdditional Information Teaching Methods \n4 hours per week lectures; 4 hours per week exercise classes. \nMethod of Assessment \nThe homework is mandatory for qualifying for the exam (70% of the homework points to qualify \nfor the exam). In case at least 90% of the homework points is obtained, 0.5 bonus point is \nawarded for the final grade. At the end of the course there is a final exam. \n \nThe overall grade is the grade of the final exam plus the possibly 0.5 bonus point obtained for \nthe homework. (The bonus is only added for students that pass the exam with a grade of at \nleast 5.5.) \n \nThere is no resit opportunity for the homework. \n \nLiterature \nPeter Linz, An Introduction to Formal Languages and Automata, Jones & Bartlett, 4th or 5th \nedition \n \nAdditional Information Target Audience \nBSc Computer Science ( )\n \n",
        "MACHINE LEARNING \nCourse Objective \nUpon completion of this course, students will: \n \nbe acquainted with the dominant concepts of machine learning methods, including some \ntheoretical background. (Knowledge and understanding) \nacquire knowledge of established machine learning techniques such as linear models, neural \nnetworks, decision trees and ensemble methods (Knowledge and understanding) \nlearn some statistical techniques to assess and validate machine learning results. (Apply \nknowledge and understanding, make judgments) \nCourse Content \nMachine learning is the discipline that studies how to build computer programs that learn how to \nbehave from examples, rather than following explicit instructions. It is a subfield of artificial \nintelligence that intersects with statistics, cognitive science, information theory, and probability \ntheory. \n \nRecently, machine learning has become increasingly important for the design of search engines, \nrobots, and sensor systems, and for the processing of large scientific data sets. Other \napplications include handwriting or speech recognition, image classification, medical diagnosis, \nstock market analysis and bioinformatics. \n \nThe course covers a wide variety of machine learning techniques, but puts particular emphasis \non gradient descent optimization, backpropagation, neural networks and deep learning. Some \ndiscussion on the broader social impact of machine learning technology is included. \n \nAdditional Information Teaching Methods \nThe course consists of pre-recorded videos, interactive lecture/QA sessions (two per week) and \noptional homework assignments discussed in working groups (one per week). The practical \nassignment is supported by small exercises to help with the relevant technologies, and informal \npresentations at project groups (one per week). \n \nThere is no mandatory attendance for any lectures or workgroups, except that one member of \neach group must be present at the weekly project group. A large amount of the material is freely \navailable at https://mlvu.github.io The course is taught in English. \n \nMethod of Assessment \nThe course assessment consists of two parts: an examination and a practical assignment. The \nexamination consists of a standard exam and four online quizzes. The examination and \npractical assignment both comprise 50% of the final grade. \nTo pass the course, the examination grade should be at least 5.5, the practical assignment \ngrade should be at least 4.5 and the average should be at least 5.5. \n \nThe examination is made individually, and the practical assignment is made in groups. There is \na resit for the exam, no resit is possible for the practical assignment. \n",
        " \nLiterature \nThere is no textbook. Some reading material will be provided digitally. \nAdditional Information Target Audience \nThis course is only open to the following programs. If you are not a student of these programs, \nregistration is not available. \n \nIt is currently part of the curriculumn of: \nBachelor Artificial Intelligence \nBachelor Business Analytics \nBachelor Computer Science \n \nPremaster Artificial Intelligence \nPremaster Business Analytics \n \nIt is available as an elective to students of: \nBachelor Mathematics \nBachelor Medische Natuurwetenschappen \n \nIf you are in the MSc Bioinformatics, you need to register forScientific Machine Learning \n(XM_0138), which shares some aspects with this course. \n \nCustom Course Registration \nWorkgroup registration will be done through Canvas in the first week of the course. Only a \nregistration for the main course itself is required to take part in all parts of the course. \n \nRecommended background knowledge \nWe require that students have some prior experience with linear algebra, calculus (limited to \ndifferentiation), probability theory and statistics. An overview and explanation of the required \npreliminaries can be found at https://mlvu.github.io/preliminaries/ \n \nA basic understanding will suffice and we will take some time to go over the basics again. Feel \nfree to register if you have no experience with any of these, but expect to put in a little extra \neffort in the first weeks (using the materials provided). \n \nProgramming experience in python is also required.\n \n",
        "PHILOSOPHY AND ETHICS \nCourse Objective \nAt the end of the course, the students will be: \n \nfamiliar with basic knowledge of key theories in Moral philosophy, Philosophy of Mind and AI, \nand Epistemology [knowledge and understanding]; \nable to apply these theories to moral dilemmas concerning new technologies [applying \nknowledge and understanding]; \ntrained to deal with moral dilemmas they might encounter in their future career [learning skills]. \nCourse Content \nArgument of the course: \n \nNew technologies (e.g. the ads we see, nudging us to make healthy and sustainable choices, \nwriting texts, etc.) that influence our actions and ways of thinking are everywhere. \nIt is better if these technologies meet certain moral and epistemic standards. \nHence, those involved in the design or regulation of these technologies (i.e. you, in the future) \nshould know about the main ideas in ethics, epistemology, and philosophy of mind/AI. \nThis course surveys and critically examines relevant issues in Philosophy and Ethics, including \nthe philosophy of AI, algorithms and echo chambers, and the background moral and \nepistemological theories that help us to think critically about new technologies. You will learn \nabout the main ethical theories (namely, utilitarianism, Kantian ethics, and theories of \nwell-being), epistemological theories (evidentialism; epistemic paternalism), and in philosophy of \nmind/AI (functionalism; mind-brain identity theory; the ethics of AI), learning to utilize these \ntheories and distinctions to resolve moral and social dilemmas in a justified and intelligent way. \n \nAdditional Information Teaching Methods \nLectures \n \nMethod of Assessment \nFinal exam (100% grade) \n \nLiterature \nSelected textbook chapters: \n \n**All texts will be available online**. \n \n- Chapters from Rachels & Rachels The Elements of Moral Philosophy. \n- Chapters from The Oxford Handbook of Ethics of AI. \n \nSelected academic articles or chapters: \n- Nguyen, C. Thi (2021). Echo chambers and epistemic bubbles. Episteme. \n- Rubel, Alan; Clinton, Castro, and Pham, Adam (2021). \u201cAgency Laundering and Information \nTechnologies\u201d Algorithms and Autonomy: The Ethics of Automated Decision Systems. \nCambridge University Press. \n"
    ],
    "semesters_134818312194680222": [],
    "text_curriculum\\University of Luxembourg.pdf": [
        "Course Outlines \n1st Semester \nWEB DEVELOPMENT 1 \nObjectives \nThe course provides an introduction to front-end web development. The course covers the \nfoundational building blocks of the Web and user interface design fundamentals for building \nwebsites and web applications. After the course, students will be able to understand and \ndevelop the front-end of any kind of websites and web applications. \n \nCourse learning outcomes \n1.Understand the foundations of front-end development. \n \n2.Identify the key components of web technologies.3.Judge and support best practices in web \ndevelopment. \nDescription \n1. Getting started 1.1. Front-end roles: Design, develop, create, animate1.2. Languages: HTML, \nCSS, JS1.3. Setup: OS, browsers, editors2. How the web works 2.1. History: Internet, web \nbrowsers2.2. URIs: Scheme, conventions3. Key concepts to know 3.1. Methodologies: \nProgressive enhancement, graceful degradation, RWD3.2. Accessibility: Types of impairments4. \nHTML Overview 4.1. Defaults: Formatting, doctypes, stylesheets4.2. Semantic markup: \nMicrodata, microformats4.3. Entities: Tags, attributes5. Marking up text 5.1. Structural elements: \nMetadata, sections, text, lists, tables, form, media6. Adding links 6.1. Working with URLs: Link \ntypes, attributes, fragments7. Adding images 7.1. Concepts: Formats, raster/vector, resolution, \ninterlacing, transparency7.2. Optimization: Compression, dithering7.3. SVG: Animation, filters8. \nTables 8.1. Markup notation: Semantics, controlling structure9. Forms 9.1. Markup notation: \nElements, attributes9.2. Sending data: GET, POST, encodings10. HTML510.1. Overview: \nFeatures, browser wars10.2. APIs: Media Player, History, Storage, Drag and Drop, Canvas11. \nCascading Style Sheets 11.1. Authoring: Formats, structure11.2. Inheritance: Tree matching, \nspecificity11.3. Selectors: IDs, classes, conflicting styles, contextual and pseudo-selectors12. \nFormatting text 12.1. Fonts: Properties, family, style, color12.2. Measurement units: Absolute \n(px, pt) and relative (em, ex)13. Colors and backgrounds 13.1. Color models: RGB, RGBA, \nHSV, opacity13.2. Images: Properties, notation13.3. Gradients: Linear and radial gradients14. \nThinking inside the box 14.1. Box model: Sizing, overflow, margin, padding, borders15. Floating \nand positioning 15.1. Layout flow: Containers, clears, stacking order16. Page layout 16.1. \nTypes: Fixed, fluid, elastic, hybrid16.2. Methodologies: Common patterns, Flexbox, Grid \nsystem17. Transitions, transforms, and animation 17.1. Fundamentals: Functions, keyframes, \nproperties18. CSS techniques 18.1. Tips: Resets, sprites18.2. Preprocessors: Variables, \nfunctions18.3. Responsive web design: Media queries \nAssessment \nAssessment modality: Coding assignments (continuous evaluation) and multiple-choice quiz \nexam. \n \nAssessment tasks \n \n",
        "Task 1: Coding assignments (40%) \n \nGrading scheme: 20 points (0-20) \n \nObjectives: Students will learn how to implement business requirements through hands-on \nexercises using JavaScript, HTML, and CSS. \n \nAssessment rules: Every week, students must submit a simple programming exercise based on \nthe contents taught in the course. Students must follow a series of specifications about each \nexercise, provided in Moodle. Students have up to 1 week to submit. Exercises must be \nsubmitted only via Moodle. No late submissions are allowed, unless \u201cforce majeure\u201d causes; \ne.g. sickness, accident, etc. for which an authoritative certificate must be provided (e.g. a \ncertificate signed by a medical doctor or a police representative). \n \nAssessment criteria: There are 10 coding assignments in total, and each will be graded using a \n0-10 point scale via an automated testing platform. Students can access such a platform at any \ntime before each submission deadline. Students must get an average grade of at least 4.5 \npoints (out of 10) in this part in order to qualify for the final exam. If a student scores less that \n4.5 points in this part, the final grade in the course will be the minimum grade achieved in either \nthe coding assignments or the final exam. Any form of cheating or plagiarism will be penalized \nwith a grade of 0 in this part, which will make the student to fail the whole course. The grade in \nthis part will be retained until the student passes the final exam, unless the student decides to \nrepeat the course in the next academic year. There is no retaking option for this part within the \nsame academic year, which means that a student who fails this part must enroll again in the \ncourse in the next academic year. Retaking students must inform the course responsible \nwhether they want to keep their grade in this part from the previous year.Task 2: Final exam \n(60%) \n \nGrading scheme: 20 points (0-20) \n \nObjectives: Students will demonstrate that they have acquired the required competencies \naccording to the theory covered in the course. \n \nAssessment rules: Only students who got at least 4.5 points in the coding assignments should \ntake the final exam, otherwise they are advised to de-enrol from the final exam in order to avoid \nmissing an official attempt. Students can bring an A4 paper \u201ccheat sheet\u201d written on both sides. \nNo other supporting material is allowed, i.e. no books, no mobile devices, no laptops, etc. \n \nAssessment criteria: The exam is a paper-based quiz with 30 questions that must be solved in \n45 minutes. Each question comes with 4 possible answers, among which only one is the right \none. A student must get at least 4.5 points (out of 10) in the final exam in order to pass the \ncourse. If a student scores less that 4.5 points in this part, the final grade in the course will be \nthe minimum grade achieved in either the coding assignments or the final exam. Any form of \ncheating or plagiarism will be penalized with a grade of 0 in this part, which will make the \n",
        "student to fail the whole course. The grade in this part will not be retained for the next academic \nyear. Failing students can retake the exam in the next examination period or enroll again in the \ncourse the next academic year. \nNote \nSyllabus\u22a0Yes\u2610NoRemarks:Available on MoodleLiterature list\u22a0Yes\u2610NoRemarks:Reference \ntexbook:\u2022J. Robbins. 2012. Learning Web Design. O\u2019Reilly Media, 4th ed.Recommended \nbooks:\u2022R. Anquetil. 2019. Fundamental Concepts for Web Development, 1st ed.\u2022M. Haverbeke. \n2018. Eloquent JavaScript, 3rd ed.\u2022S. Krug. 2000. Don\u2019t Make Me Think, 3rd ed.Moodle \npage\u22a0Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=5689 Other, please \nspecify:Class attendance is not required but highly encouraged.\n \n",
        "ANALYSIS 1 \nObjectives \nThis course is an introductory analysis course, covering basics on numbers, sequences, and \nfunctions. \n \nThe course aims to introduce students to these notions, including formal proofs, techniques and \nto give them necessary tools for the understanding of mathematics and the mathematical \nlanguage of science. \n \nCourse learning outcomes \nAt the end of the course the student will:-remember further mathematical knowledge. -apply \nanalytic and critical thinking.-understand and practice deep mathematical concepts that will be \nused throughout their scientific career.-apply techniques from calculus to compute. \nDescription \nThis course is an introductory analysis course, covering basics on numbers, sequences, and \nfunctions. There is both a calculus component (computations of limits of sequences, derivatives, \nfunction approximations, limits of sequences) and more theoretical analysis.This latter portion is \nsizeable part of the course where the students are introduced to proof techniques and the \nimportance of rigorous arguments which are foundational and transversal in mathematics and \nscience. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(60%)Grading scheme: 20 points (0-20)Objectives: Test concepts learned during the \nyearAssessment rules: Students cannot use calculators, electronic devices, or \nnotes.Assessment criteria: Graded out of 20 with points for each exerciseTask 2: Written exam \n(20%)Grading scheme: 20 points (0-20)Objectives: Test concepts learned during the \nyearAssessment rules: These are partial exams during the semester (there are several of them). \nStudents cannot use calculators, electronic devices, or notes.Assessment criteria: Graded out of \n20 with points for each exerciseTask 3: Take-home assignment (10%)Grading scheme: 20 \npoints (0-20)Objectives: Practice conceptsAssessment rules: Students work from home and can \nuse course materials.Assessment criteria: Graded out of 20 with points for each exerciseTask 4: \nWritten exam (10%)Grading scheme: 20 points (0-20)Objectives: QuizzesAssessment rules: \nThere are 2 mandatory quizzes. Students cannot use calculators, electronic devices, or \nnotes.Assessment criteria: Graded out of 20 with points for each exerciseTask 5: Written exam \u2013 \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: The final grade, in case of a \nretake exam, is based 100% on the exam grade. (Performance on quizzes, homework, \nmidterms, and exercises is not taken into account.)Assessment rules: Students cannot use \ncalculators, electronic devices, or notes.Assessment criteria: Graded out of 20 with points for \neach exercise \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Literature list\u2612Yes\u2610NoRemarks:Course notesMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=322\n \n",
        "DISCRETE MATHEMATICS 1 \n \nObjectives \nDiscrete structures are foundational material for computer science. Relatively   few computer \nscientists will be working primarily on discrete structures, but many other areas of computer \nscience require the ability to work with concepts from discrete structures. The discrete structures \ncovered in this introduction include important material from such areas as set theory, logic, \ngraph theory, and number theory. \n \nCourse learning outcomes \nBy the end of the course students will be able to:-Use logical notation to define and reason \nabout fundamental mathematical concepts, such as sets, relations, functions, and \nintegers.-Evaluate elementary mathematical arguments and identify fallacious   reasoning (not \njust fallacious conclusions).-Synthesise induction hypothesis and simple induction proofs.-Prove \nelementary properties of modular arithmetic and explain their applications in Computer Science, \nfor example, in cryptography.-Apply graph theory models of data structures and state machines \nto solve problems of connectivity and constraint satisfaction, for example, scheduling.-Apply the \nmethod of invariants and well-founded ordering to prove   correctness and termination of \nprocesses and state machines.-Efficiently work on problems in a small team with fellow \nstudents. -Manage their time and tasks in a responsible way. \nDescription \n* Week 1 \u2013 Week 4: Proof techniques* Week 5 \u2013 Week 6: Introduction to Logic* Week 7: \nMid-Term Exam* Week 8 \u2013 Week 9: Sets, Relations, and State Machines* Week 10 \u2013 Week 12: \nGraph Theory* Week 13 \u2013 Week 14: Number Theory and modular Arithmetic* Final Exam* \nRetake Exam \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Mid-Term (50%)Grading scheme: 20 points (0-20)Objectives: To test the \nstudents their knowledge of the first half of the material i.e. week 1-6 Proof techniques and \nLogic.Assessment rules: Students are allowed a cheat sheet using 1 side of 1 a4 page. Beside \nthis, students can only bring pen and pencil. Final answers should be written using pen \n(blue/black).Assessment criteria: The answers to the exercises are graded based on \ncorrectness completeness and clarity. (see 9 points for writing good proofs in proof guide on \nmoodle)Task 2: Written exam \u2013 Final Exam (50%)Grading scheme: 20 points (0-20)   \nObjectives: To test the students their knowledge of the second half of the material i.e. week \n7-13: sets, relations and state machines; graph theory; number theory and \narithmetic.Assessment rules: Students are allowed a cheat sheet using 1 side of 1 a4 page. \nBeside this, students can only bring pen and pencil. Final answers should be written using pen \n(blue/black).Assessment criteria: The answers to the exercises are graded based on \ncorrectness completeness and clarity. (see 9 points for writing good proofs in proof guide on \nmoodle) \n",
        " \nIn order to receive a final grade the midterm exam and final exam need to be completed. \n \nTask 3: Written exam \u2013 RETAKE EXAM (100%)Grading scheme: 20 points (0-20) Objectives: \nStudents who did not get an average of at least 10 points on the mid-term combined with the \nfinal exam are entitled to sit to the retaken test of the course. This test allows the student \nanother opportunity to pass the course by obtaining at least 10 points on this retake exam. The \nretake exam covers all course material.Assessment rules: Students are allowed a cheat sheet \nusing 1 side of 1 a4 page. Beside this, students can only bring pen and pencil. Final answers \nshould be written using pen (blue/black).Assessment criteria: The answers to the exercises are \ngraded based on correctness completeness and clarity. (see 9 points for writing good proofs in \nproof guide on moodle) \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on the Moodle page.Literature list\u2612Yes\u2610No \n \nRemarks:-Lecture notes available on the Moodle \npage.https://moodle.uni.lu/pluginfile.php/2227981/mod_resource/content/1/Lecture%20Notes%2\n0-%20MIT%20Discrete%20Math.pdfWe use the version from 2018. \n \n-A Guide for making proofs. Available on the moodle page.Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=323 Other, please \nspecify:We based this course on the MIT course Mathematics for Computer Science: \nhttps://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/\n \n",
        "LINEAR ALGEBRA 1 \n \nObjectives \nFundamental notions of Linear Algebra. \n \nCourse learning outcomes \nThe students recall and are able:\u2022To formulate the basic notions of linear algebra. \u2022To solve \nsmall linear algebra problems by performing calculations and applying algorithms.\u2022To \nunderstand small proofs and to look for examples and counterexamples. \nDescription \nSystems of linear equations and matrices; determinants; Euclidean vector spaces (especially in \ndimension 2 and 3); general vector spaces (linear independence, span, basis). \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Midterm exam 1 (15%)Grading scheme: 20 points (0-20)Objectives: \nWritten test with exercises.Assessment rules: Only 6 pages of personal notes are allowed. No \ncalculators.Assessment criteria: The tests are graded. The average of the two best midterms \ncounts as mark.Task 2: Written exam \u2013 Midterm exam 2 (15%)Grading scheme: 20 points \n(0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of personal notes \nare allowed. No calculators.Assessment criteria: The tests are graded. The average of the two \nbest midterms counts as mark.Task 3: Written exam \u2013 Midterm exam 3 (15%)Grading scheme: \n20 points (0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of \npersonal notes are allowed. No calculators.Assessment criteria: The tests are graded. The \naverage of the two best midterms counts as mark.Task 4: Written exam \u2013 Final exam \n(70%)Grading scheme: 20 points (0-20)Objectives: Written test with exercises.Assessment \nrules: Only 6 pages of personal notes are allowed. No calculators.Assessment criteria: The test \nis graded.Task 5: Oral exam \u2013 optional Grading scheme: 20 points (0-20)Objectives: Oral exam \n(in case of justified absence to >1 midterms or as additional evaluation in case of fraud \nsuspicion)Assessment rules: Discussion with questions (theoretical questions and \nexercises)Assessment criteria: Correct and partially correct answers contribute positively to the \ngrade.Task 6: Either final written exam (100%) or the same modalities as the regular students \n(to be selected by each retaking student at the beginning of each semester)Grading scheme: 20 \npoints (0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of personal \nnotes are allowed. No calculators.Assessment criteria: The test is graded.   \nNote \nSyllabus\u2612Yes\u2610NoRemarks:Moodle pageLiterature list\u2612Yes\u2610NoRemarks:Moodle \npageMoodle page\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=324 Other, \nplease specify:\n \n",
        "PROGRAMMING FUNDAMENTALS 1 \nObjectives \nThis course introduces the fundamentals of programming using the Python programming \nlanguage. This is not primarily a Python programming course but rather a discussion of the \nfundamental concepts underlying computation using Python code examples as illustration. At \nthe same time enough of the Python language is covered for the students to be able to tackle \nnon-trivial problems (e.g., in the context of projects). This introductory course forms the basis for \nmore advanced courses on algorithms and object-oriented programming. \n \nCourse learning outcomes \nUpon completion of this course the student should be able to:\u2022move from a problem description \nto a Python program by successively reducing the level of abstraction with the help of \npseudo-code.\u2022document the implementation choices. \u2022make use of available data types and \nprogram libraries.\u2022extend and adapt code written by other programmers.\u2022test and debug \ncomputer programs. \nDescription \n1. Introduction to computational problem solving and the Python programming language.2. \nBasic syntax and semantics of Python.3. Functions and modules.4. Problem solving and \nrecursion.5. Structured types and function objects.6. Files and exceptions.7. Testing.8. \nDebugging.9. Iterators and generators.10. Floating-point numbers.11. Introduction to \nobject-oriented programming in Python.12. Introduction to popular libraries: mathplotlib, NumPy \nand Pandas.13. Introduction to software engineering. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(50%)Grading scheme: 20 points (0-20)Objectives: The objective of this final exam is to test the \nstudent\u2019s understanding of the course material.Assessment rules: The student has to answer \nquestions with pencil and paper. This is a closed-book exam. No cheat sheet \nallowed.Assessment criteria: The student must answer the stipulated questions in a way that \nclearly demonstrates understanding of underlying concepts.Task 2: Written exam (50%)Grading \nscheme: 20 points (0-20)Objectives: To test the student\u2019s ability to implement Python programs \nfor concrete problems.Assessment rules: The student has to solve programming tasks with \npencil and paper. This is a closed-book exam. No cheat sheet allowed.Assessment criteria: The \nexam consists of two parts: mid-term evaluation and final evaluation, each of which counts \n25%.Task 3: Written exam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: The \nobjective of this final exam is to test the student\u2019s understanding of the course \nmaterial.Assessment rules: The student has to answer questions with pencil and paper. This is \na closed-book exam. No cheat sheet allowed.Assessment criteria: The student must answer the \nstipulated questions in a way that clearly demonstrates understanding of underlying \nconcepts.Assessment modality: Combined assessmentAssessment tasksAssessment modality: \nCombined assessmentAssessment tasks  \nNote \nCourse materialsSyllabus\u2610Yes\u2612NoRemarks:Literature list\u2610Yes\u2612NoRemarks:Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=321Other, please specify:\n",
        "INTRODUCTION TO PROJECT MANAGEMENT \nObjectives \nThe course aims to provide comprehensive knowledge and practical skills in project \nmanagement for scientific research, encompassing the entire lifecycle of projects from initiation \nto completion, including defining project deliverables, developing project plans, employing best \npractices and modern tools, conducting research ethically, and effectively presenting research \nfindings. \n \nCourse learning outcomes \nAt the end of the course students should be able to:- Understand Key Concepts of Project \nManagement- Develop Practical Project Management Skills- Apply Best Practices in Project \nManagement- Master Research Development Techniques- Handle and Analyze Data Ethically- \nEffectively Communicate Research Findings \nDescription \nThis course provides an in-depth exploration of project management and scientific research, \ncovering project planning, deliverables, values, tools, best practices, and case studies, as well \nas scientific research processes from topic selection to data gathering, hypothesis generation, \nand ethical considerations, with practical hands-on lab sessions integrated throughout each \nweek. \nAssessment \n\u200bAssessment modality: Combined assessmentAssessment tasks \n \nTask 1: Take-home assignment (30%)Grading scheme: 20 points (0-20)Objectives: Written one \nreport for project management planAssessment rules: Match with the course quality \ncriteria.Assessment criteria: Time constrained submission.Task 2: Take-home assignment \n(30%)Grading scheme: 20 points (0-20)Objectives: Written one report for scientific \nresearch.Assessment rules: Match with the course quality criteria.Assessment criteria: Time \nconstrained submission.  Task 3: Presentation (40%)Grading scheme: 20 points \n(0-20)Objectives: Presentation to a group of studentsAssessment rules: Match with the course \nquality criteria.Assessment criteria: Time constrained submission and present.Task 4: Written \nexam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: In the case the student \nhas failed to pass the class, he/she will be given a written retake assignment.Assessment rules: \nMatch with the course quality criteria.Assessment criteria: Time constrained submission. \nNote \nCourse materials \n \nSyllabus\u2610Yes\u2612NoRemarks:Literature list\u2612Yes\u2610NoRemarks:The AI Revolution in Project \nManagement: Elevating Productivity with Generative AI Vijay Kanabar (Auteur), Jason Wong \n(Auteur) ISBN 978-0138297336 Project Management: A Systems Approach to Planning, \nScheduling, and Controlling Harold Kerzner  ISBN: 978-1119805373 Software Engineering Ian \nSommerville  ISBN: 978-0133943030 Engineering Software Products: An Introduction to \nModern Software Engineering, Global Edition, 1st edition Ian Sommerville  ISBN-13: \n9781292376356 https://en.wikibooks.org/wiki/LaTeX Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=325 Other, please specify:  \n",
        "2nd Semester \nTHEORETICAL COMPUTER SCIENCE 1 \nObjectives \nThis course covers basic principles and techniques in theoretical computer science. More \nspecifically, automata theory, formal languages and Turing machines will be the core part of the \ncourse. The course is structured into two main parts. In the first part, we introduce the basic \nconcepts of automata theory such as deterministic and non-deterministic automata, regular and \ncontext-free languages. We then move to more advanced concepts of automata theory and \ncomputation. The languages and methods covered in the course are the building blocks of the \nscientific foundation of computer science.  \n \n  \n \nCourse learning outcomes \nBy the end of this course, the students will be able to:1. Understand the hierarchy of regular, \ncontext-free and decidable languages.2. Know the formal definition of syntax and semantics of \nvarious types of computational models (including (non-)deterministic finite automata, regular \nexpressions, push-down automata, context-free grammars, Chomsky normal form, and Turing \nmachines).3. Understand how the various types of computational models relate to the hierarchy \nof languages.4. Given an informal or mathematical definition of a formal language, develop a \nmodel of a given type that generates that language, and vice versa.5. Given an informal or \nmathematical definition of a formal language, determine to which language class it belongs and, \nusing one of the pumping lemmas, prove that it does not belong to a language class that is \nlower in the hierarchy.6. Convert a computational model of a given type into an equivalent \ncomputational model of another given type. \nDescription \n1. Basic Automata Theory and Computability 1.1. Automata Theory: introduction, context, \nmotivation, history, notation, basic concepts 1.2. Motivation and history, Deterministic finite \nautomata 1.3. Non-deterministic finite automata, equivalence of deterministic and \nnon-deterministic automata 1.4. Regular expressions, closure properties of regular languages \n1.5. equivalence of regular languages and finite automata, non-regular languages 1.6. Pumping \nlemma for regular languages, Context-free languages, context-free grammars, parsing, \nambiguity 1.7. Pushdown automata  2. Advanced Automata Theory and Computability 2.1. \nInclusion of regular languages in context-free languages, equivalence of pushdown automata \nand context-free grammars 2.2. Chomsky normal forms, pumping lemma for context-free \nlanguages 2.3. Turing machines 2.4. Turing-decidability, Turing machine variants 2.5. \nChurch-Turing thesis, decidable problems  \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks: \n \nTask 1 : Mid-term written exam (50%)Grading scheme: 20 points (0-20)Objectives Exam 1: \nEvaluate the mastery of contents taught in the first half of the semester.\u200b Assessment rules: \n",
        "\u200bClosed exam without any supporting materials only eligible for students who take the course for \nthe first time\u200b Assessment criteria: The correctness of solutions to assigned questions\u200b Task 2: \n\u200bWritten exam\u200b (50%)Grading scheme: 20 points (0-20)Objectives Exam 2: Evaluate the mastery \nof contents taught in the second half of the semester.\u200b Assessment rules: Closed exam without \nany supporting materials only eligible for students who take the course for the first time and \npass the mid-term exam\u200b Assessment criteria: The correctness of solutions to assigned \nquestions\u200b Task 3: Written exam\u200b RETAKE (100%)Grading scheme: 20 points (0-20) Objectives \nFull Exam: Evaluate the mastery of all the contents given in the whole semester. Provide a \nchance for students who need retaking the exam.\u200b Assessment rules: Closed exam without any \nsupporting materials eligible for the students who fail in exams of previous semesters or the \nmid-term exam in the same semester.  The Full Exam is equivalent to the combination of Exam \n1 and Exam 2.\u200b Assessment criteria: The correctness of solutions to assigned questions\u200b   \nNote \nCourse materials \n \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nPublished on Moodle on a weekly basis \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nMichael Sipser, Introduction to the Theory of Computation, 3rd Ed. (EMEA adapta- tion), \nCengage Learning, 2013 \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2454 \n \nOther, please specify:\n \n",
        "COMPUTING INFRASTRUCTURES 1 \nObjectives \nComputing professionals should not regard computers as black boxes that execute programs by \nmagic. This course first aims to develop a deeper understanding of the hardware and software \nenvironment upon which all computing is based. Students should acquire an understanding of a \ncomputer system\u2019s functional components, their characteristics, performance, and interactions.  \nThe course will cover how data are represented in memory and how they are manipulated \nduring computations. This course provides an introduction to operating systems, which define \nan abstraction of hardware and manage resource sharing among users. For instance, the \ncourse introduces the concept of processes and describe the difference between kernel and \nuser execution modes. \n \nCourse learning outcomes \nAt the end of the course the student will be able to: \n \n\u2022Explain why everything is data, including instructions, in computers.\u2022Describe how positive \nintegers are stored in unsigned representation.\u2022Describe how negative integers are stored in \ntwo\u2019s-complement representation.\u2022Describe how floating-point numbers are stored in IEEE754 \nrepresentation.\u2022Describe the internal representation of non-numeric data, such as characters \nand strings.\u2022Convert numerical data from one format to another.\u2022Explain how fixed-length \nnumber representations affect accuracy and precision.\u2022Explain the organization of the classical \nvon Neumann machine and its major functional units.\u2022Describe how an instruction is executed in \na classical von Neumann machine.\u2022Understand the mapping between high-level language code \nand assembly/machine language code.\u2022Explain different instruction formats, such as addresses \nper instruction and variable length vs. fixed length formats.\u2022Explain the basic concepts of \ninterrupts and I/O operations.\u2022Identify the main types of memory technology (e.g., SRAM and \nDRAM) and their relative cost and performance.\u2022Explain memory hierarchy and \ncost-performance trade-offs.\u2022Describe how the use of memory hierarchy (cache, virtual \nmemory)  reduces the effective memory latency.\u2022Explain how interrupts are used to implement \nI/O control and data transfers.\u2022Explain basic instruction level parallelism using \npipelining.\u2022Explain the importance of spatial and temporal locality in determining \nperformance.\u2022Explain the objectives and functions of modern operating systems.\u2022Describe how \ncomputing resources are used by application software and managed by system \nsoftware.\u2022Contrast kernel and user mode in an operating system\u2022Describe the need for memory \nprotection in an OS.\u2022Discuss the advantages and disadvantages of using interrupt \nprocessing.\u2022Explain the different states that a task may be in\u2022Describe reasons for using \ninterrupts, dispatching, and context switching to support concurrency in an operating system. \n\u2022Describe the difference between processes and threads.\u2022Explain how processes and threads \nare created and terminated.\u2022Compare and contrast common algorithms used for pre-emptive \nand non-pre-emptive scheduling. \nDescription \nCourse content Overview and history of computer architectureMachine level data \nrepresentation: \u2022 Bits, bytes, and words\u2022 Numeric data representation and number bases: \nfixed\u2010point, floating\u2010point, signed and two\u2019s\u2010complement representations, \u2022 Representation of \n",
        "non\u2010numeric data such as characters\u2022 Overflow and underflow of numeric data typesComputer \narchitecture: \u2022 Basic building blocks of a computer\u2022 von Neumann machine architecture\u2022 Control \nunit, instruction fetch, decode, and execution.\u2022 Shared memory multiprocessors/multicore \norganization\u2022 Main memory organization and operations\u2022 Cache memories and storage \nsystems\u2022 Memory hierarchy: the importance of temporal and spatial locality\u2022 Direct-memory \naccess (DMA)\u2022 Instruction set architecture (ISA) \u2022 Instruction formats\u2022 Data manipulation, \ncontrol, I/O\u2022 Addressing modes\u2022 Assembly and machine language \u2022 Subroutine call and return \nmechanisms.\u2022 I/O and interrupts\u2022 Heap, stack, data, and code segments\u2022 Branch prediction, \nspeculative execution, out\u2010of\u2010order executionOperating Systems (OS):\u2022 Role and purpose of \nthe operating system\u2022 OS main abstractions, processes, and resources\u2022 Concept of application \nprogram interfaces (APIs) \u2022 Use of libraries\u2022 The evolution of hardware/software techniques and \napplication needs\u2022 Device organization\u2022 Interrupts: principles and implementations\u2022 Concept of \nuser/system state and protection, transition to kernel mode\u2022 Process scheduling, scheduling \npolicies and context switching.\u2022 The role of interrupts.\u2022 The concept of threads versus \nprocesses. \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam\u200b (60%)Grading scheme: 20 points (0-20)Objectives: Assess students \nlearning.\u200b Assessment rules: Closed-book exam. \u200b Assessment criteria: \u200bCorrect and \nwell-explained answers to the questions. Demonstrate the acquisition of the learning outcomes \nof the course. No minimum passing grade is required for the exam but the final grade, \ncalculated as 0.6*Task 1 + 0.4*Task 2, must be greater than or equal to 10 to pass the course.\u200b \nTask 2: Take-home assignment\u200b (40%)Grading scheme: 20 points (0-20)Objectives: Assess \nstudents learning and improve learning. Identify gaps between what students know and can do \nand what they need to know and be able to do.\u200b Assessment rules: Each week students must \nhand in an assignment. Assignments are submitted electronically. Over the course of semester, \nfour assignments are taken at random to be graded. Those four assignments together weight \n40% of the final grade (10% each).  Assessment criteria: Correct and well-explained answers to \nthe questions. Demonstrate the acquisition of the concepts presented during the lectures. No \nminimum passing grade is required for the assignments but the final grade, calculated as \n0.6*Task 1 + 0.4*Task 2, must be greater than or equal to 10 to pass the course.\u200b Task 3: \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Students having failed the course \nwill have to re-sit the final written exam at a next exam session. The exam will count for the \nentirety of the final grade. However, optionally, students may decide to keep the grade obtained \nfor the assignments, which will then count for 40% of the final grade. The minimum passing final \ngrade for the course is 10.\u200b Assessment rules: \u200bClosed-book exam.\u200b Assessment criteria: Correct \nand well-explained answers to the questions. Demonstrate the acquisition of the learning \noutcomes of the course. The minimum passing grade is 10/20.\u200b    \nNote \nCourse materials \n \n",
        "Syllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \n\u2013 Structured Computer Organization: International Edition, by  Andrew S. Tanenbaum, Todd \nAustin, Person, 6th edition, 2012.- Modern operating systems, by Andrew S Tanenbaum, \nHerbert Bos, 4th edition, 2015.- Operating System Concepts, by Abraham Silberschatz et al, 8th \nedition, 2008.- Computer Systems: a Programmer\u2019s Perspective, by Randal E. Bryan, David R. \nO\u2019Hallaron, 2nd edition, 2011. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2453 \n \n \n",
        "NETWORKING AND COMMUNICATION \nObjectives \nNetworking and communication play a central role in interconnected computer systems that are \ntransforming the daily lives of billions of people. The Internet provides connectivity for networked \napplications that serve ever-increasing numbers of individuals and organizations around the \nworld. Many computing applications that are used today would not be possible without \nnetworks. The objective of the course is to introduce networks in general, and TCP/IP networks \nin particular. The course will introduce current network architectures, application-level protocols \n(e.g., HTTP), transport protocols (TCP/UDP), routing and IP. The course will introduce Medium \nAccess Control (MAC) techniques and quantitative performance measures for networks. The \ncourse will also provide a first introduction to mathematical concepts of networks. \n \nCourse learning outcomes \nBy the end of this course, the students will be able to:- understand the role and operation of \nnetworking and communication in networked computer systems,- explain how network structure \nand communication protocols affect the behavior of distributed applications,- describe key \nnetworking and communication principles and their specific instantiations on the Internet,- apply \nthe concepts in new technological settings. \nDescription \n1. Introduction to Computer Networks and the Interneta. Importance of networking in \ncontemporary computing, and associated challenges.b. Organization of the Internet (e.g., users, \nInternet Service Providers, autonomous systems, content providers, content delivery \nnetworks).c. Switching techniques (e.g., circuit and packet).d. Layers and their roles \n(application, transport, network, datalink, and physical).e. Layering principles (e.g., \nencapsulation and hourglass model).f. Network elements (e.g., routers, switches, hubs, access \npoints, and hosts).g. Basic queueing concepts (e.g., relationship with latency, congestion, \nservice levels, etc.)2. Networked Applicationsa. Naming and address schemes (DNS, IP \naddresses, and Uniform Resource Identifiers).b. Distributed application paradigms (e.g., \nclient/server, peer-to-peer, cloud, edge, and fog).c. Diversity of networked application demands \n(e.g., latency, bandwidth, and loss tolerance).d. An explanation of at least one application-layer \nprotocol (e.g., HTTP, SMTP, and POP3).e. Interactions with TCP, UDP, and Socket APIs.3. \nReliability Supporta. Unreliable delivery (e.g., UDP).b. Principles of reliability (e.g., delivery \nwithout loss, duplication, or out of order).c. Error control (e.g., retransmission, error \ncorrection).d. Flow control (e.g., stop and wait, window based).e. Congestion control (e.g., \nimplicit, and explicit congestion notification).f. TCP and performance issues (e.g., Tahoe, Reno, \nVegas, Cubic, QUIC).4. Routing and Forwardinga. Routing paradigms and hierarchy (e.g., \nintra/inter domain, centralized and decentralized, source routing, virtual circuits, QoS).b. \nForwarding methods (e.g., forwarding tables and matching algorithms).c. IP and Scalability \nissues (e.g., NAT, CIDR, BGP, different versions of IP).5. Single-Hop Communicationa. \nIntroduction to error detection and correction techniques.b. Medium Access Control (MAC) (e.g., \nrandom access and scheduled access).c. Ethernet.d. Switching.e. Link virtualization. \nAssessment \nAssessment modality:  \n \n",
        "Type of assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Midterm (50%)Grading scheme: 20 points (0-20)Objectives: Assess \nstudents\u2019 knowledge, skills, and abilities. Assessment rules: The students will have 45 minutes \nto complete the written exam. Only clearly crossed answers will be marked as correct. In case of \ndoubts, the side calculations will also be taken into consideration. Books, lecture notes, and \ncalculators are allowed to be used during the exam. No communication device whatsoever is \nallowed during the exam (e.g., laptop, smartphone, smartwatch, etc.).Assessment criteria: A \nnumber of points will be assigned for each correct answer. The number of points for each \ncorrect answer will depend on the difficulty of the question.Task 2: Written exam (50%)Grading \nscheme: 20 points (0-20)Objectives: Assess students\u2019 knowledge, skills, and abilities. \nAssessment rules: The students will have 45 minutes to complete the written exam. Only clearly \ncrossed answers will be marked as correct. In case of doubts, the side calculations will also be \ntaken into consideration. Books, lecture notes, and calculators are allowed to be used during the \nexam. No communication device whatsoever is allowed during the exam (e.g., laptop, \nsmartphone, smartwatch, etc.).Assessment criteria: A number of points will be assigned for \neach correct answer. The number of points for each correct answer will depend on the difficulty \nof the question.Task 3: Take-home assignmentGrading scheme:Pass/Fail Up to 20% bonus (4 \npoints)Objectives: Understand network protocols in action by observing the sequence of \nmessages exchanges between two protocol entities, delving down into the details of protocol \noperation, and causing protocols to perform certain actions and then observing these actions \nand their consequences.Assessment rules: Take-home assignments will be solved by groups of \nat least 2 people/group. At least 4 different assignments will be given during the semester. \nTake-home assignments are not mandatory. Each passed assignment will give the student a 5% \nbonus (1 point), up to a maximum of 20% (4 points). The bonus will be added to the final grade \nof the written exam only if the student obtained the minimum passing grade (i.e., 10 \npoints).Assessment criteria: Each submitted assignment will receive a Pass/Fail assessment \nbased on its correctness.Task 4: RETAKEGrading scheme: 20 points (0-20)Objectives: Students \nhaving failed the course will have to re-sit the written exam at a next exam session. Any bonus \npreviously obtained will remain valid and will be added to the final grade of the written exam \nonly if the student obtained the minimum passing grade (i.e., 10 points).Assessment rules: \nSame as Task 1 and 2Assessment criteria: Same as Task 1 and 2 \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n",
        " \n\u2612Yes  \u2610No \n \nRemarks: \n \nComputer Networking: A Top Down Approach 8th edition (Pearson) \u2013 available at the LLC. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2455 \n \nOther, please specify: \n \n \n \n",
        "LINEAR ALGEBRA 2 \n \nObjectives \nFundamental notions of Linear Algebra \n \nCourse learning outcomes \nThe students recall and are able: \n \nTo formulate the basic notions of linear algebra. \n \nTo solve small linear algebra problems by performing calculations and applying algorithms. \n \nTo understand small proofs and to look for examples and counterexamples. \nDescription \nGeneral vector spaces (base change); matrix spaces, matrix transformations;  Eigenvalues and \nEigenvectors; complex vector spaces ; inner product spaces, orthogonality; quadratic forms; \ngeneral linear transformations; if time permits, some applications of linear algebra. \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Midterm exam 1 (15%)Grading scheme: 20 points (0-20)Objectives: \nWritten test with exercises.Assessment rules: Only 6 pages of personal notes are allowed. No \ncalculators.Assessment criteria: The tests are graded. The average of the two best midterms \ncounts as mark.Task 2: Written exam \u2013 Midterm exam 2 (15%)Grading scheme: 20 points \n(0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of personal notes \nare allowed. No calculators.Assessment criteria: The tests are graded. The average of the two \nbest midterms counts as mark.Task 3: Written exam \u2013 Midterm exam 3 (15%)Grading scheme: \n20 points (0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of \npersonal notes are allowed. No calculators.Assessment criteria: The tests are graded. The \naverage of the two best midterms counts as mark.Task 4: Written exam \u2013 Final exam \n(70%)Grading scheme: 20 points (0-20)Objectives: Written test with exercises.Assessment \nrules: Only 6 pages of personal notes are allowed. No calculators.Assessment criteria: The test \nis graded.Task 5: Oral exam, optionalGrading scheme: 20 points (0-20), Objectives: Oral exam \n(in case of justified absence to >1 midterms or as additional evaluation in case of fraud \nsuspicion)Assessment rules: Discussion with questions (theoretical questions and \nexercises)Assessment criteria: Correct and partially correct answers contribute positively to the \ngrade.Task 6: Either final written exam (100%) or the same modalities as the regular students \n(to be selected by each retaking student at the beginning of each semester)Grading scheme: 20 \npoints (0-20), Objectives: \u200bWritten test with exercises. In case of fraud suspicion, the \u200bexam can \nbe replaced by an oral exam (as described in Task 5). Assessment rules: Only 6 pages of \npersonal notes are allowed. No calculators.Assessment criteria: The test is graded. \nNote \n",
        "Syllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nMoodle page \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nMoodle page \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2456 \n \nOther, please specify: \n \n",
        "PROGRAMMING FUNDAMENTALS 2 \nObjectives \nThis course is about object-oriented programming, a paradigm that enables programmers to \ndeal with program complexity by decomposing programs into small, self-contained units that can \neasily be reused and adapted across projects. The course will have a practical flavour, with \ndemonstrations, examples, and assignments. We will rely on the Java programming language to \nconcretize object-oriented concepts through the development of programs.  Java is among the \nfive most popular and most demanded programming languages on the job market; it is used in \nWeb-based, Android, and embedded systems. Java is popular because it is easy to learn, has a \nrich set of programming APIs, and is supported by many development tools. In this course, \nthrough Java, the students will learn to develop software applications of medium complexity \nrelying on class inheritance and decomposition, known Java data structures, exception \nhandling, file processing, GUIs, and concurrency support. \n \nCourse learning outcomes \nThe course will lead to the following learning outcomes:Design, code, test, and debug Java \nprograms that follow an object-oriented design and uses each of the following fundamental \nprogramming constructs: classes, assignment and expressions, console I/O, conditional and \niterative structures, functions with parameter passing, structured data types provided with the \nlanguage, use file I/O to provide persistence across multiple executions, rely on \nexception-handling mechanism.Write programs of medium complexity that use Java GUI APIs \nand rely on concurrency mechanisms.Develop tests for program modules and apply a variety of \nstrategies to design test cases.Build, execute and debug programs using a modern IDE and \nassociated tools such as visual debuggers. \nDescription \nThe course has the following lesson topics:1. Development environments: shell, editor, java \ncompiler vs runtime, source code control, build automation tools, IDEs,2. Java Basics: Types, \nControl Flow, and I/O operations,3. Inheritance and Polymorphism in Java,4. Implementing data \nstructures in Java,5. Java collections,6. Parametric polymorphism and generics,7. Exception \nhandling in Java,8. File processing,9. Concurrency in Java,10. Java GUIs, 11. Event-driven \nprogramming in Java,12. Static methods, Nested classes, Networking,13. Persistence,14. \nLambda and Streams.They cover for the following teaching objectives:A) Principles of \nobject-oriented programming and designA.1) Decomposition into objects carrying state and \nhaving behaviour through the definition of classes (fields, methods, and constructors), \nsubclasses, inheritance, and method overriding.A.2) Idioms for encapsulation (visibility, \ninterfaces, and abstract classes).A.3) Dynamic dispatching of method calls definition of \nmethod-call.B) The Java language as an example of object-oriented languageB.1) Basic \nconcepts such as variables, primitive data types, expression evaluation, assignment. B.2) Basic \nconstructs such as conditional and iterative structures and flow of control. B.3) Key modularity \nconstructs such as methods and classes, and related concepts like parameter passing, scope, \nabstraction, data encapsulation.B.4) Input and output using files, console, and APIs B.5) \nStructured data types available in the Java APIs (e.g., the collection framework) B.6) GUI \nLibraries B.7) RecursionB.8) Dealing with runtime errors in programs (exception handling) B.9) \nStrings and string processingC) Data structures in JavaC.1) Implementing standard abstract \n",
        "data types such as lists and trees in JavaC.2) The Java Collections package for lists, trees, \nstacks, queues, sets, and mapsC.3) Performance implications of choice of data structure(s)D) \nPrinciples of reactive programmingD.1) Components of reactive programming: event-source, \nevent signals, listeners and dispatchers, event objects, adapters, event-handlers.D.2) Use of \nreactive programming in Java, with a GUI case study: Defining event handlers/listeners, \nParameterization of event senders and event arguments, externally generated events, and \nprogram-generated events D.3) Conceptual separation between Model, View, and Controller.E) \nParallelism and concurrency in JavaE.1) Basic constructs and the concurrent Package.F) Basic \nsoftware testing principlesF.1) Deriving test cases from functional specifications and \nimplementationF.2) The Junit frameworkF.3) Code coverageG) Development environmentsG.1) \nShells, editors, java compiler vs runtime.G.2) Source code control, build automation tools, IDEs. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Mid-term exam (30%) \nGrading scheme: 20 points (0-20)Objectives: Written exam to assess students\u2019 knowledge of \nthe basics of Java and OO programming. Consists of short programming exercises, open \nquestions, and quizzes.\u200b Assessment rules: \u200bAll enrolled students. Laptop, smartphones, cheat \nsheets, and books are not allowed.\u200b Assessment criteria: Correctness of answers, program \ndesign, functioning, and code style.\u200b Task 2: Written exam\u200b (70%)Grading scheme: 20 points \n(0-20)Objectives: Programming exercises to assess that students have reached the objectives \nof the course. \u200b Assessment rules: \u200bAll enrolled students. Laptop, smartphones, cheat sheets, and \nbooks are not allowed.\u200b Assessment criteria: Correctness of program design, functioning, and \ncode style.\u200b Task 3: RETAKEGrading scheme: 20 points (0-20)Objectives: Programming \nexercises to assess that students have reached the objectives of the course. The result of \nmid-term exam is not considered for the final grade. Assessment rules: All enrolled students. \nLaptop, smartphones, cheat sheets, and books are not allowed.\u200b Assessment criteria: \nCorrectness of program design, functioning, and code style.\u200b  \nNote \n Course materialsSyllabus \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: Available on Moodle. Literature list \u200b\u2612\u200bYes\u200b\u2610\u200bNo \nRemarks: 1) Building Java Programs, 4th Edition. Stuart Reges, Marty Stepp. Pearson. 2) \nLearning Java. Marc Loy, Patrick Niemeyer, Daniel Leuck. 6th Edition. O\u2019Reilly Media. Moodle \npage \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: https://moodle.uni.lu/course/view.php?id=2452 Other, please \nspecify:  \n \n \n",
        "BACHELOR SEMESTER PROJECT 2 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following. \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself. The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum. \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project.  \nAssessment \nAssessment modality: Combined assessment \n \nTask 1: Final report and in-person presentation (100%) \n \nGrading scheme: 20 points (0-20)Objectives: Assess the quality and quantity of work done \nduring the semester.Assessment rules: Time constrained submissions.Assessment criteria: The \ndetailed criteria are specific to each project subject and applied on the following weighted \ndeliverables:\u2022technical & scientific quality of the final report, primary language (60%)\u2022technical & \nscientific quality of the final in-person presentation, primary language (30%)\u2022technical & \nscientific quality of the final report, secondary language summary (5%)\u2022technical & scientific \nquality of the final in-person presentation, secondary language summary (5%)Task 2: Retake \n(100%)Grading scheme: 20 points (0-20)Objectives: Option to repeat a previously failed project \n(with a final assessment of <10 points) with the same topic and under the same \nsupervisor.Assessment rules: The same deliverables as for the previously failed project must be \nresubmitted under the given time constraints.Assessment criteria: Same as for Task 1. \nNote \nSyllabus\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageLiterature \nlist\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=2457\n \n",
        "3rd Semester \nSTATISTICS FOR COMPUTER SCIENTISTS \nObjectives \nStatistical methods are central in data science, machine learning, and computer science at large \nas they provide a sound framework for understanding and making sense of the data.  In this \ncourse whose orientation is practical, students will learn the foundation to choose and apply the \nproper statistical techniques to solve a given problem. Practice exercises will develop \nproficiency in the Python programming language and in data analysis in general. \n \nCourse learning outcomes \nAt the end of the course the student will be able to:\u2022Understand the basic concepts: population, \nsample, measures of dispersion, variance.\u2022Display data graphically and interpret graphs (e.g., \nhistograms).\u2022Recognize, describe, and calculate means, medians, quantiles, variances, \ninterquartile ranges.\u2022Compute confidence intervals with formulas and \nbootstrapping.\u2022Understand why random sampling can reduce bias and yield a higher quality \ndata set.\u2022Formulate and understand the concept of data correlation.\u2022Data transformation: data \ncleaning and dimension reduction.\u2022Apply Principal Component Analysis (PCA) to dimensionality \nreduction problems.\u2022Apply linear regression to curve-fitting problems.\u2022Understand the concept \nof overfitting.\u2022Discuss and apply cross-validation in the context of overfitting and model selection \n(e.g., degree of polynomials in a regression context).\u2022Apply statistical tests to compare different \ndesign candidates.\u2022Understand how statistics can be used to set engineering simulation \nparameters with respect to target confidence level.\u2022Apply statistics to the analysis of financial \ndata (e.g., correlation between markets).\u2022Demonstrate proficiency in Python. \nDescription \nThe course covers the following topics:\u2022 Overview of the use of statistics in data analysis, \nmachine learning and engineering. \u2022 Descriptive statistics and exploratory data analysis: \npopulation, sample, mean, median, variance, empirical distribution histogram, cumulative \ndistribution function, quantile, box plots, density plots, scatterplot and coefficient of correlation.\u2022 \nInferential statistics: sampling, sampling bias and bootstrap.\u2022 Confidence intervals and margin of \nerrors.\u2022 A/B testing.\u2022 Statistical significance and p-values.\u2022 Hypothesis tests: one way versus \ntwo ways tests.\u2022 Performance comparisons, evaluating experiments.\u2022 Statistically-sound \nsimulation-based design in electrical engineering.\u2022 Basic statistical methods used in financial \ndata analysis.\u2022 Statistics in the performance evaluation of safety-critical computer systems. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Written exam \n(60%)Grading scheme: 20 points (0-20)Objectives: Assess students learning.Assessment rules: \nClosed-book exam. Assessment criteria: Correct and well-explained answers to the questions. \nDemonstrate the acquisition of the learning outcomes of the course. No minimum passing grade \nis required for the exam but the final grade, calculated as 0.6*Task 1 + 0.4*Task 2, must be \ngreater than or equal to 10 to pass the course.Task 2: Take-home assignment (40%)Grading \nscheme: 20 points (0-20)Objectives: Assess students learning and improve learning. Identify \ngaps between what students know and can do, and what they need to know.Assessment rules: \nGroup work (2 or 3 students per group).Assessment criteria: Correct and well-explained \nanswers to the questions. The quality of the report (writing, presentation) is an important \n",
        "assessment criterion. Submissions will be systematically checked for potential plagiarism. Task \n3: RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Students having failed the \ncourse will have to re-sit the final written exam at a next exam session. The exam will count for \nthe entirety of the final grade. However, optionally, students may decide to keep the grade \nobtained for the assignments, which will then count for 40% of the final grade. The minimum \npassing final grade for the course is 10.Assessment rules: Closed-book exam.Assessment \ncriteria: Correct and well-explained answers to the questions. Demonstrate the acquisition of the \nlearning outcomes of the course. The minimum passing grade is 10/20. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on MoodleLiterature list\u2612Yes\u2610NoRemarks:-\u201cPractical \nStatistics for Data Scientists\u201d, P. Bruce, A. Bruce, P.Gedeck, second edition, O\u2019Reilly, \n2020.-\u201cPerformance Evaluation Of Computer And Communication Systems\u201d, J.Y. Le Boudec, \nEPFL press, 2010. Available at https://leboudec.github.io/perfeval/  Moodle \npage\u2612Yes\u2610NoRemarks:TBC \n \n",
        "DISCRETE MATHEMATICS 2 \nObjectives \nDiscrete structures are foundational material for computer science. Relatively few computer \nscientists will be working primarily on discrete structures, but many other areas of computer \nscience require the ability to work with concepts from discrete structures. Second part of the \ncourse focuses on the data analysis. Methods used come from combinatorics, probability theory \nand statistics \n \nCourse learning outcomes \nAt the end of the course the student will be able to:-Find cardinalities of discrete structures.-Use \ncounting for proofs.-Compute probabilities of events based on observations, and \nindependence.-Take decisions via probabilities. \nDescription \n1. Discrete Structures (DS)1.1. Basics of Counting1.1.1. Counting arguments: Set cardinality \nand counting, Sum and product rule, Inclusion-exclusion principle.1.1.2. The pigeonhole \nprinciple1.2. Permutations and combinations, Pascal\u2019s identity, The binomial theorem1.3. \nSolving recurrence relations (cross-reference: AL/Basic Analysis): An example of a simple \nrecurrence relation, such as Fibonacci numbers.2. Discrete Probability2.1. Finite probability \nspace, events2.2. Axioms of probability and probability measures2.3. Conditional probability, \nBayes\u2019 theorem2.4. (Conditional) Independence2.5. Expectation and its Properties, Mean and \nVariance2.6. Integer Random Variables (Bernoulli, Binomial, etc..)2.7. Continuous Random \nVariables (Gauss, Poisson, etc..)2.8. Law of Large Numbers, Central Limit Theorem \nAssessment \nAssessment modality:   Combined assessmentAssessment tasks \n \nTask 1: Written exam (35%)Grading scheme: 20 points (0-20)Objectives: Check if the students \nare capable of formalisation, and computation of counting problems. Furthermore, algebraic \nmethods are expected to be known by then. Assessment rules: One A4 handwritten cheat \nsheet. Possibly needed tables are provided. The exam is based on both questions and longer \nproblems.Assessment criteria: Correctness, and chosen path to a solution.Task 2: Written exam \n(65%)Grading scheme: 20 points (0-20)Objectives: Final exam counting and \nProbabilitiesAssessment rules: One A4 handwritten cheat sheet. Possibly needed tables are \nprovided. The exam is based on both questions and longer problems.Assessment criteria: \nCorrectness, and chosen path to a solutionTask 3: Oral exam \u2013 RETAKE (100%)Grading \nscheme: 20 points (0-20)Objectives: Retake students will undergo evaluation to determine their \nproficiency in formalization and computation of counting problems, as well as their grasp of \nfundamental concepts in probability.Assessment rules: Oral examAssessment criteria: 75% CPE \n1 and 25% CPE 2 \nNote \nSyllabus\u2612Yes\u2610NoRemarks:Available on the Moodle page.Literature \nlist\u2612Yes\u2610NoRemarks:Based on the lecture notes from MIT, see \nhttps://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2005/pages/lecture-n\notes/ Moodle page\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3329 Other, \nplease specify:All the lecture slides and old videos are shared in Moodle page \n",
        "INFORMATION MANAGEMENT 1 \nObjectives \nInformation Management is primarily concerned with the capture, digitization, representation, \norganization, transformation, and presentation of information; algorithms for efficient and \neffective access and updating of stored information; data modelling and abstraction; and \nphysical file storage techniques. The student needs to be able to develop conceptual and \nphysical data models, determine which IM methods and techniques are appropriate for a given \nproblem, and be able to select and implement an appropriate IM solution that addresses \nrelevant design concerns including scalability, accessibility, and usability. \n \nCourse learning outcomes \nAt the end of the course, students will be able to:-design data models in different \nrepresentations (object-oriented, hierarchical, network-based, relational)-avoid redundancies \nand inconsistencies in the resulting models.-use different query languages to create and query \nlarge databases.-solve and implement individual information-management use-cases. \nDescription \nCourse content 1. Information Management (IM) 1.1. Information Management Concepts 1.1.1. \nInformation systems as socio-technical systems 1.1.2. Basic information storage and retrieval \n(IS&R) concepts. 1.1.3. Information capture and representation 1.1.4. Supporting human needs: \nsearching, retrieving, linking, browsing, navigating1.1.5. Information management applications \n1.1.6. Declarative and navigational queries, use of links 1.1.7. Content analysis and indexing \n1.1.8. Quality issues: reliability, scalability, efficiency, and effectiveness 1.2. Relational \nDatabases 1.2.1. Mapping conceptual schema to a relational schema 1.2.2. Keys and \nforeign-keys, referential integrity 1.2.3. Relational algebra and relational calculus 1.2.4. \nRelational database design 1.2.5. Functional dependencies 1.2.6. Decomposition of a schema; \nlossless-join and dependency-preservation properties of a decomposition. 1.2.7. Candidate \nkeys, super keys, and closure of a set of attributes 1.2.8. Normal forms (2NF, 3NF BCNF) 1.2.9. \nMulti-valued dependencies (4NF) 1.2.10. Join dependencies (PJNF, 5NF) 1.2.11. \nRepresentation theory 1.3. Query Languages 1.3.1. Overview of database languages 1.3.2. \nSQL (data definition, query formulation, update sublanguage, constraints, integrity) 1.3.3. \nSelect-project-join queries. 1.3.4. Aggregations and group-by 1.3.5. Over-operator and sliding \nwindows. 1.3.6. Subqueries in SQL 1.3.7. Constraints and triggers 1.3.8. Stored procedures and \nPL/SQL1.3.9. QBE and 4th-generation environments 1.3.10. Different ways to invoke \nnon-procedural queries in conventional languages. 1.3.11. Overview of other major query \nlanguages (e.g., XPATH, SPARQL) \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written or oral midterm \nexam (50%)Grading scheme: 20 points (0-20)Objectives: Reproduction and application of the \ncourse contentsAssessment rules: Closed book written exam (whole class) or 30 minutes \nindividual oral exam.Assessment criteria: Exam results are based on the correctness of the \nprovided answers.Task 2: Written or oral final exam (50%)Grading scheme: 20 points \n(0-20)Objectives: Reproduction and application of the course contentsAssessment rules: Closed \nbook written exam (whole class) or 30 minutes individual oral exam.Assessment criteria: Exam \nresults are based on the correctness of the provided answers.Task 3: Active participation \u2013 \n",
        "Presentation of exercise solutionsUp to 2 bonus pointsGrading scheme: 20 points \n(0-20)Objectives: Solution of exercise problemsAssessment rules: A correct presentation (in \nclass) of the solution to one problem of an exercise sheet yields 1 bonus point. Up to 2 bonus \npoints can be achieved per student this way per semester. Bonus points are added on top of the \npoints the student has achieved through the exams. At most 20 points can be achieved in \naltogether.Assessment criteria: Correctness of the provided solutions.Task 4: Written exam \u2013 \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Reproduction and application of \nthe course contentsAssessment rules: Closed book written exam (whole class) or 30 minutes \nindividual oral exam.Assessment criteria: Solution of exercise problems \nNote \nCourse materialsSyllabus\u2612Yes\u2610NoRemarks:Available on MoodleLiterature \nlist\u2612Yes\u2610NoRemarks:Database Systems: The Complete Book (ISBN: \n978-0131873254)Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3332 \n \n",
        "PROGRAMMING FUNDAMENTALS 3 \nObjectives \nProgramming fundamentals 3 is a two parts course where you will learn functional programming \nand parallel programming. The first part focusses on the foundation of the functional language \nOCaml. We show that functional programs are often shorter and more elegant than their \nimperative counterparts. In the second part, we introduce concurrent and parallel programming. \nWe discuss general synchronisation issues of concurrency models such as deadlock, livelock \nand starvation. We present the shared state and message-passing programming models aiming \nat solving these issues. Moreover, we connect both paradigms as the full class will be in the \nnewest OCaml 5.0 language, which includes a new multicore extension. \n \nCourse learning outcomes \nAt the end of the course the student will:-Know how to program and reason about programs in a \npurely functional programming style. -Solve problems in Haskell in a concise, yet expressive, \nmanner.-Decompose complex problems into smaller, manageable subproblems.-Think \nrecursively, make use of higher-order functions, understand the benefits of type systems, and \nlearn how some programming languages like Haskell avoid unnecessary computations via lazy \nevaluation.-Know common data structures (like stacks, queues, trees, self-balancing trees, and \ngraphs) and how these can be implemented in a functional language with data immutability. \n-Know how to analyse the run-time complexity of operations on these data structures. \n-Understand advanced concepts and abstractions of functional programming such as functors, \napplicative functors, and monads. Understand how to approach and solve classic computer \nscience problems in Haskell with essential techniques such as recursion, permutation \ngeneration, brute-force and binary search. \nDescription \n1. Introduction to FP and Haskell 1.1. Programming languages paradigms 1.2. Basic Haskell \nsyntax 1.3. Polymorphism and typeclasses 1.3.1. Types, type inference and polymorphism \n1.3.2. Typeclasses 1.4. Recursion 1.4.1. Thinking recursively 1.4.2. Sorting algorithms 1.5. \nFunctions 1.5.1. Pointfree style and infix functions 1.5.2. Composition 1.5.3. Lambda \nexpressions 1.6. Higher order functions 1.6.1. Maps and filters 1.6.2. Folding 1.6.3. Currying \nand partial function application 1.7. Data types 1.8. Input/Output 1.9. Functional styles in other \nprogramming languages 2. Purely functional data structures 2.1. Data immutability 2.2. Trees \n2.2.1. Binary search tree2.2.2. Self-balancing tree (AVL) 2.3. Lazy evaluation of infinite data \nstructures 2.4. Graphs and common graph algorithms in FP3. Arithmetic problems 4. Advanced \nconcepts in FP 4.1. Functors 4.2. Applicative functors 4.3. Monads 4.3.1. Maybe, Either 4.3.2. \nIO 4.3.3. State 5. Solving classic computer science problems, using Haskell  \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Take-home assignment \n(10%)Grading scheme: 20 points (0-20)Objectives: Develop basic algorithms that avoid \nassigning to mutable state using recursion.Assessment rules: Homework assignments are \nrequired to be submitted individually through Moodle. Each student must complete the \nhomework assignments on their own.Assessment criteria: Successfully solves the stated \nproblem with computational efficiency. Code demonstrates conciseness, clarity, and adherence \nto a functional programming style.Task 2: Take-home assignment (10%)Grading scheme: 20 \n",
        "points (0-20)Objectives: Solve classic computer science problems with compositional reasoning \nand higher order functions.Assessment rules: Homework assignments are required to be \nsubmitted individually through Moodle. Each student must complete the homework assignments \non their own.Assessment criteria: Successfully solves the stated problem with computational \nefficiency. Code demonstrates conciseness, clarity, and adherence to a functional programming \nstyle.Task 3: Take-home assignment (10%)Grading scheme: 20 points (0-20)Objectives: \nUnderstand AVL trees and analyze the worst-case time complexity of each \noperation.Assessment rules: Homework assignments are required to be submitted individually \nthrough Moodle. Each student must complete the homework assignments on their \nown.Assessment criteria: Successfully solves the stated problem with computational efficiency. \nCode demonstrates conciseness, clarity, and adherence to a functional programming style. \nAdditionally, provides analysis of the run-time complexity of operations.Task 4: Take-home \nassignment (10%)Grading scheme: 20 points (0-20)Objectives: Understand and apply abstract \nconcepts of FP, namely monadsAssessment rules: Homework assignments are required to be \nsubmitted individually through Moodle. Each student must complete the homework assignments \non their own.Assessment criteria: Successfully solves the stated problem with computational \nefficiency. Code demonstrates conciseness, clarity, and adherence to a functional programming \nstyle.Task 5: Written exam (60%)Grading scheme: 20 points (0-20)Objectives: Evaluate the \nstudents\u2019 comprehension of the course\u2019s material.Assessment rules: Students are permitted to \nbring a single \u201ccheat sheet\u201d consisting of an A4-sized paper, on which they can include any \nnecessary notes. A minimum grade of 8/20 in the final written exam is required to pass the \ncourse.Assessment criteria: Each question has a stipulated mark clearly indicated on the \nexam.Task 6: Written exam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: \nStudents having failed the course may re-sit the final exam at a next exam session. The \nobjective is to reassess the students\u2019 comprehension of the course\u2019s material.Assessment rules: \nStudents are permitted to bring a single \u201ccheat sheet\u201d consisting of an A4-sized paper, on which \nthey can include any necessary notes. For re-sits, the exam constitutes 100% of the final \ngrade.Assessment criteria: Each question has a stipulated mark clearly indicated on the exam. \nNote \nCourse materials \n \nSyllabus\u2610Yes\u2612NoRemarks:Literature list\u2612Yes\u2610NoRemarks:[1] Programming in Haskell, 2nd \nEdition, by Graham Hutton. September 2016, Cambridge University Press, ISBN-13 \n978-1316626221.[2] Learn You a Haskell for Great Good!, by Miran Lipovaca.  April 2011, No \nStarch Press, ISBN-13 978-1593272838.Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3330 \n \n \n",
        "ALGORITHMS AND COMPLEXITY \nObjectives \nThis course presents fundamental algorithms and data structures that are required to solve \ncommon problems. The notion of computational complexity of algorithms is introduced, and \nmathematical techniques are presented to analyse the complexity of the algorithms presented in \nthe course. Finally, an introduction to problem complexity is given. \n \nCourse learning outcomes \nUpon completion of this course the student should be able to:- design and analyse an algorithm \nfor a given problem- evaluate the computational complexity of an algorithm- reason about the \ncorrectness of an algorithm- classify an algorithm according to the basic approach it uses \nDescription \n\u2013 Algorithms, and complexity, upper and lower bounds- Elementary data structures:  lists, \nstacks, queue, sets- Advanced data structures: trees and graphs- Sorting- Searching- Hashing \n\u2013 Trees, and algorithm on Trees(binary search trees and (quasi)-balanced trees)- Graphs, and \nalgorithms on Graphs(depth-first search Prim\u2019s and Dijkstra\u2019s algorithms)9. Complexity theory: \nP, NP, NP completeness10. (if time) Algorithm on secondary memory \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Written final exam \n(50%)Grading scheme: 20 points (0-20)Objectives: Test the student\u2019s understanding of the \ncourse materialAssessment rules: The student has to answer questions with pencil and paper. \nThis is a closed-book exam. No cheat sheet allowed.Assessment criteria: The student must \nanswer the stipulated questions in a way that clearly demonstrates understanding of underlying \nconcepts.Task 2: Active participation \u2013 6 Quizzes in Class (30%)Grading scheme: 20 points \n(0-20)Objectives: To track and test the student\u2019s understanding for each topic.Assessment rules: \nThe student must answer questions with pen/pencil. Each quiz will be 10 minutes. No cheat \nsheet allowed.Assessment criteria: The student must answer the stipulated questions in a way \nthat clearly demonstrates understanding of underlying conceptsTask 3: Take-home assignment \n\u2013 2 Assignments (20%)Grading scheme: 20 points (0-20)Objectives: Check the abilities of the \nstudents in analytic thinking and in group collaborationAssessment rules: The assignments are \ngroup based. For each assignment there will be a weekly track where each member must write \nhis/her related task in this worksheet. Assessment criteria: Students must be separated into \nseveral groups. Evaluation will be individual.Task 4: Written exam \u2013 RETAKE (100%)Grading \nscheme: 20 points (0-20)Objectives: Test the student\u2019s understanding of the course \nmaterialAssessment rules: The student has to answer questions with pencil and paper. This is a \nclosed-book exam. No cheat sheet allowed.Assessment criteria: The student must answer the \nstipulated questions in a way that clearly demonstrates understanding of underlying concepts. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on Moodle.Literature list\u2610Yes\u2612NoRemarks:Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3331 \n \n \n",
        "BACHELOR SEMESTER PROJECT 3 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following. \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself. The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum. \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Final report and \nin-person presentation (100%)Grading scheme: 20 points (0-20)Objectives: Assess the quality \nand quantity of work done during the semester.Assessment rules: Time constrained \nsubmissions.Assessment criteria: The detailed criteria are specific to each project subject and \napplied on the following weighted deliverables:\u2022technical & scientific quality of the final report, \nprimary language (60%)\u2022technical & scientific quality of the final in-person presentation, primary \nlanguage (30%)\u2022technical & scientific quality of the final report, secondary language summary \n(5%)\u2022technical & scientific quality of the final in-person presentation, secondary language \nsummary (5%)Task 2: RETAKE 20 points (100%)Grading scheme: 20 points (0-20)Objectives: \nOption to repeat a previously failed project (with a final assessment of <10 points) with the same \ntopic and under the same supervisor.Assessment rules: The same deliverables as for the \npreviously failed project must be resubmitted under the given time constraints.Assessment \ncriteria: Same as for Task 1. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageLiterature \nlist\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3334\n \n",
        "4th Semester \nPRACTICAL FUNCTIONAL PROGRAMMING \nObjectives \nHaskell is a modern programming language with a rich type system and many advanced \nfeatures that allow efficient, fast and reliable solutions of extremely complex programming tasks. \nHaskell is currently being increasingly adopted by industry and open-source programmers, with \napplications ranging document conversion, cryptography and cryptocurrency protocols, \nhardware design, web services and microservices, proof management and high-reliability \ncomputing, and compiler construction.  The main aim of the course is to utilize the functional \nprogramming fundamentals from the previous courses in a practical environment, showing how \nto utilize the advanced concepts to vastly simplify practical programming tasks. The course \nspecifically focuses on utilizing typed functional programming constructions for solving tasks \nthat are extremely laborious and error-prone with the current mainstream programming practice.  \nThe course consists mainly of lectures, which are supplemented by individual work of the \nstudents on the 3 homework assignments.   \n \nCourse learning outcomes \nAt the end of the course the student will be able to:  \n \nBecome productive with Haskell, using it to fulfil day-to-day programming tasks,  \n \nUse functional programming in Haskell for industry-related use-cases including systems \nprogramming, network and web applications, and game programming,  \n \nUnderstand the practical importance, implementation, and main limitations of the type-inference \nin programming languages, and  \n \nUtilize advanced functional concepts in their programs and in other languages (such as Scala \nand PureScript), including monads and monad transformers, lenses, PEG parsers and AST \nprocessing techniques.\u202f \nDescription \nThe following topics are covered in the course: Overview of Haskell syntax and semantics\u202f \nOverloading via type classes and the use of most common type classes (Monoid, FAM, \ncontainer classes, number hierarchy, \u2026)\u202f Use of functions as data objects, simulating global \nstate using functions and monads Parsec-style parsing combinators\u202f Haskell infrastructure \u2013 \ncabal, Prelude\u202f Container libraries in Haskell, and a brief overview of functional data structures\u202f \nUsual compilation pipeline of lazy functional programs, a brief overview of Haskell type \nsystem\u202fCurry-Howard correspondence\u202f Monad transformers\u202f Functional references and optics\u202f \nHaskell libraries for text processing\u202f Systems programming interface of Haskell (IO), concurrent \nand parallel programming\u202f Web applications (backend applications and API endpoints, \nmiddleware, HTML generators, Front-end programming)\u202f Processing and generating graphics \nwith Haskell\u202f Selection of debugging, testing and benchmarking libraries; property testing\u202f Tools \nfor implementing extensible data structures: Higher-order abstract syntax & higher-kinded data, \n",
        "tagless & final interpreters, free monads, Selective functors, \u201cScrap Your Boilerplate\u201d approach \nand generics.  \nAssessment \nAssessment modality: Combined assessmentAssessment tasks \n \nTask 1: Take-home assignment\u200b (40%)Grading scheme: 20 points (0-20)Objectives: 3 homework \nassignments will be given for individual implementation by students. The assignments will \nprovide practical grounds for exercising the material from the lectures, and the tasks will serve \nas a common base for the exam questions. Assessment rules: The students submit their \nsolutions via Moodle within the specified deadline, following the submission specification given \nat the lectures and in Moodle. Submissions are expected to be formatted as a Cabal package. \nSubmissions that are mangled, unreadable, delayed beyond the deadline, or visibly do not \nadhere to submission criteria will not be evaluated. In case the authorship of the solutions is \nquestionable (e.g., solution seems to be copied from other students or generated from language \nmodels), all affected submitted solutions will be scored with 0 points. Assessment criteria: The \nsolutions will be evaluated on delivering the required functionality and suitable programming \nstyle (terseness, use of the recommended language features). Exact required goals will be \nlisted in Moodle. Task 2: Written exam\u200b (60%)Grading scheme: 20 points (0-20)Objectives: \nAssessing the understanding of the course matter by students by solving several very simple \nprogramming tasks. Assessment rules: The student solves several simple tasks on paper. The \ntasks may include 1) practical use of the Haskell type system 2) finding problems or \nimprovement opportunities in existing Haskell code using the knowledge of Haskell libraries 3) \nwriting short code snippets that solve given simple tasks.  All tasks will be selected from the \ntasks that the students should have already seen or solved during their work on the homework \nassignments.  The students may bring and use any resource printed on paper, including \nprepared cheatsheets, solutions of the homework assignments, and Haskell programming \nbooks, but no communication or use of any kind of computer is permitted Assessment criteria: \nThe provided solutions of the tasks must be correct. Problems in answers that typically occur \nwhen programming on paper (such as small problems with code types, easily fixable syntax \nissues, or exact library function names) will not have impact on the evaluation unless if present \nin amounts that hamper the assessment of correctness.  \u200b  Task 3: RETAKE (60%)Grading \nscheme: 20 points (0-20)Objectives: A student who has failed the course is allowed to sit to the \nnext exam call. The objectives are the same as Task 2. The mark the student got from the \nassessment Task 1 is kept.\u200b Assessment rules: Idem to Task 2. Assessment criteria: Idem to \nTask 2.   \nNote \nCourse materials Syllabus \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: Available on Moodle. Literature list \u200b\u2612\u200bYes\u200b\u2610\u200bNo \nRemarks: Learn You A Haskell For Great Good (updated version, \nhttps://learnyouahaskell.github.io/ )  Real World Haskell (updated version, \nhttps://github.com/tssm/up-to-date-real-world-haskell ) Haskell Wikibook \n(https://en.wikibooks.org/wiki/Haskell )  What I Wish I Knew When Learning Haskell \n(https://github.com/sdiehl/wiwinwlh ) Moodle page \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: TBD \n \n",
        "INFORMATION MANAGEMENT 2 \nObjectives \nThis course is a follow up, of IM1. Therefore, the overall objectives of the course remain the \nsame as its predecessor, but with a deeper and stronger level of exposition. \n \nCourse learning outcomes \nAt the end of the course, students will be able to: \n \n\u2013          design of relational database management systems (RDBMs) \n \n\u2013          understand and apply know how different index and storage structures are implemented. \n \n\u2013          Understand and apply how queries are optimized and processed. \n \n\u2013          Understand how multi-user concurrency control works in modern DBMSs. \n \n\u2013        Understand and apply logical query languages like Datalog to query databases \nDescription \n1. Data Storage 1.1 Datatypes in SQL 1.1.1 Fixed-Length Datatypes 1.1.2 Variable-Length \nDatatypes 1.2 Records 1.2.1 Fixed-Length Records 1.2.2 Variable-Length Records 1.3 Blocks & \nAddressing 1.4 Data Modifications 1.5 Five-Minute Rule 2. Indexing 2.1 Primary Indexes vs. \nSecondary Indexes 2.2 B+ Trees 2.3 Hashing-based Indexes 2.3.1 Extensible Hashing 2.3.2 \nLinear Hashing 2.4 Multi-Dimensional Indexes 2.4.1 KD Trees 2.4.2 Quad Trees 3. Query \nOptimization 3.1 Physical Query Operators 3.1.1 External Sorting 3.1.2 Joins (Nested Loops, \nMerging, Hashing) 3.2 Cost Models for Query Optimization 3.3 Join-Order Optimization & \nDynamic Programming 4. Concurrency Control 4.1 Transactions 4.1.1 Acid Properties of \nTransactions 4.1.2 Schedules & Serializability 4.2 Transaction Manager 4.2.1 Types of Conflicts \n4.2.2 Conflict Resolution 4.2.3 Conflict-Serializability 4.3 2-Phase Locking 4.4 Optimistic \nConcurrence Control 5. Datalog 5.1 Non-Recursive Datalog: Syntax & Interpretation 5.1.2 \nEvaluation Strategies 5.1.3 Safe Rules 5.1.4 Relationship to Relational Algebra 5.2 Recursive \nDatalog 5.2.1 Evaluation Strategies (Na\u00efve vs. Semi-Naive) 5.2.2 Recursion in SQL 5.2.3 \nNegation & Stratifiability 6. Data Warehousing (OLAP vs. OLTP) 6.1. OLAP Schemas (Fact vs. \nDimension Tables) 6.2 Data Cubes 6.3 Business Intelligence 6.3.1 Frequent Itemset Mining \n6.3.2 A-Priori Algorithm in SQL \nAssessment \nAssessment modality:  \n \n Combined assessment \n \nAssessment tasks \n \nTask 1:  Written or oral midterm exam (50%)Grading scheme: 20 points (0-20)Objectives: \nReproduction and application of the course contentsAssessment rules: Open book written exam \n(whole class) or 30 minutes individual oral exam.Assessment criteria: Exam results are based \n",
        "on the correctness of the provided answers.  Task 2: Written or oral final exam (50%)Grading \nscheme: 20 points (0-20)Objectives: Reproduction and application of the course \ncontentsAssessment rules: Open book written exam (whole class) or 30 minutes individual oral \nexam.Assessment criteria: Exam results are based on the correctness of the provided \nanswers.Task 3: Active participation \u2013 Presentation of exercise solutions \u2013 Up to 2 bonus \npointsGrading scheme: 20 points (0-20)Objectives: Solution of exercise problemsAssessment \nrules: A correct presentation (in class) of the solution to one problem of an exercise sheet yields \none bonus point. Up to two bonus points can be achieved per student this way per semester. \nBonus points are added on top of the points the student has achieved through the exams. At \nmost 20 points can be achieved in altogether.Assessment criteria: Correctness of the provided \nsolutions.Task 4: Written RETAKE exam (100%)Grading scheme: 20 points (0-20)Objectives: \nReproduction and application of the course contentsAssessment rules: Closed book written \nexam (whole class) or 30 minutes individual oral exam.Assessment criteria: Solution of exercise \nproblems \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nDatabase Systems: The Complete Book (ISBN: 978-0131873254) \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3576 \n \nOther, please specify: \n \n \n",
        "PROGRAMMING FUNDAMENTALS 4 \nObjectives \nProgramming languages are a key instrument in computer science: they are used to write \nprograms executed by a computer either through compilation or interpretation. They provide \nprogrammers with different abstraction mechanisms that enable rapid (and reliable) software \ndevelopment, while hiding the complexity of the underlying hardware. In general, they can be \nseen as communication tools not only to communicate with computers but also with humans. \nThe objective of this course is to help students understand the concepts underlying the main \nprogramming languages, as well as their capabilities and limitations. \n \nCourse learning outcomes \nAt the end of the course, students will be able to:\u2022Understand the most common programming \nlanguage paradigms.\u2022Explain the main concepts of programming languages.\u2022Implement the \nmain features of a programming language (e.g., type inference)\u2022Analyse the features of a new \nprogramming language.\u2022Select the most suitable programming language for a new project. \nDescription \nCourse content 1. Introduction, history of programming languages 2. Programming Language \nConcepts 3. Lambda calculus 4. Binding, Parameter passing modes, 5. The Algol family of \nlanguages 6. ML 7. Types systems and type inference 8. Scope, Functions, and Storage \nManagement 9. Control structures and exceptions 10. Modularity and abstraction 11. Object \nOrientation 12. Concurrent Programming 13. Summary and Review   \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(60%)Grading scheme: 20 points (0-20)Objectives: Assessing the students\u2019 understanding of \nthe main concepts presented in the lectures and their capability to solve some exercises based \non the algorithms presented in class.Assessment rules: The use of documents (including books \nand notes) is not authorized. The use of electronic devices is not authorizedAssessment criteria: \nCorrectness of the answersTask 2: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Programming exercises to show the students can implement fundamental \nalgorithms of programming language designAssessment rules: Use of generative AI \ntechnologies must be disclosed upon submission; the prompts used to get the results should be \nincluded in the submission. Late submissions are penalized by 50% (<24h), 75% (>=24h and < \n48h), 100% (>=48h)Assessment criteria: Correctness of the program functionality, overall \nprogram design, coding style.Task 3: Presentation (20%)Grading scheme: 20 points \n(0-20)Objectives: By the end of the course, the student should be able to analyse the features of \na previously unknown programming language.Assessment rules: Each student will be asked to \npresent the main concepts of a programming language chosen from a list proposed by the \ninstructor.Assessment criteria: Depth and breadth of the presentation, quality of the visual \nsupport (slides)Task 4: Retake (60%)Grading scheme: 20 points (0-20)Objectives: A student \nmay retake the written exam. No resitting is foreseen for the take-home assignments and the \nfinal presentation.Assessment rules: Same as task 1 Assessment criteria: Same as task 1  \nNote \nSyllabus \n \n",
        "\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nConcepts in programming languages /John C. Mitchell. 2003. Cambridge University \nPress.Available on A-Z.lu \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=6843 \n \n",
        "THEORETICAL COMPUTER SCIENCE 2 \nObjectives \nThe course aims to provide the students an introduction to formal methods and basic concepts, \ntheories, logics, and verification algorithms for automata-based model checking. \n \nCourse learning outcomes \nAfter the course, the students will be able to:-model computer systems as transition \nsystems,-understand what types of properties can be specified on the transition system, \n-formalise such properties in logics (LTL and CTL), -verify whether a transition system satisfies a \nproperty written as a logic formula. \nDescription \nModelling computer systems as transition systems (hardware circuits, sequential programs, \nconcurrency and communication, shared variables, message-passing, channel \nsystems).Linear-time properties (invariants, safety, liveness, and fairness).Regular safety \nproperties, Buchi automata, omega-regular properties.Linear temporal logics (syntax, \nsemantics, equivalence).LTL model checking algorithms.Computation tree logic (syntax, \nsemantics, equivalence).CTL model checking algorithms. \nAssessment \nAssessment modality:  \n \n  Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam (40%)Grading scheme: 20 points (0-20)Objectives: The students have \nfulfilled the objectives of the course.Assessment rules: The students should perform the exam \nindependently by themselves.Assessment criteria: Quality of the submitted exam.Task 2: \nTake-home assignment (40%)Grading scheme: 20 points (0-20)Objectives: The students can \napply the course materials to finish the assignments/homework.Assessment rules: The students \nshould perform the assignments independently by themselves. Assessment criteria: Quality of \nthe submitted assignments/homework.Task 3: Attendance (20%)Grading scheme: 20 points \n(0-20)Objectives: The students need to be present at the classes in order to understand the \nbasic concepts, theories and verification algorithms.Assessment rules: Be present at both \nlectures and practical sessions. Otherwise, inform the teachers about the reasons of absence. \nAssessment criteria: Be present and active at both lectures and practical sessions.Task 4: \nWritten RETAKE exam (100%)Grading scheme: 20 points (0-20)Objectives: The students have \nfulfilled the objectives of the course.Assessment rules: The students should perform the exam \nindependently by themselves.Assessment criteria: Quality of the submitted exam. \nNote \nSyllabus \n \n\u2610Yes  \u2612No \n \nRemarks: \n",
        " \n  \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nBaier, C., Katoen, J. (2008). Principles of Model Checking. United Kingdom: MIT Press. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3577 \n \nOther, please specify: \n \n \n \n",
        "PROGRAMMING LANGUAGES \nObjectives \nThis course aims to make you understand programming language implementation and formal \nlanguage processing in an as easy as possible way through concrete examples. It will guide you \nthrough all the main phases of the design and the implementation of an interpreter and/or \ntraditional compiler \n \nCourse learning outcomes \nThe course aims to enable you to design and implement compilers and similar language \nprocessing tools. To be able to design and implement interpreters and compilers will:\u2022make you \na better programmer as you will better understand a language\u2019s intricacies. \u2022make you a better \ncomputer scientist, because programming technologies span so many areas of the discipline, \nincluding formal language theory, grammars, computability, and semantics all the advanced \nconcepts in modern programming languages.\u2022allow you to practice principles and tools seen in \nprevious semesters, as interpreters and compilers are generally large and complex software.\u2022let \nyou get very quickly into the business of implementing a programming language and running \nprograms written in it. \nDescription \nCode Generation Techniques/Schemes for Imperative as well as Object-Oriented Languages, \nLexing, Lexer Generation, Parsing, Parser Generation, Static (Code) Analysis, Compiler \nOptimizations, SCADE/Lustre. \nAssessment \nAssessment modality:  \n \n Continuous assessment \n \nAssessment tasks:  \n \nTask 1: Take-home assignment (20%)Grading scheme: 20 points (0-20)Objectives: Code \nGenerationAssessment rules: All auxiliary materials allowed, but no group work. Assessment \ncriteria: Code generation follows strict translation schemes. This task requires you to apply \nthese schemes to a C program to yield a semantically equivalent assembly program. Submitted \nhomework (code) is graded based on whether the required translation schemes have been \ncorrectly applied. Task 2: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Lexing and Lexer Generation: Formally specify tokens and token classes and \nconstruct a lexer for these tokens / token classesAssessment rules: All auxiliary materials \nallowed, but no group work. Assessment criteria: Lexer generation follows a sequence of \nwell-defined transformations/algorithms. Grading is based on whether these algorithms have \nbeen correctly applied and whether the tokens themselves have been correctly specified using \nregular expressions.Task 3: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Top-Down Parsing and Parser Generation: Construct a recursive descent \nparser and an LL parser for given context-free grammarsAssessment rules: All auxiliary \nmaterials allowed, but no group work. Assessment criteria: Top-down parser generation yields \nan action table (LL) or method implementations (RD). The grade is determined by the \n",
        "correctness of the action table and correctness and coding style of the methods, \nrespectively.Task 4: Take-home assignment (20%)Grading scheme: 20 points (0-20)Objectives: \nBottom-Up Parsing and Parser Generation: Construct an LR parser for a given context-free \ngrammarAssessment rules: All auxiliary materials allowed, but no group work. Assessment \ncriteria: Bottom-up parser are given by an action and goto tables (LR), as an intermediate step a \nso-called Item PDA may be generated. The grade is determined by the \ncorrectness/completeness of this automaton and the correct derivation of the action/goto table \nfrom the automaton.Task 5: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Static Program Analysis: Design/definition of a sound static \nanalysisAssessment rules: All auxiliary materials allowed, but no group work. Assessment \ncriteria: Sound static program analyses are defined by a complete lattice (of potential analysis \nresults), edge effects for the various code constructs, a MOP definition, etc. The grade is \ndetermined by the correctness (soundness and applicability) of your definitions for an \nappropriate lattice/MOP, edge effects etc. \nNote \nSyllabus \n \n\u2610Yes  \u2612No \n \nRemarks: \n \n  \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nLecture slides contain up-to-date literature list. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3578 \n \nOther, please specify: \n \n \n",
        "INTELLIGENT SYSTEMS 1 \nObjectives \nThis course aims to offer a foundation, ideas, and techniques underlying the design of intelligent \nagents and their application in various real-world domains. Also, it offers different ways of \nsystem implementations with \u201cintelligent\u201d functionality through statistical and decision-theoretic \nmodelling paradigms where agents will draw inferences in uncertain environments and optimize \nactions for arbitrary reward structures. Students will learn to recognize when intelligent \nfunctionality and artificial intelligence may be a good solution to a problem and to select \nappropriate AI methodologies and strategies. Further, they will acquire knowledge enabling \nthem to develop the necessary skills to design and implement an intelligent system. \n \nCourse learning outcomes \nLearning outcomesAt the end of the course, students will be able to:\u2022Describe the concept of \nsingle/multi-agent systems and their implementations.\u2022Model various search algorithms with \ndifferent problem types.\u2022Determine the most adequate search solution/algorithm in each \nproblem scenario.\u2022Design autonomous agents that efficiently make decisions in fully informed, \npartially observable, and adversarial settings. \nDescription \nThe course covers the following topics:1. Fundamental Issues1.1. Overview of AI problems, \nexamples of successful recent AI applications.1.2. What is intelligent behavior? The Turing test, \nRational versus non-rational reasoning.1.3. Problem characteristics: Fully versus partially \nobservable, Single versus multi-agent, Deterministic versus stochastic, Static versus dynamic, \nDiscrete versus continuous.1.4. Nature of agents: Autonomous versus semi-autonomous, \nReflexive, goal-based, and utility-based, the importance of perception and environmental \ninteractions.1.5. Philosophical and ethical issues. 2. Basic Search Strategies2.1. Problem \nspaces (states, goals and operators), problem solving by search.2.2. Factored representation \n(factoring state into variables).2.3. Uninformed search (breadth-first, depth-first, depth-first with \niterative deepening).2.4. Heuristics and informed search (hill-climbing, generic best-first, A*).2.5. \nSpace and time efficiency of search.2.6. Two-player games (introduction to minimax \nsearch).2.7. Constraint satisfaction (backtracking and local search methods.3. Basic Machine \nLearning3.1. Definition and examples of broad variety of machine learning tasks, including \nclassification.3.2. Inductive learning.3.3. Simple statistical-based learning, such as Naive \nBayesian Classifier, decision trees.3.4. The over-fitting problem.3.5. Measuring classifier \naccuracy. \nAssessment \nAssessment modality:  \n \n  Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam\u200b (40%)Grading scheme: 20 points (0-20)Objectives: \u200bTo assess the \nstudent\u2019s comprehension of the taught topics during the lecture part of the course. \u200b Assessment \nrules: Devices of any kind are not allowed; it is a closed-book exam.\u200b Assessment criteria: The \n",
        "exam contains several questions with a preset marking scheme and marks distribution for each \nquestion.\u200b Task 2: \u200bTake-home assignment\u200b (40%)Grading scheme: 20 points (0-20)Objectives: To \nassess students\u2019 psychomotor skills in implementing and designing intelligent agents throughout \nthe training sessions.\u200b Assessment rules: \u200bAll resources are allowed\u200b Assessment criteria: Project \nwork / Assignment reports\u200b Task 3: Active participation\u200b (20%)Grading scheme: 20 points \n(0-20)Objectives: To encourage the students to be involved in the discussions and critical \nthinking during both lecture and training sessions.  \u200b Assessment rules: N/A Assessment criteria: \nAttendance and question answering throughout lecture and training sessions.  Task 4: Written \nRETAKE exam\u200b (100%)Grading scheme: 20 points (0-20) Objectives: Retake the course in case \nof failure or missing the written exam  \u200b Assessment rules: \u200bDevices of any kind are not allowed; it \nis a closed-book exam.\u200b Assessment criteria: \u200bThe exam contains several questions with a preset \nmarking scheme and marks distribution for each question.\u200b  \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nArtificial Intelligence: A Modern Approach (Prentice Hall Series in Artificial Intelligence) by Stuart \nRussell and Peter Norvig http://aima.cs.berkeley.edu/ \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3579 \n \n",
        "BACHELOR SEMESTER PROJECT 4 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following.  \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself.  The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum  \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project.  \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Final report and in-person presentation (100%)Grading scheme: 20 points (0-20) \nObjectives: Assess the quality and quantity of work done during the semester. Assessment \nrules: Time constrained submissions. Assessment criteria: The detailed criteria are specific to \neach project subject and applied on the following weighted deliverables: technical & scientific \nquality of the final report, primary language (60%) technical & scientific quality of the final \nin-person presentation, primary language (30%) technical & scientific quality of the final report, \nsecondary language summary (5%) technical & scientific quality of the final in-person \npresentation, secondary language summary (5%) Task 2: RETAKE (100%)Grading scheme: 20 \npoints (0-20Objectives: Option to repeat a previously failed project (with a final assessment of \n<10 points) with the same topic and under the same supervisor. Assessment rules: The same \ndeliverables as for the previously failed project must be resubmitted under the given time \nconstraints. Assessment criteria: Same as for Task 1.   \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \n",
        "Literature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3581\n \n",
        "5th Semester \nCOMPUTATIONAL SCIENCE \nObjectives \nNumerous problems in engineering, physical and economical industries and application \ndomains essentially boil down to minimising a single function: the objective function in \noptimization terminology. Minimisation is not only the basis of many simulation tools, but also \nthe basis of many parameter identification approaches. Unfortunately, there is not one \nminimisation method that outperforms the others. In this module, the student will therefore \nbecome familiar with three numerical minimisation techniques, each with its own advantages \nand disadvantages. Furthermore, three ways to deal with constraints in minimisation problems \nwill be considered, also each with its own advantages and disadvantages. The student will \nimplement the minimisation techniques herself/himself in a programming language of her/his \nchoice, hereby effectively implementing her/his own simulations. In this way, the student will \ntruly be exposed to the methods\u2019 advantages and disadvantages, and she/he will capture the \nrelevant technical complexities of the methods. Thus, the aim of the module is to teach the \nstudent a variety of unconstrained and constrained minimisation approaches and understand \ntheir beneficial and disadvantageous differences. \n \nCourse learning outcomes \nAt the end of the course, the student will be able to:\u2022Understand and be able to work with \ndescent methods. \u2022Understand and be able to work with Newton\u2019s method in optimization.  \n\u2022Understand and be able to work with quasi-Newton methods in optimization. \u2022Understand and \nbe able to incorporate constraints in objective functions using substitution. \u2022Understand and be \nable to incorporate constraints in objective functions using the penalty method. \u2022Understand and \nbe able to incorporate constraints using the method of Lagrange multipliers.  \nDescription \n1. Descent methods: steepest descent method, line search using the Armijo rule, conjugate \ngradient method, compute multivariate derivatives, implement the methods.2. Newton\u2019s method: \nCompute multivariate second-order derivatives, solve linear systems, implement the method.3. \nQuasi-Newton methods: line search using the Wolfe conditions, implement the BFGS method \nand the L-BFGS method.4. Implement constraints in previous unconstrained objective functions \nusing substitution.5. Implement constraints in previous unconstrained objective functions using \nthe penalty method.6. Implement constraints in previous unconstrained objective functions using \nthe method of Lagrange multipliers. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Written exam \n(20%)Grading scheme: 20 points (0-20)Objectives: Assess the student\u2019s understanding of (1) \ndescent methods and (2) Newton\u2019s method.Assessment rules: The lecture notes and even the \ninternet may be used. However, any means of communication is forbidden.Assessment criteria: \nThe student must use its own implementations, made during the semester, to calculate some \nminimization problems. Open questions may also be posed, which require a textual \nresponse.Task 2: Written exam (20%)Grading scheme: 20 points (0-20)Objectives: Assess the \nstudent\u2019s understanding of (3) quasi-Newton methods.Assessment rules: The lecture notes and \neven the internet may be used. However, any means of communication is \n",
        "forbidden.Assessment criteria: The student must use its own implementations, made during the \nsemester, to calculate some minimization problems. Open questions may also be posed, which \nrequire a textual response.Task 3: Written exam (60%)Grading scheme: 20 points \n(0-20)Objectives: Assess the student\u2019s understanding of (1) descent methods, (2) Newton\u2019s \nmethod, (3) quasi-Newton methods, (4) constraint incorporation using substitution, (5) constraint \nincorporation using the penalty method, (6) constraint incorporation using the method of \nLagrange multipliers.Assessment rules: The lecture notes and even the internet may be used. \nHowever, any means of communication is forbidden.Assessment criteria: The student must use \nits own implementations, made during the semester, to calculate some minimization problems. \nOpen questions may also be posed, which require a textual response.Task 4: Written exam \u2013 \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Assess the student\u2019s \nunderstanding of (1) descent methods, (2) Newton\u2019s method, (3) quasi-Newton methods, (4) \nconstraint incorporation using substitution, (5) constraint incorporation using the penalty \nmethod, (6) constraint incorporation using the method of Lagrange multipliers.Assessment \nrules: The lecture notes and even the internet may be used. However, any means of \ncommunication is forbidden. In principle, again the resit exams consist of 2 midterm exams and \none final exam \u2013 with the same weights for the final grade as for the standard \nexams.Assessment criteria: The student must use its own implementations, made during the \nsemester, to calculate some minimization problems. Open questions may also be posed, which \nrequire a textual response. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on the Moodle page.Literature \nlist\u2612Yes\u2610NoRemarks:Lecture notes are provided by the instructor.Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=4194 \n \n",
        "SOFTWARE ENGINEERING 1 \nObjectives \nSoftware engineering is the discipline concerned with the application of theory, knowledge, and \npractice to effectively and efficiently build reliable software systems that satisfy the requirements \nof customers and users. This discipline is applicable to small, medium, and large-scale systems.  \nIt encompasses all phases of the lifecycle of a software system, including requirements \nelicitation, analysis and specification; design; construction; verification and validation; \ndeployment; and operation and maintenance.\u201d [ACM/IEEE-CS Joint Task Force on Computing \nCurricula. 2013. Computer Science Curricula 2013. ACM Press and IEEE Computer Society \nPress. DOI: http://dx.doi.org/10.1145/2534860].  \n \nThe objectives of this course are to provide knowledge on the discipline such that the student \nunderstands the main aspects of it. The course focuses on software processes, project \nmanagement, quality standard and requirements engineering for a deep understanding of this \ndevelopment phase. \n \nCourse learning outcomes \nAt the end of the course, the student will be able to:\u2022LO1/(MF) Apply consistent documentation \nand program style standards that contribute to the readability and maintainability of software. \n\u2022LO2/(M) Describe the relative advantages and disadvantages among several major process \nmodels (e.g., waterfall, iterative, and agile).\u2022LO3/(M) Describe the different practices that are \nkey components of various process models.\u2022LO4/(M) Differentiate among the phases of \nsoftware development.\u2022LO5/(M) Explain the concept of a software lifecycle and provide an \nexample, illustrating its phases including the deliverables that are produced.\u2022LO6/(M) Compare \nseveral common process models with respect to their value for development of classes of \nsoftware systems taking into account issues such as requirement stability, size, and \nnon-functional characteristics.\u2022LO7/(M) Define software quality and describe the role of quality \nassurance activities in the software process.\u2022LO8/(M) Describe the intent and fundamental \nsimilarities among process improvement approaches.\u2022LO9/(M) Use project metrics to describe \nthe current state of a project.\u2022LO10/(M) Using a particular software process, describe the \naspects of a project that need to be planned and monitored, (e.g., estimates of size and effort, a \nschedule, resource allocation, configuration control, change management, and project risk \nidentification and management). \u2022LO11/(MF) Track the progress of some stage in a project \nusing appropriate project metrics. \u2022LO12/(MF) List the key components of a use case or similar \ndescription of some behaviour that is required for a system.\u2022LO13/(M) Describe how the \nrequirements engineering process supports the elicitation and validation of behavioural \nrequirements. \u2022LO14/(MF) Interpret a given requirements model for a simple software \nsystem.\u2022LO15/(M) Describe the fundamental challenges of and common techniques used for \nrequirements elicitation. \u2022LO16/(MF) List the key components of a data model (e.g., class \ndiagrams or ER diagrams).\u2022LO17/(MF) Identify both functional and non-functional requirements \nin a given requirements specification for a software system.\u2022LO18/(MF) Conduct a review of a \nset of software requirements to determine the quality of the requirements with respect to the \ncharacteristics of good requirements. \u2022LO19/(MF) Apply key elements and common methods for \nelicitation and analysis to produce a set of software requirements for a medium-sized software \n",
        "system.\u2022LO20/(MF) Use a common, non-formal method to model and specify the requirements \nfor a medium-size software system.\u2022LO21/(MF) Translate into natural language a software \nrequirements specification (e.g., a software component contract) written in a formal specification \nlanguage. \u2022LO22/(MF) Create a prototype of a software system to mitigate risk in requirements. \n\u2022LO23/(MF) Understand and apply the Messir requirement engineering to a small size \napplication development process.\u2022LO24/(M) Understand and apply the Messir use-case model \nin the context of the development methodology.\u2022LO25/(M) Understand and apply the Messir \nenvironment model in the context of the development methodology.\u2022LO26/(MF) Understand and \napply the Messir concept model in the context of the development methodology.\u2022LO29/(F) \nUnderstand and apply the UML use-case diagram.\u2022LO30/(F) Understand and apply the UML \nsequence diagram.\u2022LO31/(MF) Understand and apply the UML class diagram.\u2022LO32/(MF) \nUnderstand and apply the Messir operation model at definition level in the context of the \ndevelopment methodology.\u2022LO33/(MF) Understand and apply the Messir operation model at \nspecification level in the context of the development methodology.Remark: the letter M indicates \nthat the learning outcome will be assessed at midterm exam, F at final exam assessment task, \nand MF at both). \nDescription \n\u2022 Program correctness: types of errors (syntax, logic, run-time), the concept of a specification, \ndefensive programming (e.g., secure coding, exception handling), code reviews, testing \nfundamentals and test-case generation, the role and the use of contracts (including pre- and \npost-conditions), unit testing.\u2022 Simple refactoring. \u2022 Modern programming environments: Code \nsearch, Programming using library components and their APIs.\u2022 Documentation and program \nstyle. \u2022 Introduction to software process models (e.g., waterfall, incremental, agile); activities \nwithin software lifecycles. \u2022 Programming in the large vs. individual programming. \u2022 Evaluation of \nsoftware process models. \u2022 Software quality concepts. \u2022 Process improvement. \u2022 Software \nprocess capability maturity models. \u2022 Software process measurements.\u2022 Software quality \nassurance and the role of measurements. \u2022 Release management. \u2022 Requirements analysis and \ndesign modelling tools.\u2022 Describing functional requirements using, for example, use cases or \nusers\u2019 stories. \u2022 Properties of requirements including consistency, validity, completeness, and \nfeasibility. \u2022 Software requirements elicitation.\u2022 Describing system data using, for example, class \ndiagrams or entity-relationship diagrams. \u2022 Non-functional requirements and their relationship to \nsoftware quality (cross-reference IAS/Secure Software Engineering).\u2022 Evaluation and use of \nrequirements specifications. \u2022 Requirements analysis modelling techniques.\u2022 Acceptability of \ncertainty/uncertainty considerations regarding software/system behaviour.\u2022 Prototyping. \u2022 Basic \nconcepts of formal requirements specification.\u2022 Requirements specification.\u2022 Requirements \nvalidation. \u2022 Requirements tracing. \u2022 System design principles: levels of abstraction \n(architectural design and detailed design).\u2022 Structural and behavioural models of software \ndesigns.\u2022 Relationships between requirements and designs: transformation of models, design of \ncontracts, invariants. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasks \n \nTask 1: Written exam \u2013 MIDTERM (40%)Grading scheme: 20 points (0-20)Objectives: Assess to \nwhich extend the targeted course learning outcomes have been acquiredAssessment rules: no \n",
        "document allowed \u2013 no electronic device allowedthe duration of the exam can be up to FOUR \nsuccessive hoursAssessment criteria: A set of questions are asked to the student on a subset of \nthe learning outcomes targeted by the assessment task (cf. learning outcomes). Task 2: Written \nexam \u2013 FINAL (60%)Grading scheme: 20 points (0-20)Objectives: Assess to which extend the \ncourse learning outcomes have been acquiredAssessment rules: no document allowed \u2013 no \nelectronic device allowed. The duration of the exam can be up to FOUR successive \nhoursAssessment criteria: A set of questions are asked to the student on a subset of the \ntargeted learning outcomes by the assessment task (cf. learning outcomes).Task 3: Written \nexam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Assess to which extend \nthe course learning outcomes have been acquired for a student having ALREADY FAILED \nONCE TO THE COURSE USING THE assessment tasks 1 AND 2.Assessment rules: no \ndocument allowed \u2013 no electronic device allowed. The duration of the exam can be up to FOUR \nsuccessive hoursAssessment criteria: A set of written questions are asked to the student in \norder to evaluate the acquisition level reached for a subset of the learning outcomes.The final \ngrade FOR THE Task3 \u2013 RETAKE assessment is computed as follows:- 40% the > MIDTERM \ngrade- 60% the grade of the RETAKE written questions answersThe MIDTERM assessment \ntask 1 can be re-executed by a redoing students only if the student registers to the course \nduring the WINTER semester. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageLiterature \nlist\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3916 \n \n",
        "INTRODUCTION TO IOT \nObjectives \nStudents will be equipped with competences for the development of applications for the Internet \nof Things (IOT):Know the challenges of IoT networks considering the various specificities and \napplication constraints (e.g. QoS, scalability, real-time application, operational safety, \netc.).Master the basics of IoT communication protocols (Application layer).Master the selection \nand implementation of different IoT communication protocols.Design, analyze and criticize \ndifferent data collection, storage and processing data architectures, both their possibilities and \ntheir limits.Design one or more IoT applications using machine learning modules based on the \ncollected data. \n \nCourse learning outcomes \nOn successful completion of this course, students are capable to:Define and develop the \nfunctional and technical specifications of a network and telecom equipment (hardware, software, \nimplementation, etc.).Determine architecture components, technologies, equipment, tools \nsupports and integrate them according to the specifications. \nDescription \nIntroduction to issues relating to the interoperability of IoT networks/protocols (application layer \n\u2013 OSI)Real-time networks: Profibus, Modbus, Modbus-TCPIOT protocols on application layer: \nHTTP (REST API), MQTT, CoAP, OneM2M, O-MI/O-DFNOSQL databases: MongoDB, \nElasticSearchGetting started with Node-Red (visual programming tool \u2013 open source \u2013 \ndeveloped by IBM) for IoT application development:data collection: Arduino, & sensors, Cloud \nAPI endpoints\u2026data storage: databases (SQL, NoSQL)data treatment: Node-Red \n(JavaScript)publication of data via dashboard (H2M) and machine interfaces (M2M): \nImplementation of an HTTP server (REST API specification, server deployment) \nAssessment \nFirst time students:40%: practical group project60%: final written examRepeating \nstudents:100% final written exam \nNote \nLiterature: Relevant literature will be provided during the lecture. \n \n",
        "HUMAN-COMPUTER INTERACTION (HCI) \nObjectives \nThe course provides students with a comprehensive understanding of the fundamental \nprinciples and concepts underlying Human-Computer Interaction, such as research methods, \nuser interfaces, or interaction techniques. \n \nCourse learning outcomes \n1.Understand fundamental HCI principles and their role in designing interactive \nsystems.2.Compare and contrast different user-centred design and research methodologies. \n \nRecognize the societal implications of HCI, including e.g. privacy, security, and accessibility. \nDescription \n1. Introduction1.1 Why is HCI challenging?1.2 Human-computer interaction as a field1.3 \nFundamental concepts1.4 Why HCI matters1.5 Our approach to HCI2. Understanding \npeople2.1 Types of understanding2.2 Areas of understanding2.3 Applying our understanding of \npeople2.4 Is a general understanding of people possible?3. Perception3.1 Sensory \nmodalities3.2 Elementary functions of perception in HCI3.3 Visual perception and attention3.4 \nPerception is an active process4. Motor Control4.1 Elements of a motor control task in HCI4.2 \nTarget Acquisition4.3 Simple Reactions4.4 Choice reaction4.5 Gesturing5. Cognition5.1 General \nFindings about Cognition5.2 Cognitive control5.3 Memory and Learning5.4 Reasoning and \nDecision-Making5.5 Simulating cognition in interactive tasks6. Needs and Motivations6.1 \nPsychological Needs6.2 Motivations6.3 Behavior Change6.4 Gamification7. Experience7.1 \nWhat is Experience?7.2 Types of Experience7.3 Assessing and Measuring Experience7.4 Can \nexperiences be designed?8. Collaboration8.1 Understanding collaboration8.2 Coordination8.3 \nGroup cognition8.4 Why collaborative systems fail9. Communication9.1 Beyond face-to-face \ncommunication9.2 Conversations9.3 Online behavior9.4 Social Networks and Online \nCommunities9.5 Computers as Communication Partners10. User Interfaces10.1 Definition and \nElements10.2 Interaction Styles10.3 Design Objectives10.4 Design Space Analysis11. Input \nDevices11.1 Principles of Sensing11.2 Keypads and Keyboards11.3 Pointing Devices11.4 \nUncertain Control11.5 Expanding the Limits of Sensing12. Displays12.1 Encoding and \nRendering12.2 Simple Displays12.3 Visual Displays13. Contents13.4 Audio13.5 Haptics13.6 \nEmerging Forms of Displays14. Interaction Techniques14.1 Objectives for Interaction \nTechniques14.2 Pointing techniques14.3 Selection and manipulation techniques14.4 Text \nentry14.5 Camera control14.6 Two perspectives: Control and Learnability15. Commands and \nNavigation15.1 Naming Objects and Actions15.2 Command-Line Interfaces15.3 Organizing \nInformation15.4 Menu User Interfaces15.5 Notational Systems15.6 Recognition versus \nRecall16. Graphical User Interfaces16.1 A Brief History of the GUI16.2 Design Objectives16.3 \nThe Principle of Direct Manipulation16.4 Anatomy of a Graphical User Interface16.5 Designing a \nGraphical User Interface16.6 Why do we still have GUIs?17. Reality-Based Interaction17.1 \nMobile User Interfaces17.2 Ubiquitous Computing17.3 Tangible User Interfaces17.4 Mixed \nReality17.5 Should we imitate reality or go beyond it? \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Assignments \n(40%)Grading scheme: 20 points (0-20)Objectives: Students will get familiarized with HCI \n",
        "research through readings of academic papers.Assessment rules: There will be a list of \nresearch papers available in Moodle. Every week, students must present one of those papers in \nfront of the class.  There will be a monthly or bi-monthly rotation, depending on the number of \nstudents enrolled in the course, which means that each student will present two or three papers \nin total.Assessment criteria: Each presentation will be graded using a 0\u201310-point scale and the \nfinal grade in this part will be the average grade of all presentations delivered by the student. \nStudents must get an average grade of at least 5 points (out of 10) in this part in order to qualify \nfor the final exam. If a student scores less that 5 points in this part, the final grade in the course \nwill be the minimum grade achieved in either the assignments or the final exam. Any form of \ncheating or plagiarism will be penalized with a grade of 0 in this part, which will make the \nstudent to fail the whole course. The grade in this part will be retained until the student passes \nthe final exam, unless the student decides to repeat it in the next academic year. There is no \nretaking option for this part within the same academic year, which means that a student who \nfails this part must enroll again in the course in the next academic year. Retaking students must \ninform the course responsible whether they want to keep their grade from the previous \nyear.Task 2: Final exam (60%)Grading scheme: 20 points (0-20)Objectives: Students will \ndemonstrate that they have acquired the required competencies according to the theory \ncovered in the course.Assessment rules: Only students who got at least 5 points in the \nassignments should take the final exam, otherwise they are advised to de-enrol from the final \nexam in order to avoid missing an official attempt. No supporting materials are allowed in the \nexam, i.e. no cheatsheet, no books, no mobile devices, no laptops, etc.Assessment criteria: The \nexam is a paper-based quiz with 20 questions that must be solved in 30 minutes. Each question \ncomes with 4 possible answers, among which only one is the right one. A student must get at \nleast 5 points (out of 10) in the final exam in order to pass the course. If a student scores less \nthat 5 points in this part, the final grade in the course will be the minimum grade achieved in \neither the assignments or the final exam. Any form of cheating or plagiarism will be penalized \nwith a grade of 0 in this part, which will make the student to fail the whole course.The grade in \nthis part will not be retained for the next year. Failing students can retake the exam in the next \nexamination period or enroll again in the course the next academic year. \nNote \nCourse materials \n \nSyllabus\u22a0Yes\u2610NoRemarks:Available on MoodleLiterature list\u22a0Yes\u2610NoRemarks:Reference \ntexbook:\u2022Kasper Hornb\u00e6k, Per Ola Kristensson, Antti Oulasvirta. Introduction to \nHuman-Computer Interaction. Oxford University Press. 2024.Moodle \npage\u22a0Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3917 Other, please \nspecify:Class attendance is expected for the practical sessions, otherwise the students will fail \nthe continuous evaluation. \n \n",
        "INTRODUCTION TO MACHINE LEARNING \nObjectives \nThis course introduces Machine Learning (ML) principles and its three main learning paradigms \n(supervised, unsupervised, and reinforcement learning). For each learning paradigm, it presents \nsome of its most typical foundational models and discuss them from the perspective of \nrepresentation, evaluation, and optimization. A special attention is given to a basic introduction \ninto deep learning techniques and generalization. The course mixes theoretical concepts with \nvanilla implementations of various ML models. \n \nCourse learning outcomes \nAt the end of the course the student will be able to:\u2022    define Machine Learning and differentiate \nthe terms AI, Machine Learning, and Deep Learning.\u2022    describe the differences among the \nthree Machine Learning paradigms: supervised, unsupervised, and reinforcement learning.\u2022    \ndetermine which of the three Machine Learning paradigms is appropriate to a particular type of \nproblems.\u2022    derive, implement, and evaluate some of the most typical Machine Learning \nmodels. \u2022    derive, implement, and evaluate some basic Deep Learning models and their \nlearning algorithms.\u2022    explain proper ML evaluation procedures, including the differences \nbetween training and testing performance.\u2022    apply Machine Learning models to real-world \nproblems.\u2022    identify overfitting in the context of a problem and describe solutions to overfitting.\u2022    \nevaluate the performance of a Machine Learning algorithm on a real-world dataset. \nDescription \nThe following topics are covered in the course:\u2022    Basics \u2013 ML Introduction \u2022    Basics \u2013 Data \npreparation for ML \u2022    Supervised Learning \u2013 Regression \u2022    Supervised Learning \u2013 \nClassification\u2022    Unsupervised Learning \u2013 Dimensionality reduction\u2022    Unsupervised Learning \u2013 \nClustering\u2022    Reinforcement Learning \u2013 Preliminaries\u2022    Reinforcement Learning \u2013 Basic \nmethods\u2022    Deep Learning \u2013 Learning Deep Representations\u2022    Deep Learning \u2013 Models\u2022    \nDeep Learning \u2013 Deep Reinforcement Learning\u2022    Generalization\u2022    Research \u2013 Glimpse on \nstate-of-the-art research\u2022    Engineering \u2013 ML and the real-world \nAssessment \no    Three take-home assignments \u2013 40% of the final grade in total split as follows: 10%, 10%, \nand 20%o    Written exam \u2013 60% of the final grade o    Students having failed the course will \nhave to retake the exam at the next exam session. This exam will count for 100% of the final \ngrade. \nNote \nLiterature:\u2022    Bishop, C.: Pattern Recognition and Machine Learning, 2006\u2022    Goodfellow, I., \nBengio, Y. & Courville, A.: Deep Learning, 2016\u2022    Sutton, R., Barto, A.: Reinforcement \nLearning: An Introduction, second edition, 2018\u2022    Hastie, T, Tibshirani, R. & Friedman, J.: The \nElements of Statistical Learning, 2009\u2022    Zhang, A., Smola, A.J., Lipton, Z., Li, M.: Dive into \nDeep Learning, 2023 \n \n",
        "NATURAL LANGUAGE PROCESSING \nObjectives \nThis course focuses on the theoretical and practical foundations of Natural Language \nProcessing (NLP), an interesting domain at the intersection of computer science and artificial \nintelligence.  Covering language representation, syntax, semantics, and advanced techniques \nlike deep learning and transformers, the course explores how NLP enables communication with \nchatbots and other artificial systems.  By understanding language models and machine \nlearning\u2019s role, students will gain insights into NLP\u2019s applications, including sentiment detection, \nchatbots, and text comprehension.  The course aims to equip students with a comprehensive \nunderstanding of NLP\u2019s significance and motivate them to tackle complex language-related \nchallenges in the field of computer science and AI.  \n \nCourse learning outcomes \nThe learning outcomes of this course are summarized as follows: \u2013 Comprehension of the \ntheoretical foundations of Natural Language Processing (NLP). \u2013 Familiarity with language \nrepresentation techniques in NLP. \u2013 Hands-on experience in solving real-world problems using \nNLP tools and libraries. \u2013 Proficiency in using Python as the primary programming language for \nNLP tasks. \u2013 Familiarity with frameworks like PyTorch and TensorFlow for NLP applications. \u2013 \nAbility to work with Jupyter Notebooks, NLTK, and spaCy for essential \u201cclassical\u201d NLP tasks. \u2013 \nAbility to use some machine learning and deep learning algorithms to solve NLP applications.  \u2013 \nApplication of NLP techniques to more advanced tasks, such as sentiment analysis, text \nsummarization, and question answering systems. Exploration of natural language \nunderstanding, including ChatGPT prompting and engineering applications with Langchain.  \nDescription \n\u2013  Week 1: Introduction to Natural Language Processing \u2013  Week 2: Text Preprocessing \u2013  \nWeeks 3-5: Text Classification \u2013  Week 6: Vector Semantics \u2013  Week 7: Language Modeling \u2013  \nWeek 8: Text Representation \u2013  Week 9: Introduction to Neural Networks \u2013  Weeks 10-12:  \nChatGPT prompting \u2013  Weeks 13- 14: Projects Presentation and Exam preparation \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1 : \u200bWritten exam\u200b \n(50)Grading scheme: 20 points (0-20)Objectives: \u200bMain test for assessing proficiency of \nstudents.\u200b Assessment rules: Students will get exercises that test their understanding of the \ncourse. Only open books and cheat sheets are permitted; no electronic devices are allowed.\u200b \nAssessment criteria: \u200bThe answers are graded based on correctness, completeness, and clarity.\u200b \nTask 2: \u200bTake-home assignment\u200b(20%)Grading scheme: 20 points (0-20)Objectives: To familiarize \nthe students with the material and NLP libraries and applications.\u200b Assessment rules: \u200bStudents \nwill receive Jupyter notebooks with various NLP applications and will need to complete the \nrequired source code and execute the final notebook.\u200b Assessment criteria: The answers are \ngraded based on correctness, completeness, and clarity.\u200b Task 3: Final Project (30%)Grading \nscheme: 20 points (0-20)Objectives: Choose and implement an NLP application.\u200b Assessment \nrules: Students need to choose the topic of their project, implement it, and present it.\u200b \nAssessment criteria: \u200bThe grade is based on the relevance and the oral presentation of the \nproject. \u200b  Task 4: Written exam\u200b \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: \nTest for assessing proficiency of students and help them pass the NLP course \u200b Assessment \n",
        "rules: \u200bStudents will get exercises that test their understanding of the course. Only open books \nand cheat sheets are permitted; no electronic devices are allowed.\u200b Assessment criteria: The \nanswers are graded based on correctness, completeness, and clarity. \u200b   \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on MoodleLiterature list\u2612Yes\u2610NoRemarks:Available on \nMoodleMoodle page\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3921 \n \n",
        "BACHELOR SEMESTER PROJECT 5 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following.  \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself.  The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum.  \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Final report and \nin-person presentation 100%)Grading scheme: 20 points (0-20)Objectives: Assess the quality \nand quantity of work done during the semester. Assessment rules: Time constrained \nsubmissions. Assessment criteria: The detailed criteria are specific to each project subject and \napplied on the following weighted deliverables: \u2013 technical & scientific quality of the final report, \nprimary language (60%) \u2013 technical & scientific quality of the final in-person presentation, \nprimary language (30%) \u2013 technical & scientific quality of the final report, secondary language \nsummary (5%) \u2013 technical & scientific quality of the final in-person presentation, secondary \nlanguage summary (5%)  Task 2: RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: \nOption to repeat a previously failed project (with a final assessment of <10 points) with the same \ntopic and under the same supervisor. Assessment rules: The same deliverables as for the \npreviously failed project must be resubmitted under the given time constraints. Assessment \ncriteria: Same as for Task 1.   \nNote \nCourse materials  \n \nSyllabus \u2612Yes\u2610No Remarks: Accessible from the Moodle course page Literature list \n\u2612Yes\u2610No Remarks: Accessible from the Moodle course page Moodle page \u2612Yes\u2610No \nRemarks: https://moodle.uni.lu/course/view.php?id=3334 \n \n",
        "6th Semester \nAI FOR EDUCATION \nObjectives \nIn recent years, the term artificial intelligence (AI) has taken on a new meaning. While the \noriginal idea of AI is still to understand and artificially simulate human (cognitive) intelligence, \nthe applications of AI have become increasingly important in recent years. There is currently a \nreal spirit of optimism, more and more new AI companies are being founded, governments, \nindustry and science are investing in research and development projects and in targeted \nknowledge transfer, and with \u2018AI for the common good\u2019 and \u2018AI for humans\u2019 we are all prepared \nfor future developments. One of these developments relates to education (and training), be it in \nschools and universities, in industrial training or in the service sector and customer service. The \nassociated opportunities, but also risks, raise the questions of techniques (human-computer \ninterfaces, intelligent systems) of the extent to which AI can be used sensibly and responsibly \nfor learning and knowledge acquisition. AI-based systems should not necessarily be seen as a \nreplacement for existing learning practices and learning techniques, but as a supplement. The \nspectrum of ideas affected by this is therefore diverse. The aims of this course are to gain an \noverview of applications in the relevant area and to explore your own ideas. \n \nCourse learning outcomes \nThe aim of the course is for each participant to understand the selected scientific and common \nresearch directions in the field of AI/Education (lecture part) and the outline and design of an \nown meaningful application in this field, which has to be finally presented in a Poster Workshop \nat the end oif the course.  \nDescription \nThe theoretical part concerns selected aspects of and takes place in the first part of the \nsemester:\u2022 History of AI and selected basics in view of AI/Education\u2022 Techniques to be used \n(Tutoring systems, Expert systems, projects in the AI4Edu focus area, Virtual Reality, etc.\u2022 \nExamples of AI-based teaching and learning methods\u2022 Ethical aspects: GDPR, EU AI Act\u2022 \nFuture of AI-based Education.The Practical Part concerns a Poster Workshop. It is held in the \nsecond part of the semester.The second part concerns a project and its presentation in a poster \nworkshop at the end of the course. All participants work on a project and design a poster \nreflecting the content of the project. In addition, the project carried out must be summarised in a \nwritten document:\u2022 Choose of a project topic \u2022 Create objectives and work plan\u2022 Discuss the \ndata aspect ( data sources and software tools; collection and preparation of data for AI models ) \nand discuss the technical environment  (e.g. chatbots, recommendation systems, tutoring \nsystem, expert systems, etc.)\u2022 Implement the project incl. a critical reflection and future work, \nbibliography \u2022 Integration into an educational setting + testing. Analysis of feedback. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksPart 1 (30h) \u2013 \nAttendanceGrading scheme: Pass/FailObjectives: Click or tap here to enter text. Attendance is \ncompulsory in the lecture part: the candidate qualifies for the poster workshop if he/she has \nattended at least 8 of the 14 lectures.Pass or FailAssessment rules: The students work \nindependently on the course content. Contact with the teachers is desired.Assessment \ncriteriaPart 2 (30h) \u2013 Active participationGrading scheme:20 points (0-20)100%Objectives: \n",
        "Participants familiarise themselves with the project topic, the terminology and the \nobjectives.Assessment rulesEvaluation \u2022Each group member must attend at least 60% = (8 of \n14) lectures and actively contribute to the Poster workshop. If a group member has fulfilled this \n60% condition (and only then), the group member qualifies for the Poster Workshop, in which a \nproject idea relating to AI/Education has to be presented.\u2022\u201dPresented\u201d means that 1.Each group \ncontributes to the implementation of this project idea.2.Each group contributes to the design of a \nposter (at least A3 format) that summarises the most important points of the idea developed. \nExamples of poster designs can be found, for example, in the MNO building (many posters \nhang on the walls on the 3rd and 4th floors). The poster must be scientific, not \nmarketing-orientated (more information see below). 3.Presentation of the idea through a talk \nand demonstrating the implementation in front of a public audience.4.Summarisation of the idea \nin the form of a written Text (in \\LateX ) using a template presented (5 pages minimum, \nEnglish).\u2022The evaluation is as follows:o10% Value of the developed idea. It is important to \nemphasise the benefits of the idea being developed. Is it realisable and does it make sense? \no20% Design of the poster. We follow good practices relating to an effectiveness and \nexpressiveness of the components used (structure of the poster; content of the poster; style like \nfont, colour, etc.)o30% Talk/presentationo40% Written Summary (quality of content, reading and \nsyntax, comprehensibility of the content, completeness of the content, quality of the \\LaTeX \ncode, etc.), which will become a chapter in a final booklet.If Generatlve AI tools (ChatGPT and \nothers) are used, then this must be referenced and the prompts listed in a \u201cTable of prompts\u201d \nnext to the Bibliography chapter. \nNote \nCourse materials \n \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nMoodle page \n \n\u2612Yes  \u2610No \n \n",
        "Remarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4193 \n \nOther, please specify: \n \n \n",
        "SOFTWARE ENGINEERING 2 \nObjectives \nSoftware engineering is the discipline concerned with the application of theory, knowledge, and \npractice to effectively and efficiently build reliable software systems that satisfy the requirements \nof customers and users.  The purpose of this course is to address fundamentals and practical \nareas of software engineering not covered in previous courses. This course will be composed of \ntwo parallel tracks, described below.  Track 1. Testing and Validation:  Testing is the \npredominant technique used by the software industry to ensure the final software product \nreliability. It can be roughly compared to a hunt for detecting and eliminating defects and bugs \nfrom a software. Thus, testing and validation aim first at assessing the consistency/conformity of \na product with respect to its specification, and in practice to ensure at least that it will not crash! \nThese activities are thus crucial and costly for software companies, and eventually aim at \nproviding a controlled level of trust in the final product before delivery to the client (and \ncontinuously during maintenance and evolution). Testing is related to all the design stages of the \ndevelopment process and must deal with many application contexts (embedded systems, \nmobile applications, information systems \u2026) and various levels of complexity \n(programming-in-the-small, in-the-large and in-the-duration). Besides the fundamentals of \nsoftware testing, the focus will be on practical techniques that can be applied in real-world \nsoftware development cycles (agile, continuous integration), including techniques to localize and \nremove the detected faults.   Track 2. Software design and architectures: the design of software \nsystems is largely dependent on the accurate analysis of functional and non-functional \nrequirements. This track will address software architectures, design patterns, and, in general, \nnon-functional requirements. The use cases that we will study will be taken from, or inspired by, \nreal-world industrial software.  \n \nCourse learning outcomes \nAt the end of the course the student will:  \n \nRemember, and understand the fundamentals of software testing (the concepts and principles \nbehind the many existing techniques).  \n \nApply classical testing techniques, black-box and glass-box ones, on simple programs.  \n \nSolve a larger software testing problem (integration and system) and create a basic testing \nstrategy.  \n \nAnalyze novel enablers (e.g. AI-assistant, APR) and testing challenges (e.g. testing AI-based \nsystem).  \n \nUnderstand the main software architectural styles and design patterns  \n \nSelect the most suitable software architecture and design patterns for a new project.  \n \n   \n",
        "Description \n1. Part 1: Software Testing and Validation 1.1 Fundamentals 1.2. Unit Testing and Diagnosis 1.3. \nIntegration Testing 1.4. Requirements and System Validation 1.5. Transversal aspects to \nfunctional testing  2. Track 2: Software Architectures and Non-functional requirements 2.1. \nNon-functional requirements 2.2. Design patterns 2.3 Software architectural styles  \nAssessment \nAssessment modality: \u200bCombined assessment\u200b Assessment tasks \n \nTask 1: Written exam\u200b \u2013 Mid-term exam (40%)Grading scheme: 20 points (0-20)Objectives: \n\u200bAssessing the students\u2019 understanding of the main concepts presented in the lectures and their \ncapability to solve some exercises based on the algorithms presented in class.\u200b Assessment \nrules: The use of documents (including books and notes) is not authorized. The use of \nelectronic devices is not authorized.\u200b Assessment criteria: Correctness of the answers\u200b Task 2: \nWritten exam\u200b \u2013 Final exam (60%)Grading scheme: 20 points (0-20)Objectives: Assessing the \nstudents\u2019 understanding of the main concepts presented in the lectures and their capability to \nsolve some exercises based on the algorithms presented in class.\u200b Assessment rules: The use \nof documents (including books and notes) is not authorized. The use of electronic devices is not \nauthorized\u200b Assessment criteria: Correctness of the answers\u200b Task 3: RETAKE (100%)Grading \nscheme: 20 points (0-20)Objectives: Assessing the students\u2019 understanding of the main \nconcepts presented in the lectures and their capability to solve some exercises based on the \nalgorithms presented in class.\u200b Assessment rules: \u200bThe use of documents (including books and \nnotes) is not authorized. The use of electronic devices is not authorized\u200b Assessment criteria: \n\u200bCorrectness of the answers\u200b  \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \n\u201cIntroduction to Software Testing\u201d \u2013 Paul Ammann and Jeff Offutt \u2013 ISBN-13: 9780521880381 \u2013 \nCambridge Press \u2013 2008\u201cFoundations of Software Testing\u201d \u2013 Aditya Mathur \u2013 Addison-Wesley \nProfessional \u2013 2007\u201cSoftware Architecture Patterns\u201d \u2013 Mark Richards-O\u2019Reilly, USA-2015 \n \n  \n \n",
        "\u201cDesign Patterns\u201d Elements of Reusable Object-Oriented Software\u201d \u2013 Erich Gamma, Richard \nHelm, Ralph Johnson, and John Vlissides \u2013 Addison-Wesley \u2013 1994   \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4191 \n \n",
        "SECURITY 2 \nObjectives \nThe objectives of this course on Information Security are:1) To provide students with \ncomprehensive understanding of public-key cryptography. This will involve studying RSA \nencryption, signatures, Diffie-Hellman key exchange, along with its secure models, the methods \nto encrypt and sign securely using RSA, and a study on Public-key Infrastructure, including \ncertificates and SSL protocol.2) To delve into blockchain protocols with a focus on the basics of \nBitcoin and the crypto blockchain. This will include discussions on privacy and scalability within \nBitcoin and blockchain technology, and an introduction to multi-party computation.3) To explore \ngeneral cryptographic protocols such as Authenticated Key-Exchange (AKE) and \nPassword-based Authenticated Key-Exchange (PAKE). The course also introduces students to \nzero-knowledge protocols, authentication/identification protocols, secure voting schemes, and \nquantum key establishment.4) To provide a solid foundation in system security and trusted \ncomputation by exploring operating system security mechanisms and policies. This includes an \nin-depth study on trusted execution and authenticated boot. Overall, the course aims to furnish \nstudents with a thorough understanding of information security from various angles, preparing \nthem for future careers or research in the field. \n \nCourse learning outcomes \nUpon successful completion of this Information Security course, students should be able to:1) \nComprehend and apply the principles of public-key cryptography, including RSA encryption, \nsignatures, Diffie-Hellman key exchange, and understand how to use RSA securely. They \nshould also be able to navigate the landscape of Public-key Infrastructure, including certificates \nand SSL protocol.2) Understand and explain the basics of blockchain protocols, with a specific \nfocus on Bitcoin and crypto blockchain. Students should be able to discuss issues of privacy \nand scalability and be familiar with multi-party computation. Demonstrate understanding of \nvarious cryptographic protocols, such as Authenticated Key-Exchange (AKE), Password-based \nAuthenticated Key-Exchange (PAKE), zero-knowledge protocols, authentication/identification \nprotocols, and secure voting schemes. They should also understand the basics of quantum key \nestablishment.3) Explain and assess system security mechanisms and policies, with a particular \nemphasis on operating system security. Students should be able to evaluate and discuss trusted \nexecution and authenticated boot.4) Apply the knowledge and skills learned in this course to \nanalyze and solve problems in information security. This will prepare them for roles in the \ninformation security sector, or for further academic study in the field.5) Develop a \ncomprehensive understanding of the current challenges and opportunities in the field of \ninformation security and be prepared to stay updated as the field evolves. \nDescription \n\u200b1. Information security  1.1. Public-key cryptography (Jean-Sebastien Coron) 1.1.1. Introduction \nto public-key cryptography: RSA encryption, signatures, and DH key exchange (recap) 1.1.2. \nSecurity models in cryptography. How to encrypt and sign securely with RSA. OAEP and PSS \n1.1.3. Public-key infrastructure. Certificates, SSL protocol  1.2. Blockchain protocols (Sergiu \nBursuc) 1.2.1. Basics of Bitcoin and of the crypto blockchain 1.2.2. Bitcoin / blockchain privacy \nand scalability 1.2.3. Multi-party computation  1.3. General cryptographic protocols (Peter Ryan) \n1.3.1. Authenticated key-exchange (AKE) and password-based authenticated key-exchange \n",
        "(PAKE) 1.3.2. Zero-knowledge protocols 1.3.3. Authentication/identification protocols 1.3.4. \nSecure voting schemes 1.3.5. Quantum key establishment  1.4. System security and trusted \ncomputation (Marcus V\u00f6lp) 1.4.1. Operating system security mechanisms and policies 1.4.2. \nTrusted execution and authenticated boot\u200b  \nAssessment \nAssessment modality: Continuous assessmentAssessment tasksTask 1: Take-home assignment \n(21%)Grading scheme: 20 points (0-20)  Objectives: Ability to understand the notions of \npublic-key cryptographyAssessment rules: Students will work on their own.Assessment criteria: \nProduced code and report will be examinedTask 2: Take-home assignment (21%)Grading \nscheme: 20 points (0-20)  Objectives: Understanding of bitcoin and \ncryptocurrenciesAssessment rules: Students will work on their own.Assessment criteria: \nProduced code and report will be examinedTask 3: Take-home assignment (44%)Grading \nscheme: 20 points (0-20)  Objectives: Understanding of cryptographic protocolsAssessment \nrules: Students will work on their own.Assessment criteria: Produced code and report will be \nexaminedTask 4: Take-home assignment (14%)Grading scheme: 20 points (0-20)  Objectives: \nUnderstanding of system securityAssessment rules: Students will work on their \nown.Assessment criteria: Produced code and report will be examinedTask 5: Take-home \nassignment \u2013 Retake (100%)Grading scheme: 20 points (0-20)  Objectives: Understanding of \nthe concepts of the course.Assessment rules: Students will work on their own.Assessment \ncriteria: Produced code and report will be examined. \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nOn Moodle \n \nLiterature list \n \n\u2610Yes  \u2612No \n \nRemarks: \n \n  \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4192 \n",
        " \nFORMAL METHODS \nObjectives \nThe course starts with a gentle introduction to Software Engineering emphasizing the current \nstate of the profession concerning the constant presence of errors that cause malfunctions in a \nvariety of software systems. It shows how formal methods can help to overcome this \nsituation.After that, the B formal notation is introduced by means of several practical, real-world \nexamples. This allows to introduce set theory, binary relations, predicate calculus and how state \nmachines can be described by using these mathematical tools. It is also shown that state \nmachines are a suitable way of describing a large class of software systems. In particular, it is \nexplained the concept of state invariant and how it can be proved or disproved (informally).As a \nthird step, a tool named Set Log is introduced, and it is emphasised the fact that B specifications \ncan be easily translated into Set Log. Then, it is shown how the translated specification \nbecomes both a formula and a program. As a program, it can be executed thus allowing \nengineers to have a prototype of the system. Besides, it is shown how Set Log can \nautomatically and formally prove or disprove state invariants.Therefore, the course will show \nhow the mere fact of writing a formal specification enables a chain of verification activities that \nhelp to increase the quality of the final product. \n \nCourse learning outcomes \nAt the end of the course the student will be able to:\u2022Know the rationale behind formal methods \nand what they are used for. \u2022Write formal specifications using formal languages.\u2022Specify \nstate-based abstract machines. \u2022Know, understand, and specify invariants.\u2022Know, understand, \nand specify pre and post conditions.\u2022Perform formal verification. \nDescription \nThe following topics are covered in the course:\u2022 Introduction to formal methods\u2022 The B-Method\u2022 \nThe B formal language\u2022 Binary relations, functions, and sequences in set theory \u2022 The {log} \n(read as setlog) tool.\u2022 The {log} language.\u2022 Translation of a B machine into {log}\u2022 Automated \nproofs with {log} \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(30%)Grading scheme: 20 points (0-20)  Objectives: Assessing the students\u2019 understanding of \nhow to specify requirements using one of the formal languages presented in the course and its \nassociated tool support. Assessment rules: The student uses his/her personal computer to write \nthe specification. Any resource is available. The specification is electronically submitted via the \nofficial learning management system used at the institution. Late submissions as well as any \ndamage or corrupted submitted file will be graded with ZERO. Assessment criteria: The \nprovided specification must be correct. Correctness means that it passes the built-in controls of \nthe tool used to write the specification (syntax, type-checking), but also it describes the \nrequested requirements respecting the specification style taught during the course.  Task 2: \nWritten exam (70%)Grading scheme: 20 points (0-20)  Objectives: Idem to Task 1Assessment \nrules: Idem to Task 1Assessment criteria: Idem to Task 1Task 3: Retake (100%)Objectives: A \nstudent who has failed the course is allowed to sit to the next exam call. The objectives are the \n",
        "same as Task 2.Grading scheme: 20 points (0-20)  Assessment rules: Idem to Task \n2.Assessment criteria: Idem to Task 2. \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nSchneider, Steve. The B-Method: an Introduction. New York NY: Palgrave Macmillan, 2001. \nPrint. \n \n(Optional complementary reading) Abrial, J., Hoare, A., & Chapron, P. (1996). The B-Book: \nAssigning Programs to Meanings. Cambridge. Available at the LLC (hard copy and online). \n \nLecture notes on B and {Log}. Available on the Moodle\u2019s course\u2019s page on due time. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4195 \n \n",
        "INTELLIGENT SYSTEMS 2 \nObjectives \nUnderstand how logics are used for knowledge representation and reasoning, to model \nuncertainty, multi-agent systems, defeasibility, or causality.   \n \nCourse learning outcomes \nAt the end of the course, the student will be able to:\u2022Know and remember what classical, modal, \nand non-monotonic logics are.\u2022Represent facts using these logics.\u2022Reason using these logics. \nDescription \nPart I: Logical foundations.\u2022 Propositional logic\u2022 First-order logic\u2022 Modal logicPart II: Modelling \nagents.\u2022 Belief and preference states \u2022 Belief dynamics\u2022 Action logics\u2022 Multi-agent systemsPart \nIII: Non-monotonic reasoning.\u2022 Classical approaches\u2022 Valuation-based approaches \u2022 Formal \nArgumentationPart IV: Probabilistic reasoning.\u2022 Probabilistic logics\u2022 Inductive probabilistic \ninference \u2022 Causal reasoningPart V: Practical knowledge representation.\u2022 Applications to \nKnowledge Representation \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(70%)Grading scheme: 20 points (0-20)  Objectives: Prove that the logical concepts and \nmethods have been understood and can be applied for problem-solving.Assessment rules: \nOpen book exam (printed course materials are allowed).  Assessment criteria: Correctness of \nthe answers to questions.Task 2: Take-home assignment (30%)Grading scheme: 20 points \n(0-20)  Objectives: Weekly test to prove that the concepts and methods are being \nunderstood.Assessment rules: Provide answers in LaTeX or handwritten text.Assessment \ncriteria: Correctness of the answers to questions.Task 3: Written exam \u2013 RETAKE \n(100%)Grading scheme: 20 points (0-20)  Objectives: Prove that the logical concepts and \nmethods have been understood and can be applied for problem-solving.Assessment rules: \nOpen book exam (printed course materials are allowed).  Assessment criteria: Correctness of \nthe answers to questions. \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on the course\u2019s Moodle page. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nRelevant texts will be indicated for the individual topics. \n",
        " \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3918 \n \n",
        "USER CENTERED DESIGN \nObjectives \nThe course provides numerous insights into user-centred design methods and tools such as: \n \n(1) choosing and applying design methods, \n \n(2) reporting the findings, and \n \n(3) understanding and interpreting the findings. User-Centred Design provides hands-on \npractice on improving interfaces and products with regards to users\u2019 needs. \n \nCourse learning outcomes \nGaining experience with user-centred design methods though hands-on exercises \n \nDeveloping user-centred thinking skills  \nDescription \n1. Introducing User-Centred System Design  2. Understanding Users & Context   3. Interviewing \nUsers  4. Structuring Findings  5. User Story Mapping  6. Storyboarding 7. Brainstorming and \nPrototyping   8. User Testing   9. Exploring User Interface   10. Usability and User Experience \nScales   11. Effective Reporting   12. Student Presentations 1 13. Student Presentations 2 14. \nWrap-up  \nAssessment \nAssessment modality: Combined assessmentAssessment tasks Task 1: Project Presentation \n(100%)Grading scheme: 20 points (0-20)Objectives: Students will learn how to design and \nevaluate a user-centered interface, and how to effectively communicate the results of their \nproject via presentation. Assessment rules: Throughout the course, students will work \nindividually on a design research project. Each student must show their week-to-week \nhomework during the course to demonstrate how they applied the methods presented during \nthe course, what worked well and what did not, and iteratively improve their designs. \nAssessment criteria: The final evaluation will be based on each student\u2019s presentation of the \ndesign project undertaken during the semester. If the delivered homework assignments do not \nmeet the expected learning objective, the student will be asked to rework their project.  The \nattainment of learning goals will be evaluated through the project presentation based on 3 \ncriteria: application of the introduced methods insights, lessons learned & critical thinking. \npresentation quality Task 2: RETAKE (100%) Grading scheme: 20 points (0-20)Objectives: \nStudents will learn how to design and evaluate a user-centered interface, and how to effectively \ncommunicate the results of their project via presentation. Assessment rules: Video Presentation \nof an Interface Design and Evaluation Project (20 minutes). Assessment criteria: The attainment \nof learning goals will be evaluated through the project presentation based on 3 criteria: \napplication of the introduced methods insights, lessons learned & critical thinkingpresentation \nquality  \nNote \nSyllabus \n \n",
        "\u22a0Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u22a0Yes  \u2610No \n \nRemarks: \n \nReference textbook: \n \nCooper, A., Reimann, R., Cronin, D., & Noessel, C. (2014). About face: the essentials of \ninteraction design. John Wiley & Sons. \n \nThe Encyclopaedia of Human-Computer Interaction 2nd Edition \u2013 Available Online: \nhttps://www.interaction-design.org/literature/book/the-encyclopedia-of-human-computer-interacti\non-2nd-ed \n \nRecommended books: \n \nNorman, D. (2013). The design of everyday things: Revised and expanded edition. Basic books. \n \nMoodle page \n \n\u22a0Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4332    \n \nOther, please specify: \n \nClass attendance is not required but highly encouraged. \n \n",
        "BACHELOR SEMESTER PROJECT 6 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with UL employees in a project context, learn new technologies related to computer \nscience, learn new knowledge related to computer science, apply the scientific and technical \nknowledge learned during the BICS, apply the primary and secondary languages knowledge \nlearned during the BICS.The course content and learning objectives are consistent with the \nBiCS programme content that the student is following. \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself.  The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum.  \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project.   \nAssessment \nAssessment modality: Combined assessmentAssessment tasks \n \nTask 1: Final report and in-person presentation (100%) Grading scheme: 20 points \n(0-20)Objectives: Assess the quality and quantity of work done during the semester. \nAssessment rules: Time constrained submissions. Assessment criteria: The detailed criteria are \nspecific to each project subject and applied on the following weighted deliverables: technical & \nscientific quality of the final report, primary language (60%) technical & scientific quality of the \nfinal in-person presentation, primary language (30%) technical & scientific quality of the final \nreport, secondary language summary (5%) technical & scientific quality of the final in-person \npresentation, secondary language summary (5%) Task 2: RETAKE (100%) Grading scheme: 20 \npoints (0-20)Objectives: Option to repeat a previously failed project (with a final assessment of \n<10 points) with the same topic and under the same supervisor. Assessment rules: The same \ndeliverables as for the previously failed project must be resubmitted under the given time \nconstraints. Assessment criteria: Same as for Task 1.  \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \nLiterature list \n \n",
        "\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4197 \n"
    ],
    "semesters_-1825107718476325684": [
        "1st Semester \nWEB DEVELOPMENT 1 \nObjectives \nThe course provides an introduction to front-end web development. The course covers the \nfoundational building blocks of the Web and user interface design fundamentals for building \nwebsites and web applications. After the course, students will be able to understand and \ndevelop the front-end of any kind of websites and web applications. \n \nCourse learning outcomes \n1.Understand the foundations of front-end development. \n \n2.Identify the key components of web technologies.3.Judge and support best practices in web \ndevelopment. \nDescription \n1. Getting started 1.1. Front-end roles: Design, develop, create, animate1.2. Languages: HTML, \nCSS, JS1.3. Setup: OS, browsers, editors2. How the web works 2.1. History: Internet, web \nbrowsers2.2. URIs: Scheme, conventions3. Key concepts to know 3.1. Methodologies: \nProgressive enhancement, graceful degradation, RWD3.2. Accessibility: Types of impairments4. \nHTML Overview 4.1. Defaults: Formatting, doctypes, stylesheets4.2. Semantic markup: \nMicrodata, microformats4.3. Entities: Tags, attributes5. Marking up text 5.1. Structural elements: \nMetadata, sections, text, lists, tables, form, media6. Adding links 6.1. Working with URLs: Link \ntypes, attributes, fragments7. Adding images 7.1. Concepts: Formats, raster/vector, resolution, \ninterlacing, transparency7.2. Optimization: Compression, dithering7.3. SVG: Animation, filters8. \nTables 8.1. Markup notation: Semantics, controlling structure9. Forms 9.1. Markup notation: \nElements, attributes9.2. Sending data: GET, POST, encodings10. HTML510.1. Overview: \nFeatures, browser wars10.2. APIs: Media Player, History, Storage, Drag and Drop, Canvas11. \nCascading Style Sheets 11.1. Authoring: Formats, structure11.2. Inheritance: Tree matching, \nspecificity11.3. Selectors: IDs, classes, conflicting styles, contextual and pseudo-selectors12. \nFormatting text 12.1. Fonts: Properties, family, style, color12.2. Measurement units: Absolute \n(px, pt) and relative (em, ex)13. Colors and backgrounds 13.1. Color models: RGB, RGBA, \nHSV, opacity13.2. Images: Properties, notation13.3. Gradients: Linear and radial gradients14. \nThinking inside the box 14.1. Box model: Sizing, overflow, margin, padding, borders15. Floating \nand positioning 15.1. Layout flow: Containers, clears, stacking order16. Page layout 16.1. \nTypes: Fixed, fluid, elastic, hybrid16.2. Methodologies: Common patterns, Flexbox, Grid \nsystem17. Transitions, transforms, and animation 17.1. Fundamentals: Functions, keyframes, \nproperties18. CSS techniques 18.1. Tips: Resets, sprites18.2. Preprocessors: Variables, \nfunctions18.3. Responsive web design: Media queries \nAssessment \nAssessment modality: Coding assignments (continuous evaluation) and multiple-choice quiz \nexam. \n \nAssessment tasks \n \n\nTask 1: Coding assignments (40%) \n \nGrading scheme: 20 points (0-20) \n \nObjectives: Students will learn how to implement business requirements through hands-on \nexercises using JavaScript, HTML, and CSS. \n \nAssessment rules: Every week, students must submit a simple programming exercise based on \nthe contents taught in the course. Students must follow a series of specifications about each \nexercise, provided in Moodle. Students have up to 1 week to submit. Exercises must be \nsubmitted only via Moodle. No late submissions are allowed, unless \u201cforce majeure\u201d causes; \ne.g. sickness, accident, etc. for which an authoritative certificate must be provided (e.g. a \ncertificate signed by a medical doctor or a police representative). \n \nAssessment criteria: There are 10 coding assignments in total, and each will be graded using a \n0-10 point scale via an automated testing platform. Students can access such a platform at any \ntime before each submission deadline. Students must get an average grade of at least 4.5 \npoints (out of 10) in this part in order to qualify for the final exam. If a student scores less that \n4.5 points in this part, the final grade in the course will be the minimum grade achieved in either \nthe coding assignments or the final exam. Any form of cheating or plagiarism will be penalized \nwith a grade of 0 in this part, which will make the student to fail the whole course. The grade in \nthis part will be retained until the student passes the final exam, unless the student decides to \nrepeat the course in the next academic year. There is no retaking option for this part within the \nsame academic year, which means that a student who fails this part must enroll again in the \ncourse in the next academic year. Retaking students must inform the course responsible \nwhether they want to keep their grade in this part from the previous year.Task 2: Final exam \n(60%) \n \nGrading scheme: 20 points (0-20) \n \nObjectives: Students will demonstrate that they have acquired the required competencies \naccording to the theory covered in the course. \n \nAssessment rules: Only students who got at least 4.5 points in the coding assignments should \ntake the final exam, otherwise they are advised to de-enrol from the final exam in order to avoid \nmissing an official attempt. Students can bring an A4 paper \u201ccheat sheet\u201d written on both sides. \nNo other supporting material is allowed, i.e. no books, no mobile devices, no laptops, etc. \n \nAssessment criteria: The exam is a paper-based quiz with 30 questions that must be solved in \n45 minutes. Each question comes with 4 possible answers, among which only one is the right \none. A student must get at least 4.5 points (out of 10) in the final exam in order to pass the \ncourse. If a student scores less that 4.5 points in this part, the final grade in the course will be \nthe minimum grade achieved in either the coding assignments or the final exam. Any form of \ncheating or plagiarism will be penalized with a grade of 0 in this part, which will make the \n\nstudent to fail the whole course. The grade in this part will not be retained for the next academic \nyear. Failing students can retake the exam in the next examination period or enroll again in the \ncourse the next academic year. \nNote \nSyllabus\u22a0Yes\u2610NoRemarks:Available on MoodleLiterature list\u22a0Yes\u2610NoRemarks:Reference \ntexbook:\u2022J. Robbins. 2012. Learning Web Design. O\u2019Reilly Media, 4th ed.Recommended \nbooks:\u2022R. Anquetil. 2019. Fundamental Concepts for Web Development, 1st ed.\u2022M. Haverbeke. \n2018. Eloquent JavaScript, 3rd ed.\u2022S. Krug. 2000. Don\u2019t Make Me Think, 3rd ed.Moodle \npage\u22a0Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=5689 Other, please \nspecify:Class attendance is not required but highly encouraged.\n \n\nANALYSIS 1 \nObjectives \nThis course is an introductory analysis course, covering basics on numbers, sequences, and \nfunctions. \n \nThe course aims to introduce students to these notions, including formal proofs, techniques and \nto give them necessary tools for the understanding of mathematics and the mathematical \nlanguage of science. \n \nCourse learning outcomes \nAt the end of the course the student will:-remember further mathematical knowledge. -apply \nanalytic and critical thinking.-understand and practice deep mathematical concepts that will be \nused throughout their scientific career.-apply techniques from calculus to compute. \nDescription \nThis course is an introductory analysis course, covering basics on numbers, sequences, and \nfunctions. There is both a calculus component (computations of limits of sequences, derivatives, \nfunction approximations, limits of sequences) and more theoretical analysis.This latter portion is \nsizeable part of the course where the students are introduced to proof techniques and the \nimportance of rigorous arguments which are foundational and transversal in mathematics and \nscience. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(60%)Grading scheme: 20 points (0-20)Objectives: Test concepts learned during the \nyearAssessment rules: Students cannot use calculators, electronic devices, or \nnotes.Assessment criteria: Graded out of 20 with points for each exerciseTask 2: Written exam \n(20%)Grading scheme: 20 points (0-20)Objectives: Test concepts learned during the \nyearAssessment rules: These are partial exams during the semester (there are several of them). \nStudents cannot use calculators, electronic devices, or notes.Assessment criteria: Graded out of \n20 with points for each exerciseTask 3: Take-home assignment (10%)Grading scheme: 20 \npoints (0-20)Objectives: Practice conceptsAssessment rules: Students work from home and can \nuse course materials.Assessment criteria: Graded out of 20 with points for each exerciseTask 4: \nWritten exam (10%)Grading scheme: 20 points (0-20)Objectives: QuizzesAssessment rules: \nThere are 2 mandatory quizzes. Students cannot use calculators, electronic devices, or \nnotes.Assessment criteria: Graded out of 20 with points for each exerciseTask 5: Written exam \u2013 \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: The final grade, in case of a \nretake exam, is based 100% on the exam grade. (Performance on quizzes, homework, \nmidterms, and exercises is not taken into account.)Assessment rules: Students cannot use \ncalculators, electronic devices, or notes.Assessment criteria: Graded out of 20 with points for \neach exercise \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Literature list\u2612Yes\u2610NoRemarks:Course notesMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=322\n \n\nDISCRETE MATHEMATICS 1 \n \nObjectives \nDiscrete structures are foundational material for computer science. Relatively   few computer \nscientists will be working primarily on discrete structures, but many other areas of computer \nscience require the ability to work with concepts from discrete structures. The discrete structures \ncovered in this introduction include important material from such areas as set theory, logic, \ngraph theory, and number theory. \n \nCourse learning outcomes \nBy the end of the course students will be able to:-Use logical notation to define and reason \nabout fundamental mathematical concepts, such as sets, relations, functions, and \nintegers.-Evaluate elementary mathematical arguments and identify fallacious   reasoning (not \njust fallacious conclusions).-Synthesise induction hypothesis and simple induction proofs.-Prove \nelementary properties of modular arithmetic and explain their applications in Computer Science, \nfor example, in cryptography.-Apply graph theory models of data structures and state machines \nto solve problems of connectivity and constraint satisfaction, for example, scheduling.-Apply the \nmethod of invariants and well-founded ordering to prove   correctness and termination of \nprocesses and state machines.-Efficiently work on problems in a small team with fellow \nstudents. -Manage their time and tasks in a responsible way. \nDescription \n* Week 1 \u2013 Week 4: Proof techniques* Week 5 \u2013 Week 6: Introduction to Logic* Week 7: \nMid-Term Exam* Week 8 \u2013 Week 9: Sets, Relations, and State Machines* Week 10 \u2013 Week 12: \nGraph Theory* Week 13 \u2013 Week 14: Number Theory and modular Arithmetic* Final Exam* \nRetake Exam \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Mid-Term (50%)Grading scheme: 20 points (0-20)Objectives: To test the \nstudents their knowledge of the first half of the material i.e. week 1-6 Proof techniques and \nLogic.Assessment rules: Students are allowed a cheat sheet using 1 side of 1 a4 page. Beside \nthis, students can only bring pen and pencil. Final answers should be written using pen \n(blue/black).Assessment criteria: The answers to the exercises are graded based on \ncorrectness completeness and clarity. (see 9 points for writing good proofs in proof guide on \nmoodle)Task 2: Written exam \u2013 Final Exam (50%)Grading scheme: 20 points (0-20)   \nObjectives: To test the students their knowledge of the second half of the material i.e. week \n7-13: sets, relations and state machines; graph theory; number theory and \narithmetic.Assessment rules: Students are allowed a cheat sheet using 1 side of 1 a4 page. \nBeside this, students can only bring pen and pencil. Final answers should be written using pen \n(blue/black).Assessment criteria: The answers to the exercises are graded based on \ncorrectness completeness and clarity. (see 9 points for writing good proofs in proof guide on \nmoodle) \n\n \nIn order to receive a final grade the midterm exam and final exam need to be completed. \n \nTask 3: Written exam \u2013 RETAKE EXAM (100%)Grading scheme: 20 points (0-20) Objectives: \nStudents who did not get an average of at least 10 points on the mid-term combined with the \nfinal exam are entitled to sit to the retaken test of the course. This test allows the student \nanother opportunity to pass the course by obtaining at least 10 points on this retake exam. The \nretake exam covers all course material.Assessment rules: Students are allowed a cheat sheet \nusing 1 side of 1 a4 page. Beside this, students can only bring pen and pencil. Final answers \nshould be written using pen (blue/black).Assessment criteria: The answers to the exercises are \ngraded based on correctness completeness and clarity. (see 9 points for writing good proofs in \nproof guide on moodle) \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on the Moodle page.Literature list\u2612Yes\u2610No \n \nRemarks:-Lecture notes available on the Moodle \npage.https://moodle.uni.lu/pluginfile.php/2227981/mod_resource/content/1/Lecture%20Notes%2\n0-%20MIT%20Discrete%20Math.pdfWe use the version from 2018. \n \n-A Guide for making proofs. Available on the moodle page.Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=323 Other, please \nspecify:We based this course on the MIT course Mathematics for Computer Science: \nhttps://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2010/\n \n\nLINEAR ALGEBRA 1 \n \nObjectives \nFundamental notions of Linear Algebra. \n \nCourse learning outcomes \nThe students recall and are able:\u2022To formulate the basic notions of linear algebra. \u2022To solve \nsmall linear algebra problems by performing calculations and applying algorithms.\u2022To \nunderstand small proofs and to look for examples and counterexamples. \nDescription \nSystems of linear equations and matrices; determinants; Euclidean vector spaces (especially in \ndimension 2 and 3); general vector spaces (linear independence, span, basis). \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Midterm exam 1 (15%)Grading scheme: 20 points (0-20)Objectives: \nWritten test with exercises.Assessment rules: Only 6 pages of personal notes are allowed. No \ncalculators.Assessment criteria: The tests are graded. The average of the two best midterms \ncounts as mark.Task 2: Written exam \u2013 Midterm exam 2 (15%)Grading scheme: 20 points \n(0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of personal notes \nare allowed. No calculators.Assessment criteria: The tests are graded. The average of the two \nbest midterms counts as mark.Task 3: Written exam \u2013 Midterm exam 3 (15%)Grading scheme: \n20 points (0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of \npersonal notes are allowed. No calculators.Assessment criteria: The tests are graded. The \naverage of the two best midterms counts as mark.Task 4: Written exam \u2013 Final exam \n(70%)Grading scheme: 20 points (0-20)Objectives: Written test with exercises.Assessment \nrules: Only 6 pages of personal notes are allowed. No calculators.Assessment criteria: The test \nis graded.Task 5: Oral exam \u2013 optional Grading scheme: 20 points (0-20)Objectives: Oral exam \n(in case of justified absence to >1 midterms or as additional evaluation in case of fraud \nsuspicion)Assessment rules: Discussion with questions (theoretical questions and \nexercises)Assessment criteria: Correct and partially correct answers contribute positively to the \ngrade.Task 6: Either final written exam (100%) or the same modalities as the regular students \n(to be selected by each retaking student at the beginning of each semester)Grading scheme: 20 \npoints (0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of personal \nnotes are allowed. No calculators.Assessment criteria: The test is graded.   \nNote \nSyllabus\u2612Yes\u2610NoRemarks:Moodle pageLiterature list\u2612Yes\u2610NoRemarks:Moodle \npageMoodle page\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=324 Other, \nplease specify:\n \n\nPROGRAMMING FUNDAMENTALS 1 \nObjectives \nThis course introduces the fundamentals of programming using the Python programming \nlanguage. This is not primarily a Python programming course but rather a discussion of the \nfundamental concepts underlying computation using Python code examples as illustration. At \nthe same time enough of the Python language is covered for the students to be able to tackle \nnon-trivial problems (e.g., in the context of projects). This introductory course forms the basis for \nmore advanced courses on algorithms and object-oriented programming. \n \nCourse learning outcomes \nUpon completion of this course the student should be able to:\u2022move from a problem description \nto a Python program by successively reducing the level of abstraction with the help of \npseudo-code.\u2022document the implementation choices. \u2022make use of available data types and \nprogram libraries.\u2022extend and adapt code written by other programmers.\u2022test and debug \ncomputer programs. \nDescription \n1. Introduction to computational problem solving and the Python programming language.2. \nBasic syntax and semantics of Python.3. Functions and modules.4. Problem solving and \nrecursion.5. Structured types and function objects.6. Files and exceptions.7. Testing.8. \nDebugging.9. Iterators and generators.10. Floating-point numbers.11. Introduction to \nobject-oriented programming in Python.12. Introduction to popular libraries: mathplotlib, NumPy \nand Pandas.13. Introduction to software engineering. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(50%)Grading scheme: 20 points (0-20)Objectives: The objective of this final exam is to test the \nstudent\u2019s understanding of the course material.Assessment rules: The student has to answer \nquestions with pencil and paper. This is a closed-book exam. No cheat sheet \nallowed.Assessment criteria: The student must answer the stipulated questions in a way that \nclearly demonstrates understanding of underlying concepts.Task 2: Written exam (50%)Grading \nscheme: 20 points (0-20)Objectives: To test the student\u2019s ability to implement Python programs \nfor concrete problems.Assessment rules: The student has to solve programming tasks with \npencil and paper. This is a closed-book exam. No cheat sheet allowed.Assessment criteria: The \nexam consists of two parts: mid-term evaluation and final evaluation, each of which counts \n25%.Task 3: Written exam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: The \nobjective of this final exam is to test the student\u2019s understanding of the course \nmaterial.Assessment rules: The student has to answer questions with pencil and paper. This is \na closed-book exam. No cheat sheet allowed.Assessment criteria: The student must answer the \nstipulated questions in a way that clearly demonstrates understanding of underlying \nconcepts.Assessment modality: Combined assessmentAssessment tasksAssessment modality: \nCombined assessmentAssessment tasks  \nNote \nCourse materialsSyllabus\u2610Yes\u2612NoRemarks:Literature list\u2610Yes\u2612NoRemarks:Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=321Other, please specify:\n\nINTRODUCTION TO PROJECT MANAGEMENT \nObjectives \nThe course aims to provide comprehensive knowledge and practical skills in project \nmanagement for scientific research, encompassing the entire lifecycle of projects from initiation \nto completion, including defining project deliverables, developing project plans, employing best \npractices and modern tools, conducting research ethically, and effectively presenting research \nfindings. \n \nCourse learning outcomes \nAt the end of the course students should be able to:- Understand Key Concepts of Project \nManagement- Develop Practical Project Management Skills- Apply Best Practices in Project \nManagement- Master Research Development Techniques- Handle and Analyze Data Ethically- \nEffectively Communicate Research Findings \nDescription \nThis course provides an in-depth exploration of project management and scientific research, \ncovering project planning, deliverables, values, tools, best practices, and case studies, as well \nas scientific research processes from topic selection to data gathering, hypothesis generation, \nand ethical considerations, with practical hands-on lab sessions integrated throughout each \nweek. \nAssessment \n\u200bAssessment modality: Combined assessmentAssessment tasks \n \nTask 1: Take-home assignment (30%)Grading scheme: 20 points (0-20)Objectives: Written one \nreport for project management planAssessment rules: Match with the course quality \ncriteria.Assessment criteria: Time constrained submission.Task 2: Take-home assignment \n(30%)Grading scheme: 20 points (0-20)Objectives: Written one report for scientific \nresearch.Assessment rules: Match with the course quality criteria.Assessment criteria: Time \nconstrained submission.  Task 3: Presentation (40%)Grading scheme: 20 points \n(0-20)Objectives: Presentation to a group of studentsAssessment rules: Match with the course \nquality criteria.Assessment criteria: Time constrained submission and present.Task 4: Written \nexam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: In the case the student \nhas failed to pass the class, he/she will be given a written retake assignment.Assessment rules: \nMatch with the course quality criteria.Assessment criteria: Time constrained submission. \nNote \nCourse materials \n \nSyllabus\u2610Yes\u2612NoRemarks:Literature list\u2612Yes\u2610NoRemarks:The AI Revolution in Project \nManagement: Elevating Productivity with Generative AI Vijay Kanabar (Auteur), Jason Wong \n(Auteur) ISBN 978-0138297336 Project Management: A Systems Approach to Planning, \nScheduling, and Controlling Harold Kerzner  ISBN: 978-1119805373 Software Engineering Ian \nSommerville  ISBN: 978-0133943030 Engineering Software Products: An Introduction to \nModern Software Engineering, Global Edition, 1st edition Ian Sommerville  ISBN-13: \n9781292376356 https://en.wikibooks.org/wiki/LaTeX Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=325 Other, please specify:  \n\n",
        "2nd Semester \nTHEORETICAL COMPUTER SCIENCE 1 \nObjectives \nThis course covers basic principles and techniques in theoretical computer science. More \nspecifically, automata theory, formal languages and Turing machines will be the core part of the \ncourse. The course is structured into two main parts. In the first part, we introduce the basic \nconcepts of automata theory such as deterministic and non-deterministic automata, regular and \ncontext-free languages. We then move to more advanced concepts of automata theory and \ncomputation. The languages and methods covered in the course are the building blocks of the \nscientific foundation of computer science.  \n \n  \n \nCourse learning outcomes \nBy the end of this course, the students will be able to:1. Understand the hierarchy of regular, \ncontext-free and decidable languages.2. Know the formal definition of syntax and semantics of \nvarious types of computational models (including (non-)deterministic finite automata, regular \nexpressions, push-down automata, context-free grammars, Chomsky normal form, and Turing \nmachines).3. Understand how the various types of computational models relate to the hierarchy \nof languages.4. Given an informal or mathematical definition of a formal language, develop a \nmodel of a given type that generates that language, and vice versa.5. Given an informal or \nmathematical definition of a formal language, determine to which language class it belongs and, \nusing one of the pumping lemmas, prove that it does not belong to a language class that is \nlower in the hierarchy.6. Convert a computational model of a given type into an equivalent \ncomputational model of another given type. \nDescription \n1. Basic Automata Theory and Computability 1.1. Automata Theory: introduction, context, \nmotivation, history, notation, basic concepts 1.2. Motivation and history, Deterministic finite \nautomata 1.3. Non-deterministic finite automata, equivalence of deterministic and \nnon-deterministic automata 1.4. Regular expressions, closure properties of regular languages \n1.5. equivalence of regular languages and finite automata, non-regular languages 1.6. Pumping \nlemma for regular languages, Context-free languages, context-free grammars, parsing, \nambiguity 1.7. Pushdown automata  2. Advanced Automata Theory and Computability 2.1. \nInclusion of regular languages in context-free languages, equivalence of pushdown automata \nand context-free grammars 2.2. Chomsky normal forms, pumping lemma for context-free \nlanguages 2.3. Turing machines 2.4. Turing-decidability, Turing machine variants 2.5. \nChurch-Turing thesis, decidable problems  \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks: \n \nTask 1 : Mid-term written exam (50%)Grading scheme: 20 points (0-20)Objectives Exam 1: \nEvaluate the mastery of contents taught in the first half of the semester.\u200b Assessment rules: \n\n\u200bClosed exam without any supporting materials only eligible for students who take the course for \nthe first time\u200b Assessment criteria: The correctness of solutions to assigned questions\u200b Task 2: \n\u200bWritten exam\u200b (50%)Grading scheme: 20 points (0-20)Objectives Exam 2: Evaluate the mastery \nof contents taught in the second half of the semester.\u200b Assessment rules: Closed exam without \nany supporting materials only eligible for students who take the course for the first time and \npass the mid-term exam\u200b Assessment criteria: The correctness of solutions to assigned \nquestions\u200b Task 3: Written exam\u200b RETAKE (100%)Grading scheme: 20 points (0-20) Objectives \nFull Exam: Evaluate the mastery of all the contents given in the whole semester. Provide a \nchance for students who need retaking the exam.\u200b Assessment rules: Closed exam without any \nsupporting materials eligible for the students who fail in exams of previous semesters or the \nmid-term exam in the same semester.  The Full Exam is equivalent to the combination of Exam \n1 and Exam 2.\u200b Assessment criteria: The correctness of solutions to assigned questions\u200b   \nNote \nCourse materials \n \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nPublished on Moodle on a weekly basis \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nMichael Sipser, Introduction to the Theory of Computation, 3rd Ed. (EMEA adapta- tion), \nCengage Learning, 2013 \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2454 \n \nOther, please specify:\n \n\nCOMPUTING INFRASTRUCTURES 1 \nObjectives \nComputing professionals should not regard computers as black boxes that execute programs by \nmagic. This course first aims to develop a deeper understanding of the hardware and software \nenvironment upon which all computing is based. Students should acquire an understanding of a \ncomputer system\u2019s functional components, their characteristics, performance, and interactions.  \nThe course will cover how data are represented in memory and how they are manipulated \nduring computations. This course provides an introduction to operating systems, which define \nan abstraction of hardware and manage resource sharing among users. For instance, the \ncourse introduces the concept of processes and describe the difference between kernel and \nuser execution modes. \n \nCourse learning outcomes \nAt the end of the course the student will be able to: \n \n\u2022Explain why everything is data, including instructions, in computers.\u2022Describe how positive \nintegers are stored in unsigned representation.\u2022Describe how negative integers are stored in \ntwo\u2019s-complement representation.\u2022Describe how floating-point numbers are stored in IEEE754 \nrepresentation.\u2022Describe the internal representation of non-numeric data, such as characters \nand strings.\u2022Convert numerical data from one format to another.\u2022Explain how fixed-length \nnumber representations affect accuracy and precision.\u2022Explain the organization of the classical \nvon Neumann machine and its major functional units.\u2022Describe how an instruction is executed in \na classical von Neumann machine.\u2022Understand the mapping between high-level language code \nand assembly/machine language code.\u2022Explain different instruction formats, such as addresses \nper instruction and variable length vs. fixed length formats.\u2022Explain the basic concepts of \ninterrupts and I/O operations.\u2022Identify the main types of memory technology (e.g., SRAM and \nDRAM) and their relative cost and performance.\u2022Explain memory hierarchy and \ncost-performance trade-offs.\u2022Describe how the use of memory hierarchy (cache, virtual \nmemory)  reduces the effective memory latency.\u2022Explain how interrupts are used to implement \nI/O control and data transfers.\u2022Explain basic instruction level parallelism using \npipelining.\u2022Explain the importance of spatial and temporal locality in determining \nperformance.\u2022Explain the objectives and functions of modern operating systems.\u2022Describe how \ncomputing resources are used by application software and managed by system \nsoftware.\u2022Contrast kernel and user mode in an operating system\u2022Describe the need for memory \nprotection in an OS.\u2022Discuss the advantages and disadvantages of using interrupt \nprocessing.\u2022Explain the different states that a task may be in\u2022Describe reasons for using \ninterrupts, dispatching, and context switching to support concurrency in an operating system. \n\u2022Describe the difference between processes and threads.\u2022Explain how processes and threads \nare created and terminated.\u2022Compare and contrast common algorithms used for pre-emptive \nand non-pre-emptive scheduling. \nDescription \nCourse content Overview and history of computer architectureMachine level data \nrepresentation: \u2022 Bits, bytes, and words\u2022 Numeric data representation and number bases: \nfixed\u2010point, floating\u2010point, signed and two\u2019s\u2010complement representations, \u2022 Representation of \n\nnon\u2010numeric data such as characters\u2022 Overflow and underflow of numeric data typesComputer \narchitecture: \u2022 Basic building blocks of a computer\u2022 von Neumann machine architecture\u2022 Control \nunit, instruction fetch, decode, and execution.\u2022 Shared memory multiprocessors/multicore \norganization\u2022 Main memory organization and operations\u2022 Cache memories and storage \nsystems\u2022 Memory hierarchy: the importance of temporal and spatial locality\u2022 Direct-memory \naccess (DMA)\u2022 Instruction set architecture (ISA) \u2022 Instruction formats\u2022 Data manipulation, \ncontrol, I/O\u2022 Addressing modes\u2022 Assembly and machine language \u2022 Subroutine call and return \nmechanisms.\u2022 I/O and interrupts\u2022 Heap, stack, data, and code segments\u2022 Branch prediction, \nspeculative execution, out\u2010of\u2010order executionOperating Systems (OS):\u2022 Role and purpose of \nthe operating system\u2022 OS main abstractions, processes, and resources\u2022 Concept of application \nprogram interfaces (APIs) \u2022 Use of libraries\u2022 The evolution of hardware/software techniques and \napplication needs\u2022 Device organization\u2022 Interrupts: principles and implementations\u2022 Concept of \nuser/system state and protection, transition to kernel mode\u2022 Process scheduling, scheduling \npolicies and context switching.\u2022 The role of interrupts.\u2022 The concept of threads versus \nprocesses. \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam\u200b (60%)Grading scheme: 20 points (0-20)Objectives: Assess students \nlearning.\u200b Assessment rules: Closed-book exam. \u200b Assessment criteria: \u200bCorrect and \nwell-explained answers to the questions. Demonstrate the acquisition of the learning outcomes \nof the course. No minimum passing grade is required for the exam but the final grade, \ncalculated as 0.6*Task 1 + 0.4*Task 2, must be greater than or equal to 10 to pass the course.\u200b \nTask 2: Take-home assignment\u200b (40%)Grading scheme: 20 points (0-20)Objectives: Assess \nstudents learning and improve learning. Identify gaps between what students know and can do \nand what they need to know and be able to do.\u200b Assessment rules: Each week students must \nhand in an assignment. Assignments are submitted electronically. Over the course of semester, \nfour assignments are taken at random to be graded. Those four assignments together weight \n40% of the final grade (10% each).  Assessment criteria: Correct and well-explained answers to \nthe questions. Demonstrate the acquisition of the concepts presented during the lectures. No \nminimum passing grade is required for the assignments but the final grade, calculated as \n0.6*Task 1 + 0.4*Task 2, must be greater than or equal to 10 to pass the course.\u200b Task 3: \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Students having failed the course \nwill have to re-sit the final written exam at a next exam session. The exam will count for the \nentirety of the final grade. However, optionally, students may decide to keep the grade obtained \nfor the assignments, which will then count for 40% of the final grade. The minimum passing final \ngrade for the course is 10.\u200b Assessment rules: \u200bClosed-book exam.\u200b Assessment criteria: Correct \nand well-explained answers to the questions. Demonstrate the acquisition of the learning \noutcomes of the course. The minimum passing grade is 10/20.\u200b    \nNote \nCourse materials \n \n\nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \n\u2013 Structured Computer Organization: International Edition, by  Andrew S. Tanenbaum, Todd \nAustin, Person, 6th edition, 2012.- Modern operating systems, by Andrew S Tanenbaum, \nHerbert Bos, 4th edition, 2015.- Operating System Concepts, by Abraham Silberschatz et al, 8th \nedition, 2008.- Computer Systems: a Programmer\u2019s Perspective, by Randal E. Bryan, David R. \nO\u2019Hallaron, 2nd edition, 2011. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2453 \n \n \n\nNETWORKING AND COMMUNICATION \nObjectives \nNetworking and communication play a central role in interconnected computer systems that are \ntransforming the daily lives of billions of people. The Internet provides connectivity for networked \napplications that serve ever-increasing numbers of individuals and organizations around the \nworld. Many computing applications that are used today would not be possible without \nnetworks. The objective of the course is to introduce networks in general, and TCP/IP networks \nin particular. The course will introduce current network architectures, application-level protocols \n(e.g., HTTP), transport protocols (TCP/UDP), routing and IP. The course will introduce Medium \nAccess Control (MAC) techniques and quantitative performance measures for networks. The \ncourse will also provide a first introduction to mathematical concepts of networks. \n \nCourse learning outcomes \nBy the end of this course, the students will be able to:- understand the role and operation of \nnetworking and communication in networked computer systems,- explain how network structure \nand communication protocols affect the behavior of distributed applications,- describe key \nnetworking and communication principles and their specific instantiations on the Internet,- apply \nthe concepts in new technological settings. \nDescription \n1. Introduction to Computer Networks and the Interneta. Importance of networking in \ncontemporary computing, and associated challenges.b. Organization of the Internet (e.g., users, \nInternet Service Providers, autonomous systems, content providers, content delivery \nnetworks).c. Switching techniques (e.g., circuit and packet).d. Layers and their roles \n(application, transport, network, datalink, and physical).e. Layering principles (e.g., \nencapsulation and hourglass model).f. Network elements (e.g., routers, switches, hubs, access \npoints, and hosts).g. Basic queueing concepts (e.g., relationship with latency, congestion, \nservice levels, etc.)2. Networked Applicationsa. Naming and address schemes (DNS, IP \naddresses, and Uniform Resource Identifiers).b. Distributed application paradigms (e.g., \nclient/server, peer-to-peer, cloud, edge, and fog).c. Diversity of networked application demands \n(e.g., latency, bandwidth, and loss tolerance).d. An explanation of at least one application-layer \nprotocol (e.g., HTTP, SMTP, and POP3).e. Interactions with TCP, UDP, and Socket APIs.3. \nReliability Supporta. Unreliable delivery (e.g., UDP).b. Principles of reliability (e.g., delivery \nwithout loss, duplication, or out of order).c. Error control (e.g., retransmission, error \ncorrection).d. Flow control (e.g., stop and wait, window based).e. Congestion control (e.g., \nimplicit, and explicit congestion notification).f. TCP and performance issues (e.g., Tahoe, Reno, \nVegas, Cubic, QUIC).4. Routing and Forwardinga. Routing paradigms and hierarchy (e.g., \nintra/inter domain, centralized and decentralized, source routing, virtual circuits, QoS).b. \nForwarding methods (e.g., forwarding tables and matching algorithms).c. IP and Scalability \nissues (e.g., NAT, CIDR, BGP, different versions of IP).5. Single-Hop Communicationa. \nIntroduction to error detection and correction techniques.b. Medium Access Control (MAC) (e.g., \nrandom access and scheduled access).c. Ethernet.d. Switching.e. Link virtualization. \nAssessment \nAssessment modality:  \n \n\nType of assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Midterm (50%)Grading scheme: 20 points (0-20)Objectives: Assess \nstudents\u2019 knowledge, skills, and abilities. Assessment rules: The students will have 45 minutes \nto complete the written exam. Only clearly crossed answers will be marked as correct. In case of \ndoubts, the side calculations will also be taken into consideration. Books, lecture notes, and \ncalculators are allowed to be used during the exam. No communication device whatsoever is \nallowed during the exam (e.g., laptop, smartphone, smartwatch, etc.).Assessment criteria: A \nnumber of points will be assigned for each correct answer. The number of points for each \ncorrect answer will depend on the difficulty of the question.Task 2: Written exam (50%)Grading \nscheme: 20 points (0-20)Objectives: Assess students\u2019 knowledge, skills, and abilities. \nAssessment rules: The students will have 45 minutes to complete the written exam. Only clearly \ncrossed answers will be marked as correct. In case of doubts, the side calculations will also be \ntaken into consideration. Books, lecture notes, and calculators are allowed to be used during the \nexam. No communication device whatsoever is allowed during the exam (e.g., laptop, \nsmartphone, smartwatch, etc.).Assessment criteria: A number of points will be assigned for \neach correct answer. The number of points for each correct answer will depend on the difficulty \nof the question.Task 3: Take-home assignmentGrading scheme:Pass/Fail Up to 20% bonus (4 \npoints)Objectives: Understand network protocols in action by observing the sequence of \nmessages exchanges between two protocol entities, delving down into the details of protocol \noperation, and causing protocols to perform certain actions and then observing these actions \nand their consequences.Assessment rules: Take-home assignments will be solved by groups of \nat least 2 people/group. At least 4 different assignments will be given during the semester. \nTake-home assignments are not mandatory. Each passed assignment will give the student a 5% \nbonus (1 point), up to a maximum of 20% (4 points). The bonus will be added to the final grade \nof the written exam only if the student obtained the minimum passing grade (i.e., 10 \npoints).Assessment criteria: Each submitted assignment will receive a Pass/Fail assessment \nbased on its correctness.Task 4: RETAKEGrading scheme: 20 points (0-20)Objectives: Students \nhaving failed the course will have to re-sit the written exam at a next exam session. Any bonus \npreviously obtained will remain valid and will be added to the final grade of the written exam \nonly if the student obtained the minimum passing grade (i.e., 10 points).Assessment rules: \nSame as Task 1 and 2Assessment criteria: Same as Task 1 and 2 \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n\n \n\u2612Yes  \u2610No \n \nRemarks: \n \nComputer Networking: A Top Down Approach 8th edition (Pearson) \u2013 available at the LLC. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2455 \n \nOther, please specify: \n \n \n \n\nLINEAR ALGEBRA 2 \n \nObjectives \nFundamental notions of Linear Algebra \n \nCourse learning outcomes \nThe students recall and are able: \n \nTo formulate the basic notions of linear algebra. \n \nTo solve small linear algebra problems by performing calculations and applying algorithms. \n \nTo understand small proofs and to look for examples and counterexamples. \nDescription \nGeneral vector spaces (base change); matrix spaces, matrix transformations;  Eigenvalues and \nEigenvectors; complex vector spaces ; inner product spaces, orthogonality; quadratic forms; \ngeneral linear transformations; if time permits, some applications of linear algebra. \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam \u2013 Midterm exam 1 (15%)Grading scheme: 20 points (0-20)Objectives: \nWritten test with exercises.Assessment rules: Only 6 pages of personal notes are allowed. No \ncalculators.Assessment criteria: The tests are graded. The average of the two best midterms \ncounts as mark.Task 2: Written exam \u2013 Midterm exam 2 (15%)Grading scheme: 20 points \n(0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of personal notes \nare allowed. No calculators.Assessment criteria: The tests are graded. The average of the two \nbest midterms counts as mark.Task 3: Written exam \u2013 Midterm exam 3 (15%)Grading scheme: \n20 points (0-20)Objectives: Written test with exercises.Assessment rules: Only 6 pages of \npersonal notes are allowed. No calculators.Assessment criteria: The tests are graded. The \naverage of the two best midterms counts as mark.Task 4: Written exam \u2013 Final exam \n(70%)Grading scheme: 20 points (0-20)Objectives: Written test with exercises.Assessment \nrules: Only 6 pages of personal notes are allowed. No calculators.Assessment criteria: The test \nis graded.Task 5: Oral exam, optionalGrading scheme: 20 points (0-20), Objectives: Oral exam \n(in case of justified absence to >1 midterms or as additional evaluation in case of fraud \nsuspicion)Assessment rules: Discussion with questions (theoretical questions and \nexercises)Assessment criteria: Correct and partially correct answers contribute positively to the \ngrade.Task 6: Either final written exam (100%) or the same modalities as the regular students \n(to be selected by each retaking student at the beginning of each semester)Grading scheme: 20 \npoints (0-20), Objectives: \u200bWritten test with exercises. In case of fraud suspicion, the \u200bexam can \nbe replaced by an oral exam (as described in Task 5). Assessment rules: Only 6 pages of \npersonal notes are allowed. No calculators.Assessment criteria: The test is graded. \nNote \n\nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nMoodle page \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nMoodle page \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=2456 \n \nOther, please specify: \n \n\nPROGRAMMING FUNDAMENTALS 2 \nObjectives \nThis course is about object-oriented programming, a paradigm that enables programmers to \ndeal with program complexity by decomposing programs into small, self-contained units that can \neasily be reused and adapted across projects. The course will have a practical flavour, with \ndemonstrations, examples, and assignments. We will rely on the Java programming language to \nconcretize object-oriented concepts through the development of programs.  Java is among the \nfive most popular and most demanded programming languages on the job market; it is used in \nWeb-based, Android, and embedded systems. Java is popular because it is easy to learn, has a \nrich set of programming APIs, and is supported by many development tools. In this course, \nthrough Java, the students will learn to develop software applications of medium complexity \nrelying on class inheritance and decomposition, known Java data structures, exception \nhandling, file processing, GUIs, and concurrency support. \n \nCourse learning outcomes \nThe course will lead to the following learning outcomes:Design, code, test, and debug Java \nprograms that follow an object-oriented design and uses each of the following fundamental \nprogramming constructs: classes, assignment and expressions, console I/O, conditional and \niterative structures, functions with parameter passing, structured data types provided with the \nlanguage, use file I/O to provide persistence across multiple executions, rely on \nexception-handling mechanism.Write programs of medium complexity that use Java GUI APIs \nand rely on concurrency mechanisms.Develop tests for program modules and apply a variety of \nstrategies to design test cases.Build, execute and debug programs using a modern IDE and \nassociated tools such as visual debuggers. \nDescription \nThe course has the following lesson topics:1. Development environments: shell, editor, java \ncompiler vs runtime, source code control, build automation tools, IDEs,2. Java Basics: Types, \nControl Flow, and I/O operations,3. Inheritance and Polymorphism in Java,4. Implementing data \nstructures in Java,5. Java collections,6. Parametric polymorphism and generics,7. Exception \nhandling in Java,8. File processing,9. Concurrency in Java,10. Java GUIs, 11. Event-driven \nprogramming in Java,12. Static methods, Nested classes, Networking,13. Persistence,14. \nLambda and Streams.They cover for the following teaching objectives:A) Principles of \nobject-oriented programming and designA.1) Decomposition into objects carrying state and \nhaving behaviour through the definition of classes (fields, methods, and constructors), \nsubclasses, inheritance, and method overriding.A.2) Idioms for encapsulation (visibility, \ninterfaces, and abstract classes).A.3) Dynamic dispatching of method calls definition of \nmethod-call.B) The Java language as an example of object-oriented languageB.1) Basic \nconcepts such as variables, primitive data types, expression evaluation, assignment. B.2) Basic \nconstructs such as conditional and iterative structures and flow of control. B.3) Key modularity \nconstructs such as methods and classes, and related concepts like parameter passing, scope, \nabstraction, data encapsulation.B.4) Input and output using files, console, and APIs B.5) \nStructured data types available in the Java APIs (e.g., the collection framework) B.6) GUI \nLibraries B.7) RecursionB.8) Dealing with runtime errors in programs (exception handling) B.9) \nStrings and string processingC) Data structures in JavaC.1) Implementing standard abstract \n\ndata types such as lists and trees in JavaC.2) The Java Collections package for lists, trees, \nstacks, queues, sets, and mapsC.3) Performance implications of choice of data structure(s)D) \nPrinciples of reactive programmingD.1) Components of reactive programming: event-source, \nevent signals, listeners and dispatchers, event objects, adapters, event-handlers.D.2) Use of \nreactive programming in Java, with a GUI case study: Defining event handlers/listeners, \nParameterization of event senders and event arguments, externally generated events, and \nprogram-generated events D.3) Conceptual separation between Model, View, and Controller.E) \nParallelism and concurrency in JavaE.1) Basic constructs and the concurrent Package.F) Basic \nsoftware testing principlesF.1) Deriving test cases from functional specifications and \nimplementationF.2) The Junit frameworkF.3) Code coverageG) Development environmentsG.1) \nShells, editors, java compiler vs runtime.G.2) Source code control, build automation tools, IDEs. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Mid-term exam (30%) \nGrading scheme: 20 points (0-20)Objectives: Written exam to assess students\u2019 knowledge of \nthe basics of Java and OO programming. Consists of short programming exercises, open \nquestions, and quizzes.\u200b Assessment rules: \u200bAll enrolled students. Laptop, smartphones, cheat \nsheets, and books are not allowed.\u200b Assessment criteria: Correctness of answers, program \ndesign, functioning, and code style.\u200b Task 2: Written exam\u200b (70%)Grading scheme: 20 points \n(0-20)Objectives: Programming exercises to assess that students have reached the objectives \nof the course. \u200b Assessment rules: \u200bAll enrolled students. Laptop, smartphones, cheat sheets, and \nbooks are not allowed.\u200b Assessment criteria: Correctness of program design, functioning, and \ncode style.\u200b Task 3: RETAKEGrading scheme: 20 points (0-20)Objectives: Programming \nexercises to assess that students have reached the objectives of the course. The result of \nmid-term exam is not considered for the final grade. Assessment rules: All enrolled students. \nLaptop, smartphones, cheat sheets, and books are not allowed.\u200b Assessment criteria: \nCorrectness of program design, functioning, and code style.\u200b  \nNote \n Course materialsSyllabus \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: Available on Moodle. Literature list \u200b\u2612\u200bYes\u200b\u2610\u200bNo \nRemarks: 1) Building Java Programs, 4th Edition. Stuart Reges, Marty Stepp. Pearson. 2) \nLearning Java. Marc Loy, Patrick Niemeyer, Daniel Leuck. 6th Edition. O\u2019Reilly Media. Moodle \npage \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: https://moodle.uni.lu/course/view.php?id=2452 Other, please \nspecify:  \n \n \n\nBACHELOR SEMESTER PROJECT 2 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following. \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself. The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum. \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project.  \nAssessment \nAssessment modality: Combined assessment \n \nTask 1: Final report and in-person presentation (100%) \n \nGrading scheme: 20 points (0-20)Objectives: Assess the quality and quantity of work done \nduring the semester.Assessment rules: Time constrained submissions.Assessment criteria: The \ndetailed criteria are specific to each project subject and applied on the following weighted \ndeliverables:\u2022technical & scientific quality of the final report, primary language (60%)\u2022technical & \nscientific quality of the final in-person presentation, primary language (30%)\u2022technical & \nscientific quality of the final report, secondary language summary (5%)\u2022technical & scientific \nquality of the final in-person presentation, secondary language summary (5%)Task 2: Retake \n(100%)Grading scheme: 20 points (0-20)Objectives: Option to repeat a previously failed project \n(with a final assessment of <10 points) with the same topic and under the same \nsupervisor.Assessment rules: The same deliverables as for the previously failed project must be \nresubmitted under the given time constraints.Assessment criteria: Same as for Task 1. \nNote \nSyllabus\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageLiterature \nlist\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=2457\n \n\n",
        "3rd Semester \nSTATISTICS FOR COMPUTER SCIENTISTS \nObjectives \nStatistical methods are central in data science, machine learning, and computer science at large \nas they provide a sound framework for understanding and making sense of the data.  In this \ncourse whose orientation is practical, students will learn the foundation to choose and apply the \nproper statistical techniques to solve a given problem. Practice exercises will develop \nproficiency in the Python programming language and in data analysis in general. \n \nCourse learning outcomes \nAt the end of the course the student will be able to:\u2022Understand the basic concepts: population, \nsample, measures of dispersion, variance.\u2022Display data graphically and interpret graphs (e.g., \nhistograms).\u2022Recognize, describe, and calculate means, medians, quantiles, variances, \ninterquartile ranges.\u2022Compute confidence intervals with formulas and \nbootstrapping.\u2022Understand why random sampling can reduce bias and yield a higher quality \ndata set.\u2022Formulate and understand the concept of data correlation.\u2022Data transformation: data \ncleaning and dimension reduction.\u2022Apply Principal Component Analysis (PCA) to dimensionality \nreduction problems.\u2022Apply linear regression to curve-fitting problems.\u2022Understand the concept \nof overfitting.\u2022Discuss and apply cross-validation in the context of overfitting and model selection \n(e.g., degree of polynomials in a regression context).\u2022Apply statistical tests to compare different \ndesign candidates.\u2022Understand how statistics can be used to set engineering simulation \nparameters with respect to target confidence level.\u2022Apply statistics to the analysis of financial \ndata (e.g., correlation between markets).\u2022Demonstrate proficiency in Python. \nDescription \nThe course covers the following topics:\u2022 Overview of the use of statistics in data analysis, \nmachine learning and engineering. \u2022 Descriptive statistics and exploratory data analysis: \npopulation, sample, mean, median, variance, empirical distribution histogram, cumulative \ndistribution function, quantile, box plots, density plots, scatterplot and coefficient of correlation.\u2022 \nInferential statistics: sampling, sampling bias and bootstrap.\u2022 Confidence intervals and margin of \nerrors.\u2022 A/B testing.\u2022 Statistical significance and p-values.\u2022 Hypothesis tests: one way versus \ntwo ways tests.\u2022 Performance comparisons, evaluating experiments.\u2022 Statistically-sound \nsimulation-based design in electrical engineering.\u2022 Basic statistical methods used in financial \ndata analysis.\u2022 Statistics in the performance evaluation of safety-critical computer systems. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Written exam \n(60%)Grading scheme: 20 points (0-20)Objectives: Assess students learning.Assessment rules: \nClosed-book exam. Assessment criteria: Correct and well-explained answers to the questions. \nDemonstrate the acquisition of the learning outcomes of the course. No minimum passing grade \nis required for the exam but the final grade, calculated as 0.6*Task 1 + 0.4*Task 2, must be \ngreater than or equal to 10 to pass the course.Task 2: Take-home assignment (40%)Grading \nscheme: 20 points (0-20)Objectives: Assess students learning and improve learning. Identify \ngaps between what students know and can do, and what they need to know.Assessment rules: \nGroup work (2 or 3 students per group).Assessment criteria: Correct and well-explained \nanswers to the questions. The quality of the report (writing, presentation) is an important \n\nassessment criterion. Submissions will be systematically checked for potential plagiarism. Task \n3: RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Students having failed the \ncourse will have to re-sit the final written exam at a next exam session. The exam will count for \nthe entirety of the final grade. However, optionally, students may decide to keep the grade \nobtained for the assignments, which will then count for 40% of the final grade. The minimum \npassing final grade for the course is 10.Assessment rules: Closed-book exam.Assessment \ncriteria: Correct and well-explained answers to the questions. Demonstrate the acquisition of the \nlearning outcomes of the course. The minimum passing grade is 10/20. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on MoodleLiterature list\u2612Yes\u2610NoRemarks:-\u201cPractical \nStatistics for Data Scientists\u201d, P. Bruce, A. Bruce, P.Gedeck, second edition, O\u2019Reilly, \n2020.-\u201cPerformance Evaluation Of Computer And Communication Systems\u201d, J.Y. Le Boudec, \nEPFL press, 2010. Available at https://leboudec.github.io/perfeval/  Moodle \npage\u2612Yes\u2610NoRemarks:TBC \n \n\nDISCRETE MATHEMATICS 2 \nObjectives \nDiscrete structures are foundational material for computer science. Relatively few computer \nscientists will be working primarily on discrete structures, but many other areas of computer \nscience require the ability to work with concepts from discrete structures. Second part of the \ncourse focuses on the data analysis. Methods used come from combinatorics, probability theory \nand statistics \n \nCourse learning outcomes \nAt the end of the course the student will be able to:-Find cardinalities of discrete structures.-Use \ncounting for proofs.-Compute probabilities of events based on observations, and \nindependence.-Take decisions via probabilities. \nDescription \n1. Discrete Structures (DS)1.1. Basics of Counting1.1.1. Counting arguments: Set cardinality \nand counting, Sum and product rule, Inclusion-exclusion principle.1.1.2. The pigeonhole \nprinciple1.2. Permutations and combinations, Pascal\u2019s identity, The binomial theorem1.3. \nSolving recurrence relations (cross-reference: AL/Basic Analysis): An example of a simple \nrecurrence relation, such as Fibonacci numbers.2. Discrete Probability2.1. Finite probability \nspace, events2.2. Axioms of probability and probability measures2.3. Conditional probability, \nBayes\u2019 theorem2.4. (Conditional) Independence2.5. Expectation and its Properties, Mean and \nVariance2.6. Integer Random Variables (Bernoulli, Binomial, etc..)2.7. Continuous Random \nVariables (Gauss, Poisson, etc..)2.8. Law of Large Numbers, Central Limit Theorem \nAssessment \nAssessment modality:   Combined assessmentAssessment tasks \n \nTask 1: Written exam (35%)Grading scheme: 20 points (0-20)Objectives: Check if the students \nare capable of formalisation, and computation of counting problems. Furthermore, algebraic \nmethods are expected to be known by then. Assessment rules: One A4 handwritten cheat \nsheet. Possibly needed tables are provided. The exam is based on both questions and longer \nproblems.Assessment criteria: Correctness, and chosen path to a solution.Task 2: Written exam \n(65%)Grading scheme: 20 points (0-20)Objectives: Final exam counting and \nProbabilitiesAssessment rules: One A4 handwritten cheat sheet. Possibly needed tables are \nprovided. The exam is based on both questions and longer problems.Assessment criteria: \nCorrectness, and chosen path to a solutionTask 3: Oral exam \u2013 RETAKE (100%)Grading \nscheme: 20 points (0-20)Objectives: Retake students will undergo evaluation to determine their \nproficiency in formalization and computation of counting problems, as well as their grasp of \nfundamental concepts in probability.Assessment rules: Oral examAssessment criteria: 75% CPE \n1 and 25% CPE 2 \nNote \nSyllabus\u2612Yes\u2610NoRemarks:Available on the Moodle page.Literature \nlist\u2612Yes\u2610NoRemarks:Based on the lecture notes from MIT, see \nhttps://ocw.mit.edu/courses/6-042j-mathematics-for-computer-science-fall-2005/pages/lecture-n\notes/ Moodle page\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3329 Other, \nplease specify:All the lecture slides and old videos are shared in Moodle page \n\nINFORMATION MANAGEMENT 1 \nObjectives \nInformation Management is primarily concerned with the capture, digitization, representation, \norganization, transformation, and presentation of information; algorithms for efficient and \neffective access and updating of stored information; data modelling and abstraction; and \nphysical file storage techniques. The student needs to be able to develop conceptual and \nphysical data models, determine which IM methods and techniques are appropriate for a given \nproblem, and be able to select and implement an appropriate IM solution that addresses \nrelevant design concerns including scalability, accessibility, and usability. \n \nCourse learning outcomes \nAt the end of the course, students will be able to:-design data models in different \nrepresentations (object-oriented, hierarchical, network-based, relational)-avoid redundancies \nand inconsistencies in the resulting models.-use different query languages to create and query \nlarge databases.-solve and implement individual information-management use-cases. \nDescription \nCourse content 1. Information Management (IM) 1.1. Information Management Concepts 1.1.1. \nInformation systems as socio-technical systems 1.1.2. Basic information storage and retrieval \n(IS&R) concepts. 1.1.3. Information capture and representation 1.1.4. Supporting human needs: \nsearching, retrieving, linking, browsing, navigating1.1.5. Information management applications \n1.1.6. Declarative and navigational queries, use of links 1.1.7. Content analysis and indexing \n1.1.8. Quality issues: reliability, scalability, efficiency, and effectiveness 1.2. Relational \nDatabases 1.2.1. Mapping conceptual schema to a relational schema 1.2.2. Keys and \nforeign-keys, referential integrity 1.2.3. Relational algebra and relational calculus 1.2.4. \nRelational database design 1.2.5. Functional dependencies 1.2.6. Decomposition of a schema; \nlossless-join and dependency-preservation properties of a decomposition. 1.2.7. Candidate \nkeys, super keys, and closure of a set of attributes 1.2.8. Normal forms (2NF, 3NF BCNF) 1.2.9. \nMulti-valued dependencies (4NF) 1.2.10. Join dependencies (PJNF, 5NF) 1.2.11. \nRepresentation theory 1.3. Query Languages 1.3.1. Overview of database languages 1.3.2. \nSQL (data definition, query formulation, update sublanguage, constraints, integrity) 1.3.3. \nSelect-project-join queries. 1.3.4. Aggregations and group-by 1.3.5. Over-operator and sliding \nwindows. 1.3.6. Subqueries in SQL 1.3.7. Constraints and triggers 1.3.8. Stored procedures and \nPL/SQL1.3.9. QBE and 4th-generation environments 1.3.10. Different ways to invoke \nnon-procedural queries in conventional languages. 1.3.11. Overview of other major query \nlanguages (e.g., XPATH, SPARQL) \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written or oral midterm \nexam (50%)Grading scheme: 20 points (0-20)Objectives: Reproduction and application of the \ncourse contentsAssessment rules: Closed book written exam (whole class) or 30 minutes \nindividual oral exam.Assessment criteria: Exam results are based on the correctness of the \nprovided answers.Task 2: Written or oral final exam (50%)Grading scheme: 20 points \n(0-20)Objectives: Reproduction and application of the course contentsAssessment rules: Closed \nbook written exam (whole class) or 30 minutes individual oral exam.Assessment criteria: Exam \nresults are based on the correctness of the provided answers.Task 3: Active participation \u2013 \n\nPresentation of exercise solutionsUp to 2 bonus pointsGrading scheme: 20 points \n(0-20)Objectives: Solution of exercise problemsAssessment rules: A correct presentation (in \nclass) of the solution to one problem of an exercise sheet yields 1 bonus point. Up to 2 bonus \npoints can be achieved per student this way per semester. Bonus points are added on top of the \npoints the student has achieved through the exams. At most 20 points can be achieved in \naltogether.Assessment criteria: Correctness of the provided solutions.Task 4: Written exam \u2013 \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Reproduction and application of \nthe course contentsAssessment rules: Closed book written exam (whole class) or 30 minutes \nindividual oral exam.Assessment criteria: Solution of exercise problems \nNote \nCourse materialsSyllabus\u2612Yes\u2610NoRemarks:Available on MoodleLiterature \nlist\u2612Yes\u2610NoRemarks:Database Systems: The Complete Book (ISBN: \n978-0131873254)Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3332 \n \n\nPROGRAMMING FUNDAMENTALS 3 \nObjectives \nProgramming fundamentals 3 is a two parts course where you will learn functional programming \nand parallel programming. The first part focusses on the foundation of the functional language \nOCaml. We show that functional programs are often shorter and more elegant than their \nimperative counterparts. In the second part, we introduce concurrent and parallel programming. \nWe discuss general synchronisation issues of concurrency models such as deadlock, livelock \nand starvation. We present the shared state and message-passing programming models aiming \nat solving these issues. Moreover, we connect both paradigms as the full class will be in the \nnewest OCaml 5.0 language, which includes a new multicore extension. \n \nCourse learning outcomes \nAt the end of the course the student will:-Know how to program and reason about programs in a \npurely functional programming style. -Solve problems in Haskell in a concise, yet expressive, \nmanner.-Decompose complex problems into smaller, manageable subproblems.-Think \nrecursively, make use of higher-order functions, understand the benefits of type systems, and \nlearn how some programming languages like Haskell avoid unnecessary computations via lazy \nevaluation.-Know common data structures (like stacks, queues, trees, self-balancing trees, and \ngraphs) and how these can be implemented in a functional language with data immutability. \n-Know how to analyse the run-time complexity of operations on these data structures. \n-Understand advanced concepts and abstractions of functional programming such as functors, \napplicative functors, and monads. Understand how to approach and solve classic computer \nscience problems in Haskell with essential techniques such as recursion, permutation \ngeneration, brute-force and binary search. \nDescription \n1. Introduction to FP and Haskell 1.1. Programming languages paradigms 1.2. Basic Haskell \nsyntax 1.3. Polymorphism and typeclasses 1.3.1. Types, type inference and polymorphism \n1.3.2. Typeclasses 1.4. Recursion 1.4.1. Thinking recursively 1.4.2. Sorting algorithms 1.5. \nFunctions 1.5.1. Pointfree style and infix functions 1.5.2. Composition 1.5.3. Lambda \nexpressions 1.6. Higher order functions 1.6.1. Maps and filters 1.6.2. Folding 1.6.3. Currying \nand partial function application 1.7. Data types 1.8. Input/Output 1.9. Functional styles in other \nprogramming languages 2. Purely functional data structures 2.1. Data immutability 2.2. Trees \n2.2.1. Binary search tree2.2.2. Self-balancing tree (AVL) 2.3. Lazy evaluation of infinite data \nstructures 2.4. Graphs and common graph algorithms in FP3. Arithmetic problems 4. Advanced \nconcepts in FP 4.1. Functors 4.2. Applicative functors 4.3. Monads 4.3.1. Maybe, Either 4.3.2. \nIO 4.3.3. State 5. Solving classic computer science problems, using Haskell  \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Take-home assignment \n(10%)Grading scheme: 20 points (0-20)Objectives: Develop basic algorithms that avoid \nassigning to mutable state using recursion.Assessment rules: Homework assignments are \nrequired to be submitted individually through Moodle. Each student must complete the \nhomework assignments on their own.Assessment criteria: Successfully solves the stated \nproblem with computational efficiency. Code demonstrates conciseness, clarity, and adherence \nto a functional programming style.Task 2: Take-home assignment (10%)Grading scheme: 20 \n\npoints (0-20)Objectives: Solve classic computer science problems with compositional reasoning \nand higher order functions.Assessment rules: Homework assignments are required to be \nsubmitted individually through Moodle. Each student must complete the homework assignments \non their own.Assessment criteria: Successfully solves the stated problem with computational \nefficiency. Code demonstrates conciseness, clarity, and adherence to a functional programming \nstyle.Task 3: Take-home assignment (10%)Grading scheme: 20 points (0-20)Objectives: \nUnderstand AVL trees and analyze the worst-case time complexity of each \noperation.Assessment rules: Homework assignments are required to be submitted individually \nthrough Moodle. Each student must complete the homework assignments on their \nown.Assessment criteria: Successfully solves the stated problem with computational efficiency. \nCode demonstrates conciseness, clarity, and adherence to a functional programming style. \nAdditionally, provides analysis of the run-time complexity of operations.Task 4: Take-home \nassignment (10%)Grading scheme: 20 points (0-20)Objectives: Understand and apply abstract \nconcepts of FP, namely monadsAssessment rules: Homework assignments are required to be \nsubmitted individually through Moodle. Each student must complete the homework assignments \non their own.Assessment criteria: Successfully solves the stated problem with computational \nefficiency. Code demonstrates conciseness, clarity, and adherence to a functional programming \nstyle.Task 5: Written exam (60%)Grading scheme: 20 points (0-20)Objectives: Evaluate the \nstudents\u2019 comprehension of the course\u2019s material.Assessment rules: Students are permitted to \nbring a single \u201ccheat sheet\u201d consisting of an A4-sized paper, on which they can include any \nnecessary notes. A minimum grade of 8/20 in the final written exam is required to pass the \ncourse.Assessment criteria: Each question has a stipulated mark clearly indicated on the \nexam.Task 6: Written exam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: \nStudents having failed the course may re-sit the final exam at a next exam session. The \nobjective is to reassess the students\u2019 comprehension of the course\u2019s material.Assessment rules: \nStudents are permitted to bring a single \u201ccheat sheet\u201d consisting of an A4-sized paper, on which \nthey can include any necessary notes. For re-sits, the exam constitutes 100% of the final \ngrade.Assessment criteria: Each question has a stipulated mark clearly indicated on the exam. \nNote \nCourse materials \n \nSyllabus\u2610Yes\u2612NoRemarks:Literature list\u2612Yes\u2610NoRemarks:[1] Programming in Haskell, 2nd \nEdition, by Graham Hutton. September 2016, Cambridge University Press, ISBN-13 \n978-1316626221.[2] Learn You a Haskell for Great Good!, by Miran Lipovaca.  April 2011, No \nStarch Press, ISBN-13 978-1593272838.Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3330 \n \n \n\nALGORITHMS AND COMPLEXITY \nObjectives \nThis course presents fundamental algorithms and data structures that are required to solve \ncommon problems. The notion of computational complexity of algorithms is introduced, and \nmathematical techniques are presented to analyse the complexity of the algorithms presented in \nthe course. Finally, an introduction to problem complexity is given. \n \nCourse learning outcomes \nUpon completion of this course the student should be able to:- design and analyse an algorithm \nfor a given problem- evaluate the computational complexity of an algorithm- reason about the \ncorrectness of an algorithm- classify an algorithm according to the basic approach it uses \nDescription \n\u2013 Algorithms, and complexity, upper and lower bounds- Elementary data structures:  lists, \nstacks, queue, sets- Advanced data structures: trees and graphs- Sorting- Searching- Hashing \n\u2013 Trees, and algorithm on Trees(binary search trees and (quasi)-balanced trees)- Graphs, and \nalgorithms on Graphs(depth-first search Prim\u2019s and Dijkstra\u2019s algorithms)9. Complexity theory: \nP, NP, NP completeness10. (if time) Algorithm on secondary memory \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Written final exam \n(50%)Grading scheme: 20 points (0-20)Objectives: Test the student\u2019s understanding of the \ncourse materialAssessment rules: The student has to answer questions with pencil and paper. \nThis is a closed-book exam. No cheat sheet allowed.Assessment criteria: The student must \nanswer the stipulated questions in a way that clearly demonstrates understanding of underlying \nconcepts.Task 2: Active participation \u2013 6 Quizzes in Class (30%)Grading scheme: 20 points \n(0-20)Objectives: To track and test the student\u2019s understanding for each topic.Assessment rules: \nThe student must answer questions with pen/pencil. Each quiz will be 10 minutes. No cheat \nsheet allowed.Assessment criteria: The student must answer the stipulated questions in a way \nthat clearly demonstrates understanding of underlying conceptsTask 3: Take-home assignment \n\u2013 2 Assignments (20%)Grading scheme: 20 points (0-20)Objectives: Check the abilities of the \nstudents in analytic thinking and in group collaborationAssessment rules: The assignments are \ngroup based. For each assignment there will be a weekly track where each member must write \nhis/her related task in this worksheet. Assessment criteria: Students must be separated into \nseveral groups. Evaluation will be individual.Task 4: Written exam \u2013 RETAKE (100%)Grading \nscheme: 20 points (0-20)Objectives: Test the student\u2019s understanding of the course \nmaterialAssessment rules: The student has to answer questions with pencil and paper. This is a \nclosed-book exam. No cheat sheet allowed.Assessment criteria: The student must answer the \nstipulated questions in a way that clearly demonstrates understanding of underlying concepts. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on Moodle.Literature list\u2610Yes\u2612NoRemarks:Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3331 \n \n \n\nBACHELOR SEMESTER PROJECT 3 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following. \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself. The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum. \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Final report and \nin-person presentation (100%)Grading scheme: 20 points (0-20)Objectives: Assess the quality \nand quantity of work done during the semester.Assessment rules: Time constrained \nsubmissions.Assessment criteria: The detailed criteria are specific to each project subject and \napplied on the following weighted deliverables:\u2022technical & scientific quality of the final report, \nprimary language (60%)\u2022technical & scientific quality of the final in-person presentation, primary \nlanguage (30%)\u2022technical & scientific quality of the final report, secondary language summary \n(5%)\u2022technical & scientific quality of the final in-person presentation, secondary language \nsummary (5%)Task 2: RETAKE 20 points (100%)Grading scheme: 20 points (0-20)Objectives: \nOption to repeat a previously failed project (with a final assessment of <10 points) with the same \ntopic and under the same supervisor.Assessment rules: The same deliverables as for the \npreviously failed project must be resubmitted under the given time constraints.Assessment \ncriteria: Same as for Task 1. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageLiterature \nlist\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3334\n \n\n",
        "4th Semester \nPRACTICAL FUNCTIONAL PROGRAMMING \nObjectives \nHaskell is a modern programming language with a rich type system and many advanced \nfeatures that allow efficient, fast and reliable solutions of extremely complex programming tasks. \nHaskell is currently being increasingly adopted by industry and open-source programmers, with \napplications ranging document conversion, cryptography and cryptocurrency protocols, \nhardware design, web services and microservices, proof management and high-reliability \ncomputing, and compiler construction.  The main aim of the course is to utilize the functional \nprogramming fundamentals from the previous courses in a practical environment, showing how \nto utilize the advanced concepts to vastly simplify practical programming tasks. The course \nspecifically focuses on utilizing typed functional programming constructions for solving tasks \nthat are extremely laborious and error-prone with the current mainstream programming practice.  \nThe course consists mainly of lectures, which are supplemented by individual work of the \nstudents on the 3 homework assignments.   \n \nCourse learning outcomes \nAt the end of the course the student will be able to:  \n \nBecome productive with Haskell, using it to fulfil day-to-day programming tasks,  \n \nUse functional programming in Haskell for industry-related use-cases including systems \nprogramming, network and web applications, and game programming,  \n \nUnderstand the practical importance, implementation, and main limitations of the type-inference \nin programming languages, and  \n \nUtilize advanced functional concepts in their programs and in other languages (such as Scala \nand PureScript), including monads and monad transformers, lenses, PEG parsers and AST \nprocessing techniques.\u202f \nDescription \nThe following topics are covered in the course: Overview of Haskell syntax and semantics\u202f \nOverloading via type classes and the use of most common type classes (Monoid, FAM, \ncontainer classes, number hierarchy, \u2026)\u202f Use of functions as data objects, simulating global \nstate using functions and monads Parsec-style parsing combinators\u202f Haskell infrastructure \u2013 \ncabal, Prelude\u202f Container libraries in Haskell, and a brief overview of functional data structures\u202f \nUsual compilation pipeline of lazy functional programs, a brief overview of Haskell type \nsystem\u202fCurry-Howard correspondence\u202f Monad transformers\u202f Functional references and optics\u202f \nHaskell libraries for text processing\u202f Systems programming interface of Haskell (IO), concurrent \nand parallel programming\u202f Web applications (backend applications and API endpoints, \nmiddleware, HTML generators, Front-end programming)\u202f Processing and generating graphics \nwith Haskell\u202f Selection of debugging, testing and benchmarking libraries; property testing\u202f Tools \nfor implementing extensible data structures: Higher-order abstract syntax & higher-kinded data, \n\ntagless & final interpreters, free monads, Selective functors, \u201cScrap Your Boilerplate\u201d approach \nand generics.  \nAssessment \nAssessment modality: Combined assessmentAssessment tasks \n \nTask 1: Take-home assignment\u200b (40%)Grading scheme: 20 points (0-20)Objectives: 3 homework \nassignments will be given for individual implementation by students. The assignments will \nprovide practical grounds for exercising the material from the lectures, and the tasks will serve \nas a common base for the exam questions. Assessment rules: The students submit their \nsolutions via Moodle within the specified deadline, following the submission specification given \nat the lectures and in Moodle. Submissions are expected to be formatted as a Cabal package. \nSubmissions that are mangled, unreadable, delayed beyond the deadline, or visibly do not \nadhere to submission criteria will not be evaluated. In case the authorship of the solutions is \nquestionable (e.g., solution seems to be copied from other students or generated from language \nmodels), all affected submitted solutions will be scored with 0 points. Assessment criteria: The \nsolutions will be evaluated on delivering the required functionality and suitable programming \nstyle (terseness, use of the recommended language features). Exact required goals will be \nlisted in Moodle. Task 2: Written exam\u200b (60%)Grading scheme: 20 points (0-20)Objectives: \nAssessing the understanding of the course matter by students by solving several very simple \nprogramming tasks. Assessment rules: The student solves several simple tasks on paper. The \ntasks may include 1) practical use of the Haskell type system 2) finding problems or \nimprovement opportunities in existing Haskell code using the knowledge of Haskell libraries 3) \nwriting short code snippets that solve given simple tasks.  All tasks will be selected from the \ntasks that the students should have already seen or solved during their work on the homework \nassignments.  The students may bring and use any resource printed on paper, including \nprepared cheatsheets, solutions of the homework assignments, and Haskell programming \nbooks, but no communication or use of any kind of computer is permitted Assessment criteria: \nThe provided solutions of the tasks must be correct. Problems in answers that typically occur \nwhen programming on paper (such as small problems with code types, easily fixable syntax \nissues, or exact library function names) will not have impact on the evaluation unless if present \nin amounts that hamper the assessment of correctness.  \u200b  Task 3: RETAKE (60%)Grading \nscheme: 20 points (0-20)Objectives: A student who has failed the course is allowed to sit to the \nnext exam call. The objectives are the same as Task 2. The mark the student got from the \nassessment Task 1 is kept.\u200b Assessment rules: Idem to Task 2. Assessment criteria: Idem to \nTask 2.   \nNote \nCourse materials Syllabus \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: Available on Moodle. Literature list \u200b\u2612\u200bYes\u200b\u2610\u200bNo \nRemarks: Learn You A Haskell For Great Good (updated version, \nhttps://learnyouahaskell.github.io/ )  Real World Haskell (updated version, \nhttps://github.com/tssm/up-to-date-real-world-haskell ) Haskell Wikibook \n(https://en.wikibooks.org/wiki/Haskell )  What I Wish I Knew When Learning Haskell \n(https://github.com/sdiehl/wiwinwlh ) Moodle page \u200b\u2612\u200bYes\u200b\u2610\u200bNo Remarks: TBD \n \n\nINFORMATION MANAGEMENT 2 \nObjectives \nThis course is a follow up, of IM1. Therefore, the overall objectives of the course remain the \nsame as its predecessor, but with a deeper and stronger level of exposition. \n \nCourse learning outcomes \nAt the end of the course, students will be able to: \n \n\u2013          design of relational database management systems (RDBMs) \n \n\u2013          understand and apply know how different index and storage structures are implemented. \n \n\u2013          Understand and apply how queries are optimized and processed. \n \n\u2013          Understand how multi-user concurrency control works in modern DBMSs. \n \n\u2013        Understand and apply logical query languages like Datalog to query databases \nDescription \n1. Data Storage 1.1 Datatypes in SQL 1.1.1 Fixed-Length Datatypes 1.1.2 Variable-Length \nDatatypes 1.2 Records 1.2.1 Fixed-Length Records 1.2.2 Variable-Length Records 1.3 Blocks & \nAddressing 1.4 Data Modifications 1.5 Five-Minute Rule 2. Indexing 2.1 Primary Indexes vs. \nSecondary Indexes 2.2 B+ Trees 2.3 Hashing-based Indexes 2.3.1 Extensible Hashing 2.3.2 \nLinear Hashing 2.4 Multi-Dimensional Indexes 2.4.1 KD Trees 2.4.2 Quad Trees 3. Query \nOptimization 3.1 Physical Query Operators 3.1.1 External Sorting 3.1.2 Joins (Nested Loops, \nMerging, Hashing) 3.2 Cost Models for Query Optimization 3.3 Join-Order Optimization & \nDynamic Programming 4. Concurrency Control 4.1 Transactions 4.1.1 Acid Properties of \nTransactions 4.1.2 Schedules & Serializability 4.2 Transaction Manager 4.2.1 Types of Conflicts \n4.2.2 Conflict Resolution 4.2.3 Conflict-Serializability 4.3 2-Phase Locking 4.4 Optimistic \nConcurrence Control 5. Datalog 5.1 Non-Recursive Datalog: Syntax & Interpretation 5.1.2 \nEvaluation Strategies 5.1.3 Safe Rules 5.1.4 Relationship to Relational Algebra 5.2 Recursive \nDatalog 5.2.1 Evaluation Strategies (Na\u00efve vs. Semi-Naive) 5.2.2 Recursion in SQL 5.2.3 \nNegation & Stratifiability 6. Data Warehousing (OLAP vs. OLTP) 6.1. OLAP Schemas (Fact vs. \nDimension Tables) 6.2 Data Cubes 6.3 Business Intelligence 6.3.1 Frequent Itemset Mining \n6.3.2 A-Priori Algorithm in SQL \nAssessment \nAssessment modality:  \n \n Combined assessment \n \nAssessment tasks \n \nTask 1:  Written or oral midterm exam (50%)Grading scheme: 20 points (0-20)Objectives: \nReproduction and application of the course contentsAssessment rules: Open book written exam \n(whole class) or 30 minutes individual oral exam.Assessment criteria: Exam results are based \n\non the correctness of the provided answers.  Task 2: Written or oral final exam (50%)Grading \nscheme: 20 points (0-20)Objectives: Reproduction and application of the course \ncontentsAssessment rules: Open book written exam (whole class) or 30 minutes individual oral \nexam.Assessment criteria: Exam results are based on the correctness of the provided \nanswers.Task 3: Active participation \u2013 Presentation of exercise solutions \u2013 Up to 2 bonus \npointsGrading scheme: 20 points (0-20)Objectives: Solution of exercise problemsAssessment \nrules: A correct presentation (in class) of the solution to one problem of an exercise sheet yields \none bonus point. Up to two bonus points can be achieved per student this way per semester. \nBonus points are added on top of the points the student has achieved through the exams. At \nmost 20 points can be achieved in altogether.Assessment criteria: Correctness of the provided \nsolutions.Task 4: Written RETAKE exam (100%)Grading scheme: 20 points (0-20)Objectives: \nReproduction and application of the course contentsAssessment rules: Closed book written \nexam (whole class) or 30 minutes individual oral exam.Assessment criteria: Solution of exercise \nproblems \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nDatabase Systems: The Complete Book (ISBN: 978-0131873254) \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3576 \n \nOther, please specify: \n \n \n\nPROGRAMMING FUNDAMENTALS 4 \nObjectives \nProgramming languages are a key instrument in computer science: they are used to write \nprograms executed by a computer either through compilation or interpretation. They provide \nprogrammers with different abstraction mechanisms that enable rapid (and reliable) software \ndevelopment, while hiding the complexity of the underlying hardware. In general, they can be \nseen as communication tools not only to communicate with computers but also with humans. \nThe objective of this course is to help students understand the concepts underlying the main \nprogramming languages, as well as their capabilities and limitations. \n \nCourse learning outcomes \nAt the end of the course, students will be able to:\u2022Understand the most common programming \nlanguage paradigms.\u2022Explain the main concepts of programming languages.\u2022Implement the \nmain features of a programming language (e.g., type inference)\u2022Analyse the features of a new \nprogramming language.\u2022Select the most suitable programming language for a new project. \nDescription \nCourse content 1. Introduction, history of programming languages 2. Programming Language \nConcepts 3. Lambda calculus 4. Binding, Parameter passing modes, 5. The Algol family of \nlanguages 6. ML 7. Types systems and type inference 8. Scope, Functions, and Storage \nManagement 9. Control structures and exceptions 10. Modularity and abstraction 11. Object \nOrientation 12. Concurrent Programming 13. Summary and Review   \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(60%)Grading scheme: 20 points (0-20)Objectives: Assessing the students\u2019 understanding of \nthe main concepts presented in the lectures and their capability to solve some exercises based \non the algorithms presented in class.Assessment rules: The use of documents (including books \nand notes) is not authorized. The use of electronic devices is not authorizedAssessment criteria: \nCorrectness of the answersTask 2: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Programming exercises to show the students can implement fundamental \nalgorithms of programming language designAssessment rules: Use of generative AI \ntechnologies must be disclosed upon submission; the prompts used to get the results should be \nincluded in the submission. Late submissions are penalized by 50% (<24h), 75% (>=24h and < \n48h), 100% (>=48h)Assessment criteria: Correctness of the program functionality, overall \nprogram design, coding style.Task 3: Presentation (20%)Grading scheme: 20 points \n(0-20)Objectives: By the end of the course, the student should be able to analyse the features of \na previously unknown programming language.Assessment rules: Each student will be asked to \npresent the main concepts of a programming language chosen from a list proposed by the \ninstructor.Assessment criteria: Depth and breadth of the presentation, quality of the visual \nsupport (slides)Task 4: Retake (60%)Grading scheme: 20 points (0-20)Objectives: A student \nmay retake the written exam. No resitting is foreseen for the take-home assignments and the \nfinal presentation.Assessment rules: Same as task 1 Assessment criteria: Same as task 1  \nNote \nSyllabus \n \n\n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nConcepts in programming languages /John C. Mitchell. 2003. Cambridge University \nPress.Available on A-Z.lu \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=6843 \n \n\nTHEORETICAL COMPUTER SCIENCE 2 \nObjectives \nThe course aims to provide the students an introduction to formal methods and basic concepts, \ntheories, logics, and verification algorithms for automata-based model checking. \n \nCourse learning outcomes \nAfter the course, the students will be able to:-model computer systems as transition \nsystems,-understand what types of properties can be specified on the transition system, \n-formalise such properties in logics (LTL and CTL), -verify whether a transition system satisfies a \nproperty written as a logic formula. \nDescription \nModelling computer systems as transition systems (hardware circuits, sequential programs, \nconcurrency and communication, shared variables, message-passing, channel \nsystems).Linear-time properties (invariants, safety, liveness, and fairness).Regular safety \nproperties, Buchi automata, omega-regular properties.Linear temporal logics (syntax, \nsemantics, equivalence).LTL model checking algorithms.Computation tree logic (syntax, \nsemantics, equivalence).CTL model checking algorithms. \nAssessment \nAssessment modality:  \n \n  Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam (40%)Grading scheme: 20 points (0-20)Objectives: The students have \nfulfilled the objectives of the course.Assessment rules: The students should perform the exam \nindependently by themselves.Assessment criteria: Quality of the submitted exam.Task 2: \nTake-home assignment (40%)Grading scheme: 20 points (0-20)Objectives: The students can \napply the course materials to finish the assignments/homework.Assessment rules: The students \nshould perform the assignments independently by themselves. Assessment criteria: Quality of \nthe submitted assignments/homework.Task 3: Attendance (20%)Grading scheme: 20 points \n(0-20)Objectives: The students need to be present at the classes in order to understand the \nbasic concepts, theories and verification algorithms.Assessment rules: Be present at both \nlectures and practical sessions. Otherwise, inform the teachers about the reasons of absence. \nAssessment criteria: Be present and active at both lectures and practical sessions.Task 4: \nWritten RETAKE exam (100%)Grading scheme: 20 points (0-20)Objectives: The students have \nfulfilled the objectives of the course.Assessment rules: The students should perform the exam \nindependently by themselves.Assessment criteria: Quality of the submitted exam. \nNote \nSyllabus \n \n\u2610Yes  \u2612No \n \nRemarks: \n\n \n  \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nBaier, C., Katoen, J. (2008). Principles of Model Checking. United Kingdom: MIT Press. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3577 \n \nOther, please specify: \n \n \n \n\nPROGRAMMING LANGUAGES \nObjectives \nThis course aims to make you understand programming language implementation and formal \nlanguage processing in an as easy as possible way through concrete examples. It will guide you \nthrough all the main phases of the design and the implementation of an interpreter and/or \ntraditional compiler \n \nCourse learning outcomes \nThe course aims to enable you to design and implement compilers and similar language \nprocessing tools. To be able to design and implement interpreters and compilers will:\u2022make you \na better programmer as you will better understand a language\u2019s intricacies. \u2022make you a better \ncomputer scientist, because programming technologies span so many areas of the discipline, \nincluding formal language theory, grammars, computability, and semantics all the advanced \nconcepts in modern programming languages.\u2022allow you to practice principles and tools seen in \nprevious semesters, as interpreters and compilers are generally large and complex software.\u2022let \nyou get very quickly into the business of implementing a programming language and running \nprograms written in it. \nDescription \nCode Generation Techniques/Schemes for Imperative as well as Object-Oriented Languages, \nLexing, Lexer Generation, Parsing, Parser Generation, Static (Code) Analysis, Compiler \nOptimizations, SCADE/Lustre. \nAssessment \nAssessment modality:  \n \n Continuous assessment \n \nAssessment tasks:  \n \nTask 1: Take-home assignment (20%)Grading scheme: 20 points (0-20)Objectives: Code \nGenerationAssessment rules: All auxiliary materials allowed, but no group work. Assessment \ncriteria: Code generation follows strict translation schemes. This task requires you to apply \nthese schemes to a C program to yield a semantically equivalent assembly program. Submitted \nhomework (code) is graded based on whether the required translation schemes have been \ncorrectly applied. Task 2: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Lexing and Lexer Generation: Formally specify tokens and token classes and \nconstruct a lexer for these tokens / token classesAssessment rules: All auxiliary materials \nallowed, but no group work. Assessment criteria: Lexer generation follows a sequence of \nwell-defined transformations/algorithms. Grading is based on whether these algorithms have \nbeen correctly applied and whether the tokens themselves have been correctly specified using \nregular expressions.Task 3: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Top-Down Parsing and Parser Generation: Construct a recursive descent \nparser and an LL parser for given context-free grammarsAssessment rules: All auxiliary \nmaterials allowed, but no group work. Assessment criteria: Top-down parser generation yields \nan action table (LL) or method implementations (RD). The grade is determined by the \n\ncorrectness of the action table and correctness and coding style of the methods, \nrespectively.Task 4: Take-home assignment (20%)Grading scheme: 20 points (0-20)Objectives: \nBottom-Up Parsing and Parser Generation: Construct an LR parser for a given context-free \ngrammarAssessment rules: All auxiliary materials allowed, but no group work. Assessment \ncriteria: Bottom-up parser are given by an action and goto tables (LR), as an intermediate step a \nso-called Item PDA may be generated. The grade is determined by the \ncorrectness/completeness of this automaton and the correct derivation of the action/goto table \nfrom the automaton.Task 5: Take-home assignment (20%)Grading scheme: 20 points \n(0-20)Objectives: Static Program Analysis: Design/definition of a sound static \nanalysisAssessment rules: All auxiliary materials allowed, but no group work. Assessment \ncriteria: Sound static program analyses are defined by a complete lattice (of potential analysis \nresults), edge effects for the various code constructs, a MOP definition, etc. The grade is \ndetermined by the correctness (soundness and applicability) of your definitions for an \nappropriate lattice/MOP, edge effects etc. \nNote \nSyllabus \n \n\u2610Yes  \u2612No \n \nRemarks: \n \n  \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nLecture slides contain up-to-date literature list. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3578 \n \nOther, please specify: \n \n \n\nINTELLIGENT SYSTEMS 1 \nObjectives \nThis course aims to offer a foundation, ideas, and techniques underlying the design of intelligent \nagents and their application in various real-world domains. Also, it offers different ways of \nsystem implementations with \u201cintelligent\u201d functionality through statistical and decision-theoretic \nmodelling paradigms where agents will draw inferences in uncertain environments and optimize \nactions for arbitrary reward structures. Students will learn to recognize when intelligent \nfunctionality and artificial intelligence may be a good solution to a problem and to select \nappropriate AI methodologies and strategies. Further, they will acquire knowledge enabling \nthem to develop the necessary skills to design and implement an intelligent system. \n \nCourse learning outcomes \nLearning outcomesAt the end of the course, students will be able to:\u2022Describe the concept of \nsingle/multi-agent systems and their implementations.\u2022Model various search algorithms with \ndifferent problem types.\u2022Determine the most adequate search solution/algorithm in each \nproblem scenario.\u2022Design autonomous agents that efficiently make decisions in fully informed, \npartially observable, and adversarial settings. \nDescription \nThe course covers the following topics:1. Fundamental Issues1.1. Overview of AI problems, \nexamples of successful recent AI applications.1.2. What is intelligent behavior? The Turing test, \nRational versus non-rational reasoning.1.3. Problem characteristics: Fully versus partially \nobservable, Single versus multi-agent, Deterministic versus stochastic, Static versus dynamic, \nDiscrete versus continuous.1.4. Nature of agents: Autonomous versus semi-autonomous, \nReflexive, goal-based, and utility-based, the importance of perception and environmental \ninteractions.1.5. Philosophical and ethical issues. 2. Basic Search Strategies2.1. Problem \nspaces (states, goals and operators), problem solving by search.2.2. Factored representation \n(factoring state into variables).2.3. Uninformed search (breadth-first, depth-first, depth-first with \niterative deepening).2.4. Heuristics and informed search (hill-climbing, generic best-first, A*).2.5. \nSpace and time efficiency of search.2.6. Two-player games (introduction to minimax \nsearch).2.7. Constraint satisfaction (backtracking and local search methods.3. Basic Machine \nLearning3.1. Definition and examples of broad variety of machine learning tasks, including \nclassification.3.2. Inductive learning.3.3. Simple statistical-based learning, such as Naive \nBayesian Classifier, decision trees.3.4. The over-fitting problem.3.5. Measuring classifier \naccuracy. \nAssessment \nAssessment modality:  \n \n  Combined assessment \n \nAssessment tasks \n \nTask 1: Written exam\u200b (40%)Grading scheme: 20 points (0-20)Objectives: \u200bTo assess the \nstudent\u2019s comprehension of the taught topics during the lecture part of the course. \u200b Assessment \nrules: Devices of any kind are not allowed; it is a closed-book exam.\u200b Assessment criteria: The \n\nexam contains several questions with a preset marking scheme and marks distribution for each \nquestion.\u200b Task 2: \u200bTake-home assignment\u200b (40%)Grading scheme: 20 points (0-20)Objectives: To \nassess students\u2019 psychomotor skills in implementing and designing intelligent agents throughout \nthe training sessions.\u200b Assessment rules: \u200bAll resources are allowed\u200b Assessment criteria: Project \nwork / Assignment reports\u200b Task 3: Active participation\u200b (20%)Grading scheme: 20 points \n(0-20)Objectives: To encourage the students to be involved in the discussions and critical \nthinking during both lecture and training sessions.  \u200b Assessment rules: N/A Assessment criteria: \nAttendance and question answering throughout lecture and training sessions.  Task 4: Written \nRETAKE exam\u200b (100%)Grading scheme: 20 points (0-20) Objectives: Retake the course in case \nof failure or missing the written exam  \u200b Assessment rules: \u200bDevices of any kind are not allowed; it \nis a closed-book exam.\u200b Assessment criteria: \u200bThe exam contains several questions with a preset \nmarking scheme and marks distribution for each question.\u200b  \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nArtificial Intelligence: A Modern Approach (Prentice Hall Series in Artificial Intelligence) by Stuart \nRussell and Peter Norvig http://aima.cs.berkeley.edu/ \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3579 \n \n\nBACHELOR SEMESTER PROJECT 4 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following.  \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself.  The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum  \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project.  \nAssessment \nAssessment modality: Combined assessment \n \nAssessment tasks \n \nTask 1: Final report and in-person presentation (100%)Grading scheme: 20 points (0-20) \nObjectives: Assess the quality and quantity of work done during the semester. Assessment \nrules: Time constrained submissions. Assessment criteria: The detailed criteria are specific to \neach project subject and applied on the following weighted deliverables: technical & scientific \nquality of the final report, primary language (60%) technical & scientific quality of the final \nin-person presentation, primary language (30%) technical & scientific quality of the final report, \nsecondary language summary (5%) technical & scientific quality of the final in-person \npresentation, secondary language summary (5%) Task 2: RETAKE (100%)Grading scheme: 20 \npoints (0-20Objectives: Option to repeat a previously failed project (with a final assessment of \n<10 points) with the same topic and under the same supervisor. Assessment rules: The same \ndeliverables as for the previously failed project must be resubmitted under the given time \nconstraints. Assessment criteria: Same as for Task 1.   \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \n\nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3581\n \n\n",
        "5th Semester \nCOMPUTATIONAL SCIENCE \nObjectives \nNumerous problems in engineering, physical and economical industries and application \ndomains essentially boil down to minimising a single function: the objective function in \noptimization terminology. Minimisation is not only the basis of many simulation tools, but also \nthe basis of many parameter identification approaches. Unfortunately, there is not one \nminimisation method that outperforms the others. In this module, the student will therefore \nbecome familiar with three numerical minimisation techniques, each with its own advantages \nand disadvantages. Furthermore, three ways to deal with constraints in minimisation problems \nwill be considered, also each with its own advantages and disadvantages. The student will \nimplement the minimisation techniques herself/himself in a programming language of her/his \nchoice, hereby effectively implementing her/his own simulations. In this way, the student will \ntruly be exposed to the methods\u2019 advantages and disadvantages, and she/he will capture the \nrelevant technical complexities of the methods. Thus, the aim of the module is to teach the \nstudent a variety of unconstrained and constrained minimisation approaches and understand \ntheir beneficial and disadvantageous differences. \n \nCourse learning outcomes \nAt the end of the course, the student will be able to:\u2022Understand and be able to work with \ndescent methods. \u2022Understand and be able to work with Newton\u2019s method in optimization.  \n\u2022Understand and be able to work with quasi-Newton methods in optimization. \u2022Understand and \nbe able to incorporate constraints in objective functions using substitution. \u2022Understand and be \nable to incorporate constraints in objective functions using the penalty method. \u2022Understand and \nbe able to incorporate constraints using the method of Lagrange multipliers.  \nDescription \n1. Descent methods: steepest descent method, line search using the Armijo rule, conjugate \ngradient method, compute multivariate derivatives, implement the methods.2. Newton\u2019s method: \nCompute multivariate second-order derivatives, solve linear systems, implement the method.3. \nQuasi-Newton methods: line search using the Wolfe conditions, implement the BFGS method \nand the L-BFGS method.4. Implement constraints in previous unconstrained objective functions \nusing substitution.5. Implement constraints in previous unconstrained objective functions using \nthe penalty method.6. Implement constraints in previous unconstrained objective functions using \nthe method of Lagrange multipliers. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Written exam \n(20%)Grading scheme: 20 points (0-20)Objectives: Assess the student\u2019s understanding of (1) \ndescent methods and (2) Newton\u2019s method.Assessment rules: The lecture notes and even the \ninternet may be used. However, any means of communication is forbidden.Assessment criteria: \nThe student must use its own implementations, made during the semester, to calculate some \nminimization problems. Open questions may also be posed, which require a textual \nresponse.Task 2: Written exam (20%)Grading scheme: 20 points (0-20)Objectives: Assess the \nstudent\u2019s understanding of (3) quasi-Newton methods.Assessment rules: The lecture notes and \neven the internet may be used. However, any means of communication is \n\nforbidden.Assessment criteria: The student must use its own implementations, made during the \nsemester, to calculate some minimization problems. Open questions may also be posed, which \nrequire a textual response.Task 3: Written exam (60%)Grading scheme: 20 points \n(0-20)Objectives: Assess the student\u2019s understanding of (1) descent methods, (2) Newton\u2019s \nmethod, (3) quasi-Newton methods, (4) constraint incorporation using substitution, (5) constraint \nincorporation using the penalty method, (6) constraint incorporation using the method of \nLagrange multipliers.Assessment rules: The lecture notes and even the internet may be used. \nHowever, any means of communication is forbidden.Assessment criteria: The student must use \nits own implementations, made during the semester, to calculate some minimization problems. \nOpen questions may also be posed, which require a textual response.Task 4: Written exam \u2013 \nRETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Assess the student\u2019s \nunderstanding of (1) descent methods, (2) Newton\u2019s method, (3) quasi-Newton methods, (4) \nconstraint incorporation using substitution, (5) constraint incorporation using the penalty \nmethod, (6) constraint incorporation using the method of Lagrange multipliers.Assessment \nrules: The lecture notes and even the internet may be used. However, any means of \ncommunication is forbidden. In principle, again the resit exams consist of 2 midterm exams and \none final exam \u2013 with the same weights for the final grade as for the standard \nexams.Assessment criteria: The student must use its own implementations, made during the \nsemester, to calculate some minimization problems. Open questions may also be posed, which \nrequire a textual response. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on the Moodle page.Literature \nlist\u2612Yes\u2610NoRemarks:Lecture notes are provided by the instructor.Moodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=4194 \n \n\nSOFTWARE ENGINEERING 1 \nObjectives \nSoftware engineering is the discipline concerned with the application of theory, knowledge, and \npractice to effectively and efficiently build reliable software systems that satisfy the requirements \nof customers and users. This discipline is applicable to small, medium, and large-scale systems.  \nIt encompasses all phases of the lifecycle of a software system, including requirements \nelicitation, analysis and specification; design; construction; verification and validation; \ndeployment; and operation and maintenance.\u201d [ACM/IEEE-CS Joint Task Force on Computing \nCurricula. 2013. Computer Science Curricula 2013. ACM Press and IEEE Computer Society \nPress. DOI: http://dx.doi.org/10.1145/2534860].  \n \nThe objectives of this course are to provide knowledge on the discipline such that the student \nunderstands the main aspects of it. The course focuses on software processes, project \nmanagement, quality standard and requirements engineering for a deep understanding of this \ndevelopment phase. \n \nCourse learning outcomes \nAt the end of the course, the student will be able to:\u2022LO1/(MF) Apply consistent documentation \nand program style standards that contribute to the readability and maintainability of software. \n\u2022LO2/(M) Describe the relative advantages and disadvantages among several major process \nmodels (e.g., waterfall, iterative, and agile).\u2022LO3/(M) Describe the different practices that are \nkey components of various process models.\u2022LO4/(M) Differentiate among the phases of \nsoftware development.\u2022LO5/(M) Explain the concept of a software lifecycle and provide an \nexample, illustrating its phases including the deliverables that are produced.\u2022LO6/(M) Compare \nseveral common process models with respect to their value for development of classes of \nsoftware systems taking into account issues such as requirement stability, size, and \nnon-functional characteristics.\u2022LO7/(M) Define software quality and describe the role of quality \nassurance activities in the software process.\u2022LO8/(M) Describe the intent and fundamental \nsimilarities among process improvement approaches.\u2022LO9/(M) Use project metrics to describe \nthe current state of a project.\u2022LO10/(M) Using a particular software process, describe the \naspects of a project that need to be planned and monitored, (e.g., estimates of size and effort, a \nschedule, resource allocation, configuration control, change management, and project risk \nidentification and management). \u2022LO11/(MF) Track the progress of some stage in a project \nusing appropriate project metrics. \u2022LO12/(MF) List the key components of a use case or similar \ndescription of some behaviour that is required for a system.\u2022LO13/(M) Describe how the \nrequirements engineering process supports the elicitation and validation of behavioural \nrequirements. \u2022LO14/(MF) Interpret a given requirements model for a simple software \nsystem.\u2022LO15/(M) Describe the fundamental challenges of and common techniques used for \nrequirements elicitation. \u2022LO16/(MF) List the key components of a data model (e.g., class \ndiagrams or ER diagrams).\u2022LO17/(MF) Identify both functional and non-functional requirements \nin a given requirements specification for a software system.\u2022LO18/(MF) Conduct a review of a \nset of software requirements to determine the quality of the requirements with respect to the \ncharacteristics of good requirements. \u2022LO19/(MF) Apply key elements and common methods for \nelicitation and analysis to produce a set of software requirements for a medium-sized software \n\nsystem.\u2022LO20/(MF) Use a common, non-formal method to model and specify the requirements \nfor a medium-size software system.\u2022LO21/(MF) Translate into natural language a software \nrequirements specification (e.g., a software component contract) written in a formal specification \nlanguage. \u2022LO22/(MF) Create a prototype of a software system to mitigate risk in requirements. \n\u2022LO23/(MF) Understand and apply the Messir requirement engineering to a small size \napplication development process.\u2022LO24/(M) Understand and apply the Messir use-case model \nin the context of the development methodology.\u2022LO25/(M) Understand and apply the Messir \nenvironment model in the context of the development methodology.\u2022LO26/(MF) Understand and \napply the Messir concept model in the context of the development methodology.\u2022LO29/(F) \nUnderstand and apply the UML use-case diagram.\u2022LO30/(F) Understand and apply the UML \nsequence diagram.\u2022LO31/(MF) Understand and apply the UML class diagram.\u2022LO32/(MF) \nUnderstand and apply the Messir operation model at definition level in the context of the \ndevelopment methodology.\u2022LO33/(MF) Understand and apply the Messir operation model at \nspecification level in the context of the development methodology.Remark: the letter M indicates \nthat the learning outcome will be assessed at midterm exam, F at final exam assessment task, \nand MF at both). \nDescription \n\u2022 Program correctness: types of errors (syntax, logic, run-time), the concept of a specification, \ndefensive programming (e.g., secure coding, exception handling), code reviews, testing \nfundamentals and test-case generation, the role and the use of contracts (including pre- and \npost-conditions), unit testing.\u2022 Simple refactoring. \u2022 Modern programming environments: Code \nsearch, Programming using library components and their APIs.\u2022 Documentation and program \nstyle. \u2022 Introduction to software process models (e.g., waterfall, incremental, agile); activities \nwithin software lifecycles. \u2022 Programming in the large vs. individual programming. \u2022 Evaluation of \nsoftware process models. \u2022 Software quality concepts. \u2022 Process improvement. \u2022 Software \nprocess capability maturity models. \u2022 Software process measurements.\u2022 Software quality \nassurance and the role of measurements. \u2022 Release management. \u2022 Requirements analysis and \ndesign modelling tools.\u2022 Describing functional requirements using, for example, use cases or \nusers\u2019 stories. \u2022 Properties of requirements including consistency, validity, completeness, and \nfeasibility. \u2022 Software requirements elicitation.\u2022 Describing system data using, for example, class \ndiagrams or entity-relationship diagrams. \u2022 Non-functional requirements and their relationship to \nsoftware quality (cross-reference IAS/Secure Software Engineering).\u2022 Evaluation and use of \nrequirements specifications. \u2022 Requirements analysis modelling techniques.\u2022 Acceptability of \ncertainty/uncertainty considerations regarding software/system behaviour.\u2022 Prototyping. \u2022 Basic \nconcepts of formal requirements specification.\u2022 Requirements specification.\u2022 Requirements \nvalidation. \u2022 Requirements tracing. \u2022 System design principles: levels of abstraction \n(architectural design and detailed design).\u2022 Structural and behavioural models of software \ndesigns.\u2022 Relationships between requirements and designs: transformation of models, design of \ncontracts, invariants. \nAssessment \nAssessment modality:   Combined assessmentAssessment tasks \n \nTask 1: Written exam \u2013 MIDTERM (40%)Grading scheme: 20 points (0-20)Objectives: Assess to \nwhich extend the targeted course learning outcomes have been acquiredAssessment rules: no \n\ndocument allowed \u2013 no electronic device allowedthe duration of the exam can be up to FOUR \nsuccessive hoursAssessment criteria: A set of questions are asked to the student on a subset of \nthe learning outcomes targeted by the assessment task (cf. learning outcomes). Task 2: Written \nexam \u2013 FINAL (60%)Grading scheme: 20 points (0-20)Objectives: Assess to which extend the \ncourse learning outcomes have been acquiredAssessment rules: no document allowed \u2013 no \nelectronic device allowed. The duration of the exam can be up to FOUR successive \nhoursAssessment criteria: A set of questions are asked to the student on a subset of the \ntargeted learning outcomes by the assessment task (cf. learning outcomes).Task 3: Written \nexam \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: Assess to which extend \nthe course learning outcomes have been acquired for a student having ALREADY FAILED \nONCE TO THE COURSE USING THE assessment tasks 1 AND 2.Assessment rules: no \ndocument allowed \u2013 no electronic device allowed. The duration of the exam can be up to FOUR \nsuccessive hoursAssessment criteria: A set of written questions are asked to the student in \norder to evaluate the acquisition level reached for a subset of the learning outcomes.The final \ngrade FOR THE Task3 \u2013 RETAKE assessment is computed as follows:- 40% the > MIDTERM \ngrade- 60% the grade of the RETAKE written questions answersThe MIDTERM assessment \ntask 1 can be re-executed by a redoing students only if the student registers to the course \nduring the WINTER semester. \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageLiterature \nlist\u2612Yes\u2610NoRemarks:Accessible from the Moodle course pageMoodle \npage\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3916 \n \n\nINTRODUCTION TO IOT \nObjectives \nStudents will be equipped with competences for the development of applications for the Internet \nof Things (IOT):Know the challenges of IoT networks considering the various specificities and \napplication constraints (e.g. QoS, scalability, real-time application, operational safety, \netc.).Master the basics of IoT communication protocols (Application layer).Master the selection \nand implementation of different IoT communication protocols.Design, analyze and criticize \ndifferent data collection, storage and processing data architectures, both their possibilities and \ntheir limits.Design one or more IoT applications using machine learning modules based on the \ncollected data. \n \nCourse learning outcomes \nOn successful completion of this course, students are capable to:Define and develop the \nfunctional and technical specifications of a network and telecom equipment (hardware, software, \nimplementation, etc.).Determine architecture components, technologies, equipment, tools \nsupports and integrate them according to the specifications. \nDescription \nIntroduction to issues relating to the interoperability of IoT networks/protocols (application layer \n\u2013 OSI)Real-time networks: Profibus, Modbus, Modbus-TCPIOT protocols on application layer: \nHTTP (REST API), MQTT, CoAP, OneM2M, O-MI/O-DFNOSQL databases: MongoDB, \nElasticSearchGetting started with Node-Red (visual programming tool \u2013 open source \u2013 \ndeveloped by IBM) for IoT application development:data collection: Arduino, & sensors, Cloud \nAPI endpoints\u2026data storage: databases (SQL, NoSQL)data treatment: Node-Red \n(JavaScript)publication of data via dashboard (H2M) and machine interfaces (M2M): \nImplementation of an HTTP server (REST API specification, server deployment) \nAssessment \nFirst time students:40%: practical group project60%: final written examRepeating \nstudents:100% final written exam \nNote \nLiterature: Relevant literature will be provided during the lecture. \n \n\nHUMAN-COMPUTER INTERACTION (HCI) \nObjectives \nThe course provides students with a comprehensive understanding of the fundamental \nprinciples and concepts underlying Human-Computer Interaction, such as research methods, \nuser interfaces, or interaction techniques. \n \nCourse learning outcomes \n1.Understand fundamental HCI principles and their role in designing interactive \nsystems.2.Compare and contrast different user-centred design and research methodologies. \n \nRecognize the societal implications of HCI, including e.g. privacy, security, and accessibility. \nDescription \n1. Introduction1.1 Why is HCI challenging?1.2 Human-computer interaction as a field1.3 \nFundamental concepts1.4 Why HCI matters1.5 Our approach to HCI2. Understanding \npeople2.1 Types of understanding2.2 Areas of understanding2.3 Applying our understanding of \npeople2.4 Is a general understanding of people possible?3. Perception3.1 Sensory \nmodalities3.2 Elementary functions of perception in HCI3.3 Visual perception and attention3.4 \nPerception is an active process4. Motor Control4.1 Elements of a motor control task in HCI4.2 \nTarget Acquisition4.3 Simple Reactions4.4 Choice reaction4.5 Gesturing5. Cognition5.1 General \nFindings about Cognition5.2 Cognitive control5.3 Memory and Learning5.4 Reasoning and \nDecision-Making5.5 Simulating cognition in interactive tasks6. Needs and Motivations6.1 \nPsychological Needs6.2 Motivations6.3 Behavior Change6.4 Gamification7. Experience7.1 \nWhat is Experience?7.2 Types of Experience7.3 Assessing and Measuring Experience7.4 Can \nexperiences be designed?8. Collaboration8.1 Understanding collaboration8.2 Coordination8.3 \nGroup cognition8.4 Why collaborative systems fail9. Communication9.1 Beyond face-to-face \ncommunication9.2 Conversations9.3 Online behavior9.4 Social Networks and Online \nCommunities9.5 Computers as Communication Partners10. User Interfaces10.1 Definition and \nElements10.2 Interaction Styles10.3 Design Objectives10.4 Design Space Analysis11. Input \nDevices11.1 Principles of Sensing11.2 Keypads and Keyboards11.3 Pointing Devices11.4 \nUncertain Control11.5 Expanding the Limits of Sensing12. Displays12.1 Encoding and \nRendering12.2 Simple Displays12.3 Visual Displays13. Contents13.4 Audio13.5 Haptics13.6 \nEmerging Forms of Displays14. Interaction Techniques14.1 Objectives for Interaction \nTechniques14.2 Pointing techniques14.3 Selection and manipulation techniques14.4 Text \nentry14.5 Camera control14.6 Two perspectives: Control and Learnability15. Commands and \nNavigation15.1 Naming Objects and Actions15.2 Command-Line Interfaces15.3 Organizing \nInformation15.4 Menu User Interfaces15.5 Notational Systems15.6 Recognition versus \nRecall16. Graphical User Interfaces16.1 A Brief History of the GUI16.2 Design Objectives16.3 \nThe Principle of Direct Manipulation16.4 Anatomy of a Graphical User Interface16.5 Designing a \nGraphical User Interface16.6 Why do we still have GUIs?17. Reality-Based Interaction17.1 \nMobile User Interfaces17.2 Ubiquitous Computing17.3 Tangible User Interfaces17.4 Mixed \nReality17.5 Should we imitate reality or go beyond it? \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Assignments \n(40%)Grading scheme: 20 points (0-20)Objectives: Students will get familiarized with HCI \n\nresearch through readings of academic papers.Assessment rules: There will be a list of \nresearch papers available in Moodle. Every week, students must present one of those papers in \nfront of the class.  There will be a monthly or bi-monthly rotation, depending on the number of \nstudents enrolled in the course, which means that each student will present two or three papers \nin total.Assessment criteria: Each presentation will be graded using a 0\u201310-point scale and the \nfinal grade in this part will be the average grade of all presentations delivered by the student. \nStudents must get an average grade of at least 5 points (out of 10) in this part in order to qualify \nfor the final exam. If a student scores less that 5 points in this part, the final grade in the course \nwill be the minimum grade achieved in either the assignments or the final exam. Any form of \ncheating or plagiarism will be penalized with a grade of 0 in this part, which will make the \nstudent to fail the whole course. The grade in this part will be retained until the student passes \nthe final exam, unless the student decides to repeat it in the next academic year. There is no \nretaking option for this part within the same academic year, which means that a student who \nfails this part must enroll again in the course in the next academic year. Retaking students must \ninform the course responsible whether they want to keep their grade from the previous \nyear.Task 2: Final exam (60%)Grading scheme: 20 points (0-20)Objectives: Students will \ndemonstrate that they have acquired the required competencies according to the theory \ncovered in the course.Assessment rules: Only students who got at least 5 points in the \nassignments should take the final exam, otherwise they are advised to de-enrol from the final \nexam in order to avoid missing an official attempt. No supporting materials are allowed in the \nexam, i.e. no cheatsheet, no books, no mobile devices, no laptops, etc.Assessment criteria: The \nexam is a paper-based quiz with 20 questions that must be solved in 30 minutes. Each question \ncomes with 4 possible answers, among which only one is the right one. A student must get at \nleast 5 points (out of 10) in the final exam in order to pass the course. If a student scores less \nthat 5 points in this part, the final grade in the course will be the minimum grade achieved in \neither the assignments or the final exam. Any form of cheating or plagiarism will be penalized \nwith a grade of 0 in this part, which will make the student to fail the whole course.The grade in \nthis part will not be retained for the next year. Failing students can retake the exam in the next \nexamination period or enroll again in the course the next academic year. \nNote \nCourse materials \n \nSyllabus\u22a0Yes\u2610NoRemarks:Available on MoodleLiterature list\u22a0Yes\u2610NoRemarks:Reference \ntexbook:\u2022Kasper Hornb\u00e6k, Per Ola Kristensson, Antti Oulasvirta. Introduction to \nHuman-Computer Interaction. Oxford University Press. 2024.Moodle \npage\u22a0Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3917 Other, please \nspecify:Class attendance is expected for the practical sessions, otherwise the students will fail \nthe continuous evaluation. \n \n\nINTRODUCTION TO MACHINE LEARNING \nObjectives \nThis course introduces Machine Learning (ML) principles and its three main learning paradigms \n(supervised, unsupervised, and reinforcement learning). For each learning paradigm, it presents \nsome of its most typical foundational models and discuss them from the perspective of \nrepresentation, evaluation, and optimization. A special attention is given to a basic introduction \ninto deep learning techniques and generalization. The course mixes theoretical concepts with \nvanilla implementations of various ML models. \n \nCourse learning outcomes \nAt the end of the course the student will be able to:\u2022    define Machine Learning and differentiate \nthe terms AI, Machine Learning, and Deep Learning.\u2022    describe the differences among the \nthree Machine Learning paradigms: supervised, unsupervised, and reinforcement learning.\u2022    \ndetermine which of the three Machine Learning paradigms is appropriate to a particular type of \nproblems.\u2022    derive, implement, and evaluate some of the most typical Machine Learning \nmodels. \u2022    derive, implement, and evaluate some basic Deep Learning models and their \nlearning algorithms.\u2022    explain proper ML evaluation procedures, including the differences \nbetween training and testing performance.\u2022    apply Machine Learning models to real-world \nproblems.\u2022    identify overfitting in the context of a problem and describe solutions to overfitting.\u2022    \nevaluate the performance of a Machine Learning algorithm on a real-world dataset. \nDescription \nThe following topics are covered in the course:\u2022    Basics \u2013 ML Introduction \u2022    Basics \u2013 Data \npreparation for ML \u2022    Supervised Learning \u2013 Regression \u2022    Supervised Learning \u2013 \nClassification\u2022    Unsupervised Learning \u2013 Dimensionality reduction\u2022    Unsupervised Learning \u2013 \nClustering\u2022    Reinforcement Learning \u2013 Preliminaries\u2022    Reinforcement Learning \u2013 Basic \nmethods\u2022    Deep Learning \u2013 Learning Deep Representations\u2022    Deep Learning \u2013 Models\u2022    \nDeep Learning \u2013 Deep Reinforcement Learning\u2022    Generalization\u2022    Research \u2013 Glimpse on \nstate-of-the-art research\u2022    Engineering \u2013 ML and the real-world \nAssessment \no    Three take-home assignments \u2013 40% of the final grade in total split as follows: 10%, 10%, \nand 20%o    Written exam \u2013 60% of the final grade o    Students having failed the course will \nhave to retake the exam at the next exam session. This exam will count for 100% of the final \ngrade. \nNote \nLiterature:\u2022    Bishop, C.: Pattern Recognition and Machine Learning, 2006\u2022    Goodfellow, I., \nBengio, Y. & Courville, A.: Deep Learning, 2016\u2022    Sutton, R., Barto, A.: Reinforcement \nLearning: An Introduction, second edition, 2018\u2022    Hastie, T, Tibshirani, R. & Friedman, J.: The \nElements of Statistical Learning, 2009\u2022    Zhang, A., Smola, A.J., Lipton, Z., Li, M.: Dive into \nDeep Learning, 2023 \n \n\nNATURAL LANGUAGE PROCESSING \nObjectives \nThis course focuses on the theoretical and practical foundations of Natural Language \nProcessing (NLP), an interesting domain at the intersection of computer science and artificial \nintelligence.  Covering language representation, syntax, semantics, and advanced techniques \nlike deep learning and transformers, the course explores how NLP enables communication with \nchatbots and other artificial systems.  By understanding language models and machine \nlearning\u2019s role, students will gain insights into NLP\u2019s applications, including sentiment detection, \nchatbots, and text comprehension.  The course aims to equip students with a comprehensive \nunderstanding of NLP\u2019s significance and motivate them to tackle complex language-related \nchallenges in the field of computer science and AI.  \n \nCourse learning outcomes \nThe learning outcomes of this course are summarized as follows: \u2013 Comprehension of the \ntheoretical foundations of Natural Language Processing (NLP). \u2013 Familiarity with language \nrepresentation techniques in NLP. \u2013 Hands-on experience in solving real-world problems using \nNLP tools and libraries. \u2013 Proficiency in using Python as the primary programming language for \nNLP tasks. \u2013 Familiarity with frameworks like PyTorch and TensorFlow for NLP applications. \u2013 \nAbility to work with Jupyter Notebooks, NLTK, and spaCy for essential \u201cclassical\u201d NLP tasks. \u2013 \nAbility to use some machine learning and deep learning algorithms to solve NLP applications.  \u2013 \nApplication of NLP techniques to more advanced tasks, such as sentiment analysis, text \nsummarization, and question answering systems. Exploration of natural language \nunderstanding, including ChatGPT prompting and engineering applications with Langchain.  \nDescription \n\u2013  Week 1: Introduction to Natural Language Processing \u2013  Week 2: Text Preprocessing \u2013  \nWeeks 3-5: Text Classification \u2013  Week 6: Vector Semantics \u2013  Week 7: Language Modeling \u2013  \nWeek 8: Text Representation \u2013  Week 9: Introduction to Neural Networks \u2013  Weeks 10-12:  \nChatGPT prompting \u2013  Weeks 13- 14: Projects Presentation and Exam preparation \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1 : \u200bWritten exam\u200b \n(50)Grading scheme: 20 points (0-20)Objectives: \u200bMain test for assessing proficiency of \nstudents.\u200b Assessment rules: Students will get exercises that test their understanding of the \ncourse. Only open books and cheat sheets are permitted; no electronic devices are allowed.\u200b \nAssessment criteria: \u200bThe answers are graded based on correctness, completeness, and clarity.\u200b \nTask 2: \u200bTake-home assignment\u200b(20%)Grading scheme: 20 points (0-20)Objectives: To familiarize \nthe students with the material and NLP libraries and applications.\u200b Assessment rules: \u200bStudents \nwill receive Jupyter notebooks with various NLP applications and will need to complete the \nrequired source code and execute the final notebook.\u200b Assessment criteria: The answers are \ngraded based on correctness, completeness, and clarity.\u200b Task 3: Final Project (30%)Grading \nscheme: 20 points (0-20)Objectives: Choose and implement an NLP application.\u200b Assessment \nrules: Students need to choose the topic of their project, implement it, and present it.\u200b \nAssessment criteria: \u200bThe grade is based on the relevance and the oral presentation of the \nproject. \u200b  Task 4: Written exam\u200b \u2013 RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: \nTest for assessing proficiency of students and help them pass the NLP course \u200b Assessment \n\nrules: \u200bStudents will get exercises that test their understanding of the course. Only open books \nand cheat sheets are permitted; no electronic devices are allowed.\u200b Assessment criteria: The \nanswers are graded based on correctness, completeness, and clarity. \u200b   \nNote \nCourse materials \n \nSyllabus\u2612Yes\u2610NoRemarks:Available on MoodleLiterature list\u2612Yes\u2610NoRemarks:Available on \nMoodleMoodle page\u2612Yes\u2610NoRemarks:https://moodle.uni.lu/course/view.php?id=3921 \n \n\nBACHELOR SEMESTER PROJECT 5 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with their academic advisor(s), learn new technologies related to computer science, \nlearn new knowledge related to computer science, apply the scientific and technical knowledge \nlearned during the BICS, apply the primary and secondary languages knowledge learned during \nthe BICS. The course content and learning objectives are consistent with the BiCS programme \ncontent that the student is following.  \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself.  The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum.  \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project \nAssessment \nAssessment modality:   Combined assessmentAssessment tasksTask 1: Final report and \nin-person presentation 100%)Grading scheme: 20 points (0-20)Objectives: Assess the quality \nand quantity of work done during the semester. Assessment rules: Time constrained \nsubmissions. Assessment criteria: The detailed criteria are specific to each project subject and \napplied on the following weighted deliverables: \u2013 technical & scientific quality of the final report, \nprimary language (60%) \u2013 technical & scientific quality of the final in-person presentation, \nprimary language (30%) \u2013 technical & scientific quality of the final report, secondary language \nsummary (5%) \u2013 technical & scientific quality of the final in-person presentation, secondary \nlanguage summary (5%)  Task 2: RETAKE (100%)Grading scheme: 20 points (0-20)Objectives: \nOption to repeat a previously failed project (with a final assessment of <10 points) with the same \ntopic and under the same supervisor. Assessment rules: The same deliverables as for the \npreviously failed project must be resubmitted under the given time constraints. Assessment \ncriteria: Same as for Task 1.   \nNote \nCourse materials  \n \nSyllabus \u2612Yes\u2610No Remarks: Accessible from the Moodle course page Literature list \n\u2612Yes\u2610No Remarks: Accessible from the Moodle course page Moodle page \u2612Yes\u2610No \nRemarks: https://moodle.uni.lu/course/view.php?id=3334 \n \n\n",
        "6th Semester \nAI FOR EDUCATION \nObjectives \nIn recent years, the term artificial intelligence (AI) has taken on a new meaning. While the \noriginal idea of AI is still to understand and artificially simulate human (cognitive) intelligence, \nthe applications of AI have become increasingly important in recent years. There is currently a \nreal spirit of optimism, more and more new AI companies are being founded, governments, \nindustry and science are investing in research and development projects and in targeted \nknowledge transfer, and with \u2018AI for the common good\u2019 and \u2018AI for humans\u2019 we are all prepared \nfor future developments. One of these developments relates to education (and training), be it in \nschools and universities, in industrial training or in the service sector and customer service. The \nassociated opportunities, but also risks, raise the questions of techniques (human-computer \ninterfaces, intelligent systems) of the extent to which AI can be used sensibly and responsibly \nfor learning and knowledge acquisition. AI-based systems should not necessarily be seen as a \nreplacement for existing learning practices and learning techniques, but as a supplement. The \nspectrum of ideas affected by this is therefore diverse. The aims of this course are to gain an \noverview of applications in the relevant area and to explore your own ideas. \n \nCourse learning outcomes \nThe aim of the course is for each participant to understand the selected scientific and common \nresearch directions in the field of AI/Education (lecture part) and the outline and design of an \nown meaningful application in this field, which has to be finally presented in a Poster Workshop \nat the end oif the course.  \nDescription \nThe theoretical part concerns selected aspects of and takes place in the first part of the \nsemester:\u2022 History of AI and selected basics in view of AI/Education\u2022 Techniques to be used \n(Tutoring systems, Expert systems, projects in the AI4Edu focus area, Virtual Reality, etc.\u2022 \nExamples of AI-based teaching and learning methods\u2022 Ethical aspects: GDPR, EU AI Act\u2022 \nFuture of AI-based Education.The Practical Part concerns a Poster Workshop. It is held in the \nsecond part of the semester.The second part concerns a project and its presentation in a poster \nworkshop at the end of the course. All participants work on a project and design a poster \nreflecting the content of the project. In addition, the project carried out must be summarised in a \nwritten document:\u2022 Choose of a project topic \u2022 Create objectives and work plan\u2022 Discuss the \ndata aspect ( data sources and software tools; collection and preparation of data for AI models ) \nand discuss the technical environment  (e.g. chatbots, recommendation systems, tutoring \nsystem, expert systems, etc.)\u2022 Implement the project incl. a critical reflection and future work, \nbibliography \u2022 Integration into an educational setting + testing. Analysis of feedback. \nAssessment \nAssessment modality: Combined assessmentAssessment tasksPart 1 (30h) \u2013 \nAttendanceGrading scheme: Pass/FailObjectives: Click or tap here to enter text. Attendance is \ncompulsory in the lecture part: the candidate qualifies for the poster workshop if he/she has \nattended at least 8 of the 14 lectures.Pass or FailAssessment rules: The students work \nindependently on the course content. Contact with the teachers is desired.Assessment \ncriteriaPart 2 (30h) \u2013 Active participationGrading scheme:20 points (0-20)100%Objectives: \n\nParticipants familiarise themselves with the project topic, the terminology and the \nobjectives.Assessment rulesEvaluation \u2022Each group member must attend at least 60% = (8 of \n14) lectures and actively contribute to the Poster workshop. If a group member has fulfilled this \n60% condition (and only then), the group member qualifies for the Poster Workshop, in which a \nproject idea relating to AI/Education has to be presented.\u2022\u201dPresented\u201d means that 1.Each group \ncontributes to the implementation of this project idea.2.Each group contributes to the design of a \nposter (at least A3 format) that summarises the most important points of the idea developed. \nExamples of poster designs can be found, for example, in the MNO building (many posters \nhang on the walls on the 3rd and 4th floors). The poster must be scientific, not \nmarketing-orientated (more information see below). 3.Presentation of the idea through a talk \nand demonstrating the implementation in front of a public audience.4.Summarisation of the idea \nin the form of a written Text (in \\LateX ) using a template presented (5 pages minimum, \nEnglish).\u2022The evaluation is as follows:o10% Value of the developed idea. It is important to \nemphasise the benefits of the idea being developed. Is it realisable and does it make sense? \no20% Design of the poster. We follow good practices relating to an effectiveness and \nexpressiveness of the components used (structure of the poster; content of the poster; style like \nfont, colour, etc.)o30% Talk/presentationo40% Written Summary (quality of content, reading and \nsyntax, comprehensibility of the content, completeness of the content, quality of the \\LaTeX \ncode, etc.), which will become a chapter in a final booklet.If Generatlve AI tools (ChatGPT and \nothers) are used, then this must be referenced and the prompts listed in a \u201cTable of prompts\u201d \nnext to the Bibliography chapter. \nNote \nCourse materials \n \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nMoodle page \n \n\u2612Yes  \u2610No \n \n\nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4193 \n \nOther, please specify: \n \n \n\nSOFTWARE ENGINEERING 2 \nObjectives \nSoftware engineering is the discipline concerned with the application of theory, knowledge, and \npractice to effectively and efficiently build reliable software systems that satisfy the requirements \nof customers and users.  The purpose of this course is to address fundamentals and practical \nareas of software engineering not covered in previous courses. This course will be composed of \ntwo parallel tracks, described below.  Track 1. Testing and Validation:  Testing is the \npredominant technique used by the software industry to ensure the final software product \nreliability. It can be roughly compared to a hunt for detecting and eliminating defects and bugs \nfrom a software. Thus, testing and validation aim first at assessing the consistency/conformity of \na product with respect to its specification, and in practice to ensure at least that it will not crash! \nThese activities are thus crucial and costly for software companies, and eventually aim at \nproviding a controlled level of trust in the final product before delivery to the client (and \ncontinuously during maintenance and evolution). Testing is related to all the design stages of the \ndevelopment process and must deal with many application contexts (embedded systems, \nmobile applications, information systems \u2026) and various levels of complexity \n(programming-in-the-small, in-the-large and in-the-duration). Besides the fundamentals of \nsoftware testing, the focus will be on practical techniques that can be applied in real-world \nsoftware development cycles (agile, continuous integration), including techniques to localize and \nremove the detected faults.   Track 2. Software design and architectures: the design of software \nsystems is largely dependent on the accurate analysis of functional and non-functional \nrequirements. This track will address software architectures, design patterns, and, in general, \nnon-functional requirements. The use cases that we will study will be taken from, or inspired by, \nreal-world industrial software.  \n \nCourse learning outcomes \nAt the end of the course the student will:  \n \nRemember, and understand the fundamentals of software testing (the concepts and principles \nbehind the many existing techniques).  \n \nApply classical testing techniques, black-box and glass-box ones, on simple programs.  \n \nSolve a larger software testing problem (integration and system) and create a basic testing \nstrategy.  \n \nAnalyze novel enablers (e.g. AI-assistant, APR) and testing challenges (e.g. testing AI-based \nsystem).  \n \nUnderstand the main software architectural styles and design patterns  \n \nSelect the most suitable software architecture and design patterns for a new project.  \n \n   \n\nDescription \n1. Part 1: Software Testing and Validation 1.1 Fundamentals 1.2. Unit Testing and Diagnosis 1.3. \nIntegration Testing 1.4. Requirements and System Validation 1.5. Transversal aspects to \nfunctional testing  2. Track 2: Software Architectures and Non-functional requirements 2.1. \nNon-functional requirements 2.2. Design patterns 2.3 Software architectural styles  \nAssessment \nAssessment modality: \u200bCombined assessment\u200b Assessment tasks \n \nTask 1: Written exam\u200b \u2013 Mid-term exam (40%)Grading scheme: 20 points (0-20)Objectives: \n\u200bAssessing the students\u2019 understanding of the main concepts presented in the lectures and their \ncapability to solve some exercises based on the algorithms presented in class.\u200b Assessment \nrules: The use of documents (including books and notes) is not authorized. The use of \nelectronic devices is not authorized.\u200b Assessment criteria: Correctness of the answers\u200b Task 2: \nWritten exam\u200b \u2013 Final exam (60%)Grading scheme: 20 points (0-20)Objectives: Assessing the \nstudents\u2019 understanding of the main concepts presented in the lectures and their capability to \nsolve some exercises based on the algorithms presented in class.\u200b Assessment rules: The use \nof documents (including books and notes) is not authorized. The use of electronic devices is not \nauthorized\u200b Assessment criteria: Correctness of the answers\u200b Task 3: RETAKE (100%)Grading \nscheme: 20 points (0-20)Objectives: Assessing the students\u2019 understanding of the main \nconcepts presented in the lectures and their capability to solve some exercises based on the \nalgorithms presented in class.\u200b Assessment rules: \u200bThe use of documents (including books and \nnotes) is not authorized. The use of electronic devices is not authorized\u200b Assessment criteria: \n\u200bCorrectness of the answers\u200b  \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \n\u201cIntroduction to Software Testing\u201d \u2013 Paul Ammann and Jeff Offutt \u2013 ISBN-13: 9780521880381 \u2013 \nCambridge Press \u2013 2008\u201cFoundations of Software Testing\u201d \u2013 Aditya Mathur \u2013 Addison-Wesley \nProfessional \u2013 2007\u201cSoftware Architecture Patterns\u201d \u2013 Mark Richards-O\u2019Reilly, USA-2015 \n \n  \n \n\n\u201cDesign Patterns\u201d Elements of Reusable Object-Oriented Software\u201d \u2013 Erich Gamma, Richard \nHelm, Ralph Johnson, and John Vlissides \u2013 Addison-Wesley \u2013 1994   \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4191 \n \n\nSECURITY 2 \nObjectives \nThe objectives of this course on Information Security are:1) To provide students with \ncomprehensive understanding of public-key cryptography. This will involve studying RSA \nencryption, signatures, Diffie-Hellman key exchange, along with its secure models, the methods \nto encrypt and sign securely using RSA, and a study on Public-key Infrastructure, including \ncertificates and SSL protocol.2) To delve into blockchain protocols with a focus on the basics of \nBitcoin and the crypto blockchain. This will include discussions on privacy and scalability within \nBitcoin and blockchain technology, and an introduction to multi-party computation.3) To explore \ngeneral cryptographic protocols such as Authenticated Key-Exchange (AKE) and \nPassword-based Authenticated Key-Exchange (PAKE). The course also introduces students to \nzero-knowledge protocols, authentication/identification protocols, secure voting schemes, and \nquantum key establishment.4) To provide a solid foundation in system security and trusted \ncomputation by exploring operating system security mechanisms and policies. This includes an \nin-depth study on trusted execution and authenticated boot. Overall, the course aims to furnish \nstudents with a thorough understanding of information security from various angles, preparing \nthem for future careers or research in the field. \n \nCourse learning outcomes \nUpon successful completion of this Information Security course, students should be able to:1) \nComprehend and apply the principles of public-key cryptography, including RSA encryption, \nsignatures, Diffie-Hellman key exchange, and understand how to use RSA securely. They \nshould also be able to navigate the landscape of Public-key Infrastructure, including certificates \nand SSL protocol.2) Understand and explain the basics of blockchain protocols, with a specific \nfocus on Bitcoin and crypto blockchain. Students should be able to discuss issues of privacy \nand scalability and be familiar with multi-party computation. Demonstrate understanding of \nvarious cryptographic protocols, such as Authenticated Key-Exchange (AKE), Password-based \nAuthenticated Key-Exchange (PAKE), zero-knowledge protocols, authentication/identification \nprotocols, and secure voting schemes. They should also understand the basics of quantum key \nestablishment.3) Explain and assess system security mechanisms and policies, with a particular \nemphasis on operating system security. Students should be able to evaluate and discuss trusted \nexecution and authenticated boot.4) Apply the knowledge and skills learned in this course to \nanalyze and solve problems in information security. This will prepare them for roles in the \ninformation security sector, or for further academic study in the field.5) Develop a \ncomprehensive understanding of the current challenges and opportunities in the field of \ninformation security and be prepared to stay updated as the field evolves. \nDescription \n\u200b1. Information security  1.1. Public-key cryptography (Jean-Sebastien Coron) 1.1.1. Introduction \nto public-key cryptography: RSA encryption, signatures, and DH key exchange (recap) 1.1.2. \nSecurity models in cryptography. How to encrypt and sign securely with RSA. OAEP and PSS \n1.1.3. Public-key infrastructure. Certificates, SSL protocol  1.2. Blockchain protocols (Sergiu \nBursuc) 1.2.1. Basics of Bitcoin and of the crypto blockchain 1.2.2. Bitcoin / blockchain privacy \nand scalability 1.2.3. Multi-party computation  1.3. General cryptographic protocols (Peter Ryan) \n1.3.1. Authenticated key-exchange (AKE) and password-based authenticated key-exchange \n\n(PAKE) 1.3.2. Zero-knowledge protocols 1.3.3. Authentication/identification protocols 1.3.4. \nSecure voting schemes 1.3.5. Quantum key establishment  1.4. System security and trusted \ncomputation (Marcus V\u00f6lp) 1.4.1. Operating system security mechanisms and policies 1.4.2. \nTrusted execution and authenticated boot\u200b  \nAssessment \nAssessment modality: Continuous assessmentAssessment tasksTask 1: Take-home assignment \n(21%)Grading scheme: 20 points (0-20)  Objectives: Ability to understand the notions of \npublic-key cryptographyAssessment rules: Students will work on their own.Assessment criteria: \nProduced code and report will be examinedTask 2: Take-home assignment (21%)Grading \nscheme: 20 points (0-20)  Objectives: Understanding of bitcoin and \ncryptocurrenciesAssessment rules: Students will work on their own.Assessment criteria: \nProduced code and report will be examinedTask 3: Take-home assignment (44%)Grading \nscheme: 20 points (0-20)  Objectives: Understanding of cryptographic protocolsAssessment \nrules: Students will work on their own.Assessment criteria: Produced code and report will be \nexaminedTask 4: Take-home assignment (14%)Grading scheme: 20 points (0-20)  Objectives: \nUnderstanding of system securityAssessment rules: Students will work on their \nown.Assessment criteria: Produced code and report will be examinedTask 5: Take-home \nassignment \u2013 Retake (100%)Grading scheme: 20 points (0-20)  Objectives: Understanding of \nthe concepts of the course.Assessment rules: Students will work on their own.Assessment \ncriteria: Produced code and report will be examined. \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nOn Moodle \n \nLiterature list \n \n\u2610Yes  \u2612No \n \nRemarks: \n \n  \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4192 \n\n \nFORMAL METHODS \nObjectives \nThe course starts with a gentle introduction to Software Engineering emphasizing the current \nstate of the profession concerning the constant presence of errors that cause malfunctions in a \nvariety of software systems. It shows how formal methods can help to overcome this \nsituation.After that, the B formal notation is introduced by means of several practical, real-world \nexamples. This allows to introduce set theory, binary relations, predicate calculus and how state \nmachines can be described by using these mathematical tools. It is also shown that state \nmachines are a suitable way of describing a large class of software systems. In particular, it is \nexplained the concept of state invariant and how it can be proved or disproved (informally).As a \nthird step, a tool named Set Log is introduced, and it is emphasised the fact that B specifications \ncan be easily translated into Set Log. Then, it is shown how the translated specification \nbecomes both a formula and a program. As a program, it can be executed thus allowing \nengineers to have a prototype of the system. Besides, it is shown how Set Log can \nautomatically and formally prove or disprove state invariants.Therefore, the course will show \nhow the mere fact of writing a formal specification enables a chain of verification activities that \nhelp to increase the quality of the final product. \n \nCourse learning outcomes \nAt the end of the course the student will be able to:\u2022Know the rationale behind formal methods \nand what they are used for. \u2022Write formal specifications using formal languages.\u2022Specify \nstate-based abstract machines. \u2022Know, understand, and specify invariants.\u2022Know, understand, \nand specify pre and post conditions.\u2022Perform formal verification. \nDescription \nThe following topics are covered in the course:\u2022 Introduction to formal methods\u2022 The B-Method\u2022 \nThe B formal language\u2022 Binary relations, functions, and sequences in set theory \u2022 The {log} \n(read as setlog) tool.\u2022 The {log} language.\u2022 Translation of a B machine into {log}\u2022 Automated \nproofs with {log} \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(30%)Grading scheme: 20 points (0-20)  Objectives: Assessing the students\u2019 understanding of \nhow to specify requirements using one of the formal languages presented in the course and its \nassociated tool support. Assessment rules: The student uses his/her personal computer to write \nthe specification. Any resource is available. The specification is electronically submitted via the \nofficial learning management system used at the institution. Late submissions as well as any \ndamage or corrupted submitted file will be graded with ZERO. Assessment criteria: The \nprovided specification must be correct. Correctness means that it passes the built-in controls of \nthe tool used to write the specification (syntax, type-checking), but also it describes the \nrequested requirements respecting the specification style taught during the course.  Task 2: \nWritten exam (70%)Grading scheme: 20 points (0-20)  Objectives: Idem to Task 1Assessment \nrules: Idem to Task 1Assessment criteria: Idem to Task 1Task 3: Retake (100%)Objectives: A \nstudent who has failed the course is allowed to sit to the next exam call. The objectives are the \n\nsame as Task 2.Grading scheme: 20 points (0-20)  Assessment rules: Idem to Task \n2.Assessment criteria: Idem to Task 2. \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nSchneider, Steve. The B-Method: an Introduction. New York NY: Palgrave Macmillan, 2001. \nPrint. \n \n(Optional complementary reading) Abrial, J., Hoare, A., & Chapron, P. (1996). The B-Book: \nAssigning Programs to Meanings. Cambridge. Available at the LLC (hard copy and online). \n \nLecture notes on B and {Log}. Available on the Moodle\u2019s course\u2019s page on due time. \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4195 \n \n\nINTELLIGENT SYSTEMS 2 \nObjectives \nUnderstand how logics are used for knowledge representation and reasoning, to model \nuncertainty, multi-agent systems, defeasibility, or causality.   \n \nCourse learning outcomes \nAt the end of the course, the student will be able to:\u2022Know and remember what classical, modal, \nand non-monotonic logics are.\u2022Represent facts using these logics.\u2022Reason using these logics. \nDescription \nPart I: Logical foundations.\u2022 Propositional logic\u2022 First-order logic\u2022 Modal logicPart II: Modelling \nagents.\u2022 Belief and preference states \u2022 Belief dynamics\u2022 Action logics\u2022 Multi-agent systemsPart \nIII: Non-monotonic reasoning.\u2022 Classical approaches\u2022 Valuation-based approaches \u2022 Formal \nArgumentationPart IV: Probabilistic reasoning.\u2022 Probabilistic logics\u2022 Inductive probabilistic \ninference \u2022 Causal reasoningPart V: Practical knowledge representation.\u2022 Applications to \nKnowledge Representation \nAssessment \nAssessment modality: Combined assessmentAssessment tasksTask 1: Written exam \n(70%)Grading scheme: 20 points (0-20)  Objectives: Prove that the logical concepts and \nmethods have been understood and can be applied for problem-solving.Assessment rules: \nOpen book exam (printed course materials are allowed).  Assessment criteria: Correctness of \nthe answers to questions.Task 2: Take-home assignment (30%)Grading scheme: 20 points \n(0-20)  Objectives: Weekly test to prove that the concepts and methods are being \nunderstood.Assessment rules: Provide answers in LaTeX or handwritten text.Assessment \ncriteria: Correctness of the answers to questions.Task 3: Written exam \u2013 RETAKE \n(100%)Grading scheme: 20 points (0-20)  Objectives: Prove that the logical concepts and \nmethods have been understood and can be applied for problem-solving.Assessment rules: \nOpen book exam (printed course materials are allowed).  Assessment criteria: Correctness of \nthe answers to questions. \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAvailable on the course\u2019s Moodle page. \n \nLiterature list \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nRelevant texts will be indicated for the individual topics. \n\n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=3918 \n \n\nUSER CENTERED DESIGN \nObjectives \nThe course provides numerous insights into user-centred design methods and tools such as: \n \n(1) choosing and applying design methods, \n \n(2) reporting the findings, and \n \n(3) understanding and interpreting the findings. User-Centred Design provides hands-on \npractice on improving interfaces and products with regards to users\u2019 needs. \n \nCourse learning outcomes \nGaining experience with user-centred design methods though hands-on exercises \n \nDeveloping user-centred thinking skills  \nDescription \n1. Introducing User-Centred System Design  2. Understanding Users & Context   3. Interviewing \nUsers  4. Structuring Findings  5. User Story Mapping  6. Storyboarding 7. Brainstorming and \nPrototyping   8. User Testing   9. Exploring User Interface   10. Usability and User Experience \nScales   11. Effective Reporting   12. Student Presentations 1 13. Student Presentations 2 14. \nWrap-up  \nAssessment \nAssessment modality: Combined assessmentAssessment tasks Task 1: Project Presentation \n(100%)Grading scheme: 20 points (0-20)Objectives: Students will learn how to design and \nevaluate a user-centered interface, and how to effectively communicate the results of their \nproject via presentation. Assessment rules: Throughout the course, students will work \nindividually on a design research project. Each student must show their week-to-week \nhomework during the course to demonstrate how they applied the methods presented during \nthe course, what worked well and what did not, and iteratively improve their designs. \nAssessment criteria: The final evaluation will be based on each student\u2019s presentation of the \ndesign project undertaken during the semester. If the delivered homework assignments do not \nmeet the expected learning objective, the student will be asked to rework their project.  The \nattainment of learning goals will be evaluated through the project presentation based on 3 \ncriteria: application of the introduced methods insights, lessons learned & critical thinking. \npresentation quality Task 2: RETAKE (100%) Grading scheme: 20 points (0-20)Objectives: \nStudents will learn how to design and evaluate a user-centered interface, and how to effectively \ncommunicate the results of their project via presentation. Assessment rules: Video Presentation \nof an Interface Design and Evaluation Project (20 minutes). Assessment criteria: The attainment \nof learning goals will be evaluated through the project presentation based on 3 criteria: \napplication of the introduced methods insights, lessons learned & critical thinkingpresentation \nquality  \nNote \nSyllabus \n \n\n\u22a0Yes  \u2610No \n \nRemarks: \n \nAvailable on Moodle \n \nLiterature list \n \n\u22a0Yes  \u2610No \n \nRemarks: \n \nReference textbook: \n \nCooper, A., Reimann, R., Cronin, D., & Noessel, C. (2014). About face: the essentials of \ninteraction design. John Wiley & Sons. \n \nThe Encyclopaedia of Human-Computer Interaction 2nd Edition \u2013 Available Online: \nhttps://www.interaction-design.org/literature/book/the-encyclopedia-of-human-computer-interacti\non-2nd-ed \n \nRecommended books: \n \nNorman, D. (2013). The design of everyday things: Revised and expanded edition. Basic books. \n \nMoodle page \n \n\u22a0Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4332    \n \nOther, please specify: \n \nClass attendance is not required but highly encouraged. \n \n\nBACHELOR SEMESTER PROJECT 6 \nObjectives \nDuring a standard BSP, students discover research and development domains, produce \nconcrete artefacts related to computer science knowledge areas covered in the BICS, \ncollaborate with UL employees in a project context, learn new technologies related to computer \nscience, learn new knowledge related to computer science, apply the scientific and technical \nknowledge learned during the BICS, apply the primary and secondary languages knowledge \nlearned during the BICS.The course content and learning objectives are consistent with the \nBiCS programme content that the student is following. \n \nCourse learning outcomes \nAt the end of the BSP, the student should have acquired specific learning outcomes defined on \nan individual basis between the academic advisor(s) and him/herself.  The learning outcomes \nshould be agreed upon at the beginning of each project and be aligned with the general BiCS \ncurriculum.  \nDescription \nSpecific course content is defined on an individual basis between the academic advisor(s) and \nthe student for each project.   \nAssessment \nAssessment modality: Combined assessmentAssessment tasks \n \nTask 1: Final report and in-person presentation (100%) Grading scheme: 20 points \n(0-20)Objectives: Assess the quality and quantity of work done during the semester. \nAssessment rules: Time constrained submissions. Assessment criteria: The detailed criteria are \nspecific to each project subject and applied on the following weighted deliverables: technical & \nscientific quality of the final report, primary language (60%) technical & scientific quality of the \nfinal in-person presentation, primary language (30%) technical & scientific quality of the final \nreport, secondary language summary (5%) technical & scientific quality of the final in-person \npresentation, secondary language summary (5%) Task 2: RETAKE (100%) Grading scheme: 20 \npoints (0-20)Objectives: Option to repeat a previously failed project (with a final assessment of \n<10 points) with the same topic and under the same supervisor. Assessment rules: The same \ndeliverables as for the previously failed project must be resubmitted under the given time \nconstraints. Assessment criteria: Same as for Task 1.  \nNote \nSyllabus \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \nLiterature list \n \n\n\u2612Yes  \u2610No \n \nRemarks: \n \nAccessible from the Moodle course page \n \nMoodle page \n \n\u2612Yes  \u2610No \n \nRemarks: \n \nhttps://moodle.uni.lu/course/view.php?id=4197 \n"
    ]
}